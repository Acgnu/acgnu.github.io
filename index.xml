<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Acgnu+</title><link>/</link><description>Recent content on Acgnu+</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 20 Feb 2025 00:50:44 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 LuCI 编写用于 OpenWRT 的远程开机服务</title><link>/posts/embeded/wol-luci/</link><pubDate>Thu, 20 Feb 2025 00:50:44 +0800</pubDate><guid>/posts/embeded/wol-luci/</guid><description>&lt;img src="/posts/embeded/wol-luci/cover.png" alt="Featured image of post 使用 LuCI 编写用于 OpenWRT 的远程开机服务" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近更换了宽带, 拿到了公网IPv6, 刚好又换了一台 小米AX3000T 路由器, 搭载了 ARM 架构的 MT7981B 处理器, 使得安装 OpenWRT 成为了可能. 之前编写的&lt;a class="link" href="../wol" >远程开机程序&lt;/a>是轮询模式的, 在拥有公网的现在, 本着折腾的心态, 就干脆改造成服务端监听模式, 顺便为其增加 UI 方便配置. 查阅资料后了解到可以使用 LuCI, 不过网上教程基本上是 UI 和 服务分离, 这需要分别编译两个软件包 (opkg), 而我其实希望只有一个软件包, 因此有了这篇文章&lt;/p>
&lt;h2 id="需求">需求&lt;/h2>
&lt;p>编写带有 LuCI 的 OpenWRT 软件包 ( Package ), 包含 UI 和服务两部分, 作为服务运行并监听请求, 最终实现效果如下:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 199; flex-basis: 478px">
&lt;a href="/posts/embeded/wol-luci/01.png" data-size="1539x772">&lt;img src="/posts/embeded/wol-luci/01.png"
srcset="/posts/embeded/wol-luci/01_hu8d7382504fa65059fecc6a9b88b122e0_53131_480x0_resize_box_2.png 480w, /posts/embeded/wol-luci/01_hu8d7382504fa65059fecc6a9b88b122e0_53131_1024x0_resize_box_2.png 1024w"
width="1539"
height="772"
loading="lazy"
alt="预览">
&lt;/a>
&lt;figcaption>预览&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="前置条件">前置条件&lt;/h2>
&lt;ul>
&lt;li>公网 IPv6&lt;/li>
&lt;li>域名 (可选)&lt;/li>
&lt;li>OpenWRT 或基于 OpenWRT 的分支系统, 本人安装的是 ImmortalWRT, 后文将只写 ImmortalWRT&lt;/li>
&lt;/ul>
&lt;h2 id="开发准备">开发准备&lt;/h2>
&lt;p>首先需要安装环境, 基于 OpenWRT 的软件包开发通常可以选择使用 SDK 或者完整的源码, 我这边由于是 ImmortalWRT 分支系统, 所以直接下载它的 &lt;strong>&lt;a class="link" href="https://github.com/hanwckf/immortalwrt-mt798x" target="_blank" rel="noopener"
>源码&lt;/a>&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>按照源码仓库 &lt;strong>Requirements&lt;/strong> 章节准备系统和开发工具, 我这里使用的WSL 20.04&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用 &lt;code>git clone&lt;/code> 源码, 我这里存放到目录 &lt;strong>/home/acgnu/code/immortalwrt-mt798x&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>参考源码仓库 &lt;strong>Quickstart&lt;/strong> 章节执行以下步骤&lt;/p>
&lt;ul>
&lt;li>更新 feeds&lt;/li>
&lt;li>安装 feeds&lt;/li>
&lt;li>复制配置文件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意这里不需要编译整个固件, 因此 &lt;code>make&lt;/code> 是不需要执行的&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在源码目录中执行 &lt;code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin make toolchain/compile -j$(nproc)&lt;/code> 编译工具链. 首次编译会生成 menuconfig, 此时不需要修改任何东西直接保存&lt;/p>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>使用WSL的任何 &lt;code>make&lt;/code> 命令都需要加上&lt;code>PATH&lt;/code>, 详见 &lt;a class="link" href="https://openwrt.org/docs/guide-developer/toolchain/wsl" target="_blank" rel="noopener"
>Build system setup WSL&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="编写程序">编写程序&lt;/h2>
&lt;h3 id="创建工程">创建工程&lt;/h3>
&lt;p>在源码目录 &lt;strong>immortalwrt-mt798x/package/feeds/luci&lt;/strong> 下新建工程目录 &lt;strong>luci-app-remotewol&lt;/strong> 以及子目录, 此时完整的工程路径为 &lt;strong>/home/acgnu/code/immortalwrt-mt798x/luci-app-remotewol&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>将工程文件存放在此目录是为了减少编译步骤, 由于固件源码中本身就包含 Luci 模块, 所以不需要其他额外操作. 如果按照 &lt;a class="link" href="https://openwrt.org/docs/guide-developer/start" target="_blank" rel="noopener"
>OpenWRT 官方文档&lt;/a>, 则还需要额外创建模块和链接操作&lt;/p>
&lt;/blockquote>
&lt;p>完整的工程目录如下, 关于每个目录的作用可以参考: &lt;a class="link" href="https://github.com/openwrt/luci/blob/master/docs/Modules.md" target="_blank" rel="noopener"
>LuCI Modules&lt;/a>&lt;/p>
&lt;pre>&lt;code>luci-app-remotewol
|-- luasrc
|-- controller
|-- remotewol.lua #定义 LuCI 页面接口
|-- model
|-- cbi
|-- remotewol.lua #定义配置页面结构, 基于此结构生成页面组件
|-- root
|-- etc
|-- config
|-- remotewol #定义服务需要用到的配置文件
|-- init.d
|-- remotewol #定义 ImmortalWRT 后台服务规则
|-- uci-defaults
|-- luci-app-remotewol #定义软件包安装时执行的脚本
|-- usr
|-- share
|-- rpcd
|-- acl.d
|-- luci-app-remotewol.json #定义 UCI 访问权限
|-- src
Makefile #定义此 src 目录中的源码编译
remotewol.c #实际wol服务源码
Makefile #定义此软件包清单
&lt;/code>&lt;/pre>&lt;h3 id="编写-luci-前端">编写 LuCI 前端&lt;/h3>
&lt;p>LuCI 前端的编写在网上有较多的教程和&lt;a class="link" href="https://github.com/sirpdboy/sirpdboy-package/tree/main" target="_blank" rel="noopener"
>Github源码示例&lt;/a>, 此处不再详细说明, 本项目源码已上传至&lt;a class="link" href="https://github.com/Acgnu/luci-app-remotewol" target="_blank" rel="noopener"
>Github仓库&lt;/a>, 简单介绍一下关键文件&lt;/p>
&lt;ul>
&lt;li>
&lt;p>luasrc/controller/remotewol.lua 定义配置入口. 相关参考: &lt;a class="link" href="https://juejin.cn/post/7343616758325035045" target="_blank" rel="noopener"
>LuCI插件入门&lt;/a>, &lt;a class="link" href="https://www.cnblogs.com/weiweixu/p/4129234.html" target="_blank" rel="noopener"
>开发OpenWrt路由器上LuCI的模块&lt;/a>&lt;/p>
&lt;pre>&lt;code>#此处将此软件包注册在「服务」菜单, 模块为 remotewol, 名称为「远程开机」, 顺序 92
entry({&amp;quot;admin&amp;quot;,&amp;quot;services&amp;quot;,&amp;quot;remotewol&amp;quot;},cbi(&amp;quot;remotewol&amp;quot;), _(&amp;quot;远程开机&amp;quot;), 92)
&lt;/code>&lt;/pre>&lt;p>效果图如下:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 92; flex-basis: 223px">
&lt;a href="/posts/embeded/wol-luci/02.png" data-size="383x412">&lt;img src="/posts/embeded/wol-luci/02.png"
srcset="/posts/embeded/wol-luci/02_hu8104123c71a8033d467bfb0566144372_28607_480x0_resize_box_2.png 480w, /posts/embeded/wol-luci/02_hu8104123c71a8033d467bfb0566144372_28607_1024x0_resize_box_2.png 1024w"
width="383"
height="412"
loading="lazy"
alt="菜单">
&lt;/a>
&lt;figcaption>菜单&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>luasrc/model/cbi/remotewol.lua 定义配置项, LuCI 可根据配置项生成页面. 控件编写可参考: &lt;a class="link" href="https://www.cnblogs.com/lionxy/p/15269112.html" target="_blank" rel="noopener"
>Openwrt LuCI之CBI控件&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>root/etc/config/remotewol 定义实际配置文件, 软件包安装时会按照 root 下的目录结构原样复制此文件到 OpenWRT 系统中, 本例会复制到 /etc/config/remotewol&lt;/p>
&lt;/li>
&lt;li>
&lt;p>root/init.d/remotewol 通过继承 OpenWRT 系统脚本 /etc/rc.common 从而实现定义服务和执行逻辑, 而后可以在「系统」-「启动项」中呈现, 在脚本中实现 &lt;code>start_service&lt;/code>, &lt;code>stop_service&lt;/code>, &lt;code>reload_service&lt;/code> 等函数即可从页面按钮中调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 280; flex-basis: 673px">
&lt;a href="/posts/embeded/wol-luci/03.png" data-size="1300x463">&lt;img src="/posts/embeded/wol-luci/03.png"
srcset="/posts/embeded/wol-luci/03_hu55179c5aec5cc4897c6642bb943226d9_42225_480x0_resize_box_2.png 480w, /posts/embeded/wol-luci/03_hu55179c5aec5cc4897c6642bb943226d9_42225_1024x0_resize_box_2.png 1024w"
width="1300"
height="463"
loading="lazy"
alt="启动项">
&lt;/a>
&lt;figcaption>启动项&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>root/uci-defaults/luci-app-remotewol 软件包安装时自动执行的脚本, 这里主要需要给 root/init.d/remotewol 中的脚本文件赋予可执行权限和替换旧配置, 默认不可执行, 会导致服务脚本执行出错&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="编写-luci-服务端">编写 LuCI 服务端&lt;/h3>
&lt;p>因为这是基于 LuCI 的前端和服务端合并的软件包, 因此服务端源码有以下要求&lt;/p>
&lt;ul>
&lt;li>C 源码需要放在 src 目录中&lt;/li>
&lt;li>src 目录中需要包含 Makefile 以指示如何编译&lt;/li>
&lt;/ul>
&lt;p>C 源码编写没有特殊要求, 功能实现并非本文重点, &lt;a class="link" href="https://github.com/Acgnu/luci-app-remotewol/blob/master/src/remotewol.c" target="_blank" rel="noopener"
>src/remotewol.c&lt;/a> 内容大致为先读取 &lt;a class="link" href="https://github.com/Acgnu/luci-app-remotewol/blob/master/root/etc/config/remotewol" target="_blank" rel="noopener"
>/etc/config/remotewol&lt;/a> 中的配置, 然后启动一个 IPv6 的 UDP 监听. 当收到来自客户端的启动命令时, 执行唤醒局域网内的设备.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 100; flex-basis: 240px">
&lt;a href="/posts/embeded/wol-luci/05.jpg" data-size="836x833">&lt;img src="/posts/embeded/wol-luci/05.jpg"
srcset="/posts/embeded/wol-luci/05_hue266f3e4449a5b91e4bebc8d6c0b1501_91094_480x0_resize_q75_box.jpg 480w, /posts/embeded/wol-luci/05_hue266f3e4449a5b91e4bebc8d6c0b1501_91094_1024x0_resize_q75_box.jpg 1024w"
width="836"
height="833"
loading="lazy"
alt="main">
&lt;/a>
&lt;figcaption>main&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>而 src/Makefile 中的代码如下:&lt;/p>
&lt;pre>&lt;code>%.o: %.c
$(CC) $(CPPFLAGS) $(CFLAGS) $(FPIC) -Wall -c -o $@ $&amp;lt;
clean:
rm -f remotewol *.o
remotewol: remotewol.o
$(CC) $(LDFLAGS) -o $@ $^ -ldl
compile: remotewol
install: compile
mkdir -p $(DESTDIR)/usr/bin
cp remotewol $(DESTDIR)/usr/bin/remotewol
&lt;/code>&lt;/pre>&lt;p>基本上是模板代码, 主要提供编译, 清理, 安装. 一般只需要修改其中的程序名称和路径部分即可, 执行打包的时候会被调用.&lt;/p>
&lt;h2 id="编译和打包">编译和打包&lt;/h2>
&lt;p>&lt;strong>在源码根目录&lt;/strong>, 首先执行 &lt;code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin make menuconfig&lt;/code> 进入构建配置菜单, 检查并确保 「LuCI」-「Application」中的 luci-app-remotewol 被选上, 如下图&lt;/p>
&lt;p>&lt;figure style="flex-grow: 186; flex-basis: 448px">
&lt;a href="/posts/embeded/wol-luci/04.png" data-size="1360x728">&lt;img src="/posts/embeded/wol-luci/04.png"
srcset="/posts/embeded/wol-luci/04_hu8d94a7b65def4c836131859098da2fd4_119111_480x0_resize_box_2.png 480w, /posts/embeded/wol-luci/04_hu8d94a7b65def4c836131859098da2fd4_119111_1024x0_resize_box_2.png 1024w"
width="1360"
height="728"
loading="lazy"
alt="LuCI配置">
&lt;/a>
&lt;figcaption>LuCI配置&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>保存后, 执行以下命令进行构建&lt;/p>
&lt;p>&lt;code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin make package/feeds/luci/luci-app-remotewol/compile -j$(nproc)&lt;/code>&lt;/p>
&lt;p>编译完成后, 将会在 immortalwrt-mt798x/bin/packages/aarch64_cortex-a53/luci 目录下生成 .ipk 文件, 即 ImmortalWRT 的软件包文件&lt;/p>
&lt;blockquote>
&lt;p>编译时也可以执行 &lt;code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin make package/feeds/luci/luci-app-remotewol/{clean,compile} -j$(nproc)&lt;/code> , 这样可以在编译之前先清理&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装和卸载软件包">安装和卸载软件包&lt;/h2>
&lt;p>安装就很简单了, 通过 &lt;code>scp&lt;/code> 命令把 xxx.ipk 发送到路由器的任意目录, 然后执行 &lt;code>opkg install xxx.ipk&lt;/code> 即可安装, 安装完成后就可以在「服务」菜单中看到了. 如果要卸载的话可以执行 &lt;code>opkg remove xxx&lt;/code> 就可以连带配置文件和脚本一并删除了. 详细介绍请戳 &lt;a class="link" href="https://wiki.8devices.com/openwrt:recipes:opkg" target="_blank" rel="noopener"
>Package management with OPKG&lt;/a>&lt;/p></description></item><item><title>关于Adobe Flash失效后如何继续使用某弹播放器</title><link>/posts/hack/xtan/flashnext/</link><pubDate>Thu, 22 Aug 2024 00:50:44 +0800</pubDate><guid>/posts/hack/xtan/flashnext/</guid><description>&lt;img src="/posts/hack/xtan/flashnext/cover.png" alt="Featured image of post 关于Adobe Flash失效后如何继续使用某弹播放器" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>本文再续 &lt;a class="link" href="../exe" >某琴吧EXE播放器破解记录&lt;/a>, 意在解决Adobe停止维护Flash后, 整个Flash失效导致播放器无法使用的问题.&lt;/p>
&lt;p>2020年末Adobe公司停止了对Flash的维护, 随之而来的是浏览器删除了对Flash的支持, 包括Windows系统内安装的Flash也无法继续使用, 而我们获取乐谱资源需要用到Flash版的某琴吧播放器, 之前使用的是&lt;code>AxShockwaveFlash&lt;/code>, 这个组件也是引用了Windows上安装的Flash, 只能寻找其他替代方案&lt;/p>
&lt;blockquote>
&lt;p>此文章编辑于2024年8月, 实际改造在2021年5月就已完成, 因此没有早期Flash失效截图. 另外某琴吧在2023年再次更新, 用手机版APP取代了PC版播放器, 后续的乐谱播放文件变更为&lt;code>.ypn1&lt;/code> (通过前两次规律使用 &lt;code>yp&lt;/code> 当前缀, 再加两位数组/字母用脚本穷举得出), 新格式只能在手机上用APP播放. 但暂不影响乐谱页的获取.&lt;/p>
&lt;/blockquote>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>使Flash版某琴吧播放器可用&lt;/p>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>首先简单回顾一下破解过程, 我们先反编译了Flash版的某琴吧播放器, 然后在源码中增加了一个&lt;code>swfExtGetypURL&lt;/code>方法, 此方法根据传入的乐谱ID返回乐谱资源URL, 再通过&lt;code>ExternalInterface.addCallback&lt;/code>将该方法暴露给Flash容器, 我们就可以使用容器与Flash通信了. 而现在的问题是, 容器即&lt;code>AxShockwaveFlash&lt;/code>组件由于Flash停止维护已经用不了了, 那么有没有什么办法能够继续运行Flash呢? 答案是有的, 我们还有另一种独立的Flash Player应用程序, 它不需要安装, 下载到电脑后双击即可运行&lt;/p>
&lt;p>&lt;figure style="flex-grow: 190; flex-basis: 456px">
&lt;a href="/posts/hack/xtan/flashnext/1.png" data-size="417x219">&lt;img src="/posts/hack/xtan/flashnext/1.png"
srcset="/posts/hack/xtan/flashnext/1_hu58fa83f76cdc50691390964a6dfa1201_5146_480x0_resize_box_2.png 480w, /posts/hack/xtan/flashnext/1_hu58fa83f76cdc50691390964a6dfa1201_5146_1024x0_resize_box_2.png 1024w"
width="417"
height="219"
loading="lazy"
alt="Adobe Flash Player 29截图">
&lt;/a>
&lt;figcaption>Adobe Flash Player 29截图&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>如上图所示, 启动之后界面是空白的, 因为没有运行Flash文件, 我们可以单击 文件 - 打开, 来选择一个&lt;code>.swf&lt;/code>后缀的Flash文件进行播放, 例如下图是来自QQ秀的&lt;code>.swf&lt;/code>文件运行效果&lt;/p>
&lt;p>&lt;figure style="flex-grow: 109; flex-basis: 263px">
&lt;a href="/posts/hack/xtan/flashnext/3.png" data-size="331x301">&lt;img src="/posts/hack/xtan/flashnext/3.png"
srcset="/posts/hack/xtan/flashnext/3_hu7b5c7312fc7bea6799449d4b07168a61_38842_480x0_resize_box_2.png 480w, /posts/hack/xtan/flashnext/3_hu7b5c7312fc7bea6799449d4b07168a61_38842_1024x0_resize_box_2.png 1024w"
width="331"
height="301"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>实际上当时下载到的最新版本为Adobe Flash Player 3x, 这些版本也受到了停止维护的影响无法使用, 直到我逐个尝试旧版之后才找到了可用的版本 29&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>如何传入参数?&lt;/strong>&lt;/p>
&lt;p>根据 &lt;a class="link" href="../flash" >某琴吧Flash播放器破解记录&lt;/a> 中的描述, 打开某琴吧播放器是需要传入一个&lt;code>id&lt;/code>参数的, 那么这个图形化界面我们应该如何传入参数呢? 实际上我们可以手动在打开的文件后面键入&lt;code>?id=xx&lt;/code>, 就可以把&lt;code>id&lt;/code>参数传给某琴吧播放器了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 153; flex-basis: 369px">
&lt;a href="/posts/hack/xtan/flashnext/2.png" data-size="463x301">&lt;img src="/posts/hack/xtan/flashnext/2.png"
srcset="/posts/hack/xtan/flashnext/2_hu7ef1f64de5ce6734e26839ac9cb5a89d_10041_480x0_resize_box_2.png 480w, /posts/hack/xtan/flashnext/2_hu7ef1f64de5ce6734e26839ac9cb5a89d_10041_1024x0_resize_box_2.png 1024w"
width="463"
height="301"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>如何使用命令行启动?&lt;/strong>&lt;/p>
&lt;p>我们希望实际执行的时候由程序进行控制, 而不是每次都需要人为在界面上操作, 我们知道Windows可以通过命令行的方式启动&lt;code>.exe&lt;/code>文件, 并附加执行参数传递给被执行的文件, 但前提是被执行文件支持命令行传参才行, 那么Flash Player是否支持呢? 答案是支持的, 我们可以通过以下方式来启动并播放一个Flash文件&lt;/p>
&lt;pre>&lt;code>flashplayer.exe file.swf?id=666
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>其实Flash Player是否支持传参, 以及具体传入格式并没有查到相关文档, 此处仅凭借经验以及猜测得知&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>如何实现某琴吧播放器与Flash Player通信?&lt;/strong>&lt;/p>
&lt;p>很遗憾, 我们并不知道如何让Flash Player和某琴吧播放器通信, 因此我们不能采用之前外部接口的方式去获取乐谱资源, 但是我们可以依然可以改造一下某琴吧播放器, &lt;strong>此前是容器向某琴吧播放器发起调用获取到乐谱资源URL&lt;/strong>, 现在可以&lt;strong>改造为某琴吧播放器启动后将乐谱资源URL参数通过HTTP主动请求到我们搭建的Web服务上&lt;/strong>, 再由Web服务器解析后去下载乐谱资源&lt;/p>
&lt;h2 id="实践">实践&lt;/h2>
&lt;p>&lt;strong>修改某琴吧播放器源码&lt;/strong>&lt;/p>
&lt;p>根据 &lt;a class="link" href="../flash" >某琴吧Flash播放器破解记录&lt;/a> 我们知道要得到乐谱资源URL, 就需要调用&lt;code>CLib.getURL&lt;/code>并传入乐谱ID, 在之前修改的基础上, 我们再次修改一下 &lt;code>onSoundsReady&lt;/code> 方法, 如下所示&lt;/p>
&lt;pre>&lt;code>internal static function onSoundsReady(arg1:Event) : void
{
swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
var loc2:* = loc1.getDefinition(&amp;quot;Sounds&amp;quot;) as Class;
CLib.clib = loc2.cLibInit();
if(utils.Func.ypadId != 0) {
//由于 Flash Player 不可交互, 修改为启动时将琴谱地址上传, 宿主判断是否下载
var url:* = CLib.getURL(utils.Func.ypadId);
//url:* 结果为 http://www.和谐.com/flash_get_yp_info.php?ypid=66138&amp;amp;amp;sccode=77c83a7bf44542486ff37815ab75c147&amp;amp;amp;r1=9185&amp;amp;amp;r2=6640&amp;amp;amp;input=123
var args:* = &amp;quot;?&amp;quot; + url.split(&amp;quot;?&amp;quot;)[1]
urlLoader3 = new flash.net.URLLoader();
urlLoader3.load(new flash.net.URLRequest(Config.flash_yuepu_fetch_URL + args));
}
}
&lt;/code>&lt;/pre>&lt;p>代码相较于之前的版本, 仅仅只是在初始化&lt;code>CLib&lt;/code>之后, 增加了一个发起HTTP请求的代码, 具体解释如下&lt;/p>
&lt;ol>
&lt;li>&lt;code>utils.Func.ypadId&lt;/code>是某琴吧播放器启动后, 会把传入到播放器的&lt;code>id&lt;/code>参数, 赋值于此&lt;/li>
&lt;li>&lt;code>CLib&lt;/code>初始化完成之后, 调用一次&lt;code>CLib.getURL&lt;/code>, 得到该乐谱的资源URL&lt;/li>
&lt;li>通过字符串的&lt;code>split&lt;/code>方法, 把原始资源文件地址中的域名和参数分割&lt;/li>
&lt;li>丢弃原始资源的域名部分, 将参数部分拼接到&lt;code>Config.flash_yuepu_fetch_URL&lt;/code>后, 这是一个本地搭建的Web服务地址, 具体为 &lt;a class="link" href="" >http://localhost:7777/yuepu/fetch&lt;/a>, 而后&lt;code>urlLoader3.load&lt;/code>将会发起HTTP请求&lt;/li>
&lt;/ol>
&lt;p>此时完整的流程为, 某琴吧播放器启动后, 初始化的方法&lt;code>init1&lt;/code>中会调用&lt;code>CLib.myLoadSwf&lt;/code>, 从而加载音色库, 当音色库加载完成之后, 就会调用回调函数&lt;code>onSoundsReady&lt;/code>, 执行到上面的代码&lt;/p>
&lt;p>&lt;strong>添加信任文件&lt;/strong>&lt;/p>
&lt;p>默认情况下, Flash Player 8 以后的版本&lt;font color="red">禁止本地&lt;code>.swf&lt;/code>发送Internet请求&lt;/font>, 可参阅 &lt;a class="link" href="https://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager04.html#117502" target="_blank" rel="noopener"
>关于Flash Player的安全说明&lt;/a>, 因此我们还需要为某琴吧播放器添加信任文件来解除限制&lt;/p>
&lt;p>在Windows中的&lt;code>%APPDATA%\Macromedia\Flash Player\#Security\FlashPlayerTrust&lt;/code>目录下创建一个&lt;code>.cfg&lt;/code>文件, 文件名称随意, 例如&lt;code>acgnux_flash.cfg&lt;/code>, 并添加需要被执行的&lt;code>.swf&lt;/code>目录作为内容&lt;/p>
&lt;p>&lt;figure style="flex-grow: 349; flex-basis: 837px">
&lt;a href="/posts/hack/xtan/flashnext/4.png" data-size="747x214">&lt;img src="/posts/hack/xtan/flashnext/4.png"
srcset="/posts/hack/xtan/flashnext/4_hua97852b9f50607a2a5532baa20701adb_16075_480x0_resize_box_2.png 480w, /posts/hack/xtan/flashnext/4_hua97852b9f50607a2a5532baa20701adb_16075_1024x0_resize_box_2.png 1024w"
width="747"
height="214"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>当然, 我们也可以使用代码来自动化这个流程&lt;/p>
&lt;pre>&lt;code>public static void WriteTrustFile()
{
var appDataPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
FileUtil.SaveStringToFile(Environment.CurrentDirectory + @&amp;quot;\Assets\flash&amp;quot;, appDataPath + @&amp;quot;\Macromedia\Flash Player\#Security\FlashPlayerTrust\&amp;quot;, &amp;quot;acgnux_flash.cfg&amp;quot;);
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>填写为目录表示该目录下所有&lt;code>.swf&lt;/code>文件都受到信任, 也可以只填写单个&lt;code>.swf&lt;/code>文件路径, 表示只信任这一个&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Web服务器中代码&lt;/strong>&lt;/p>
&lt;p>在本地搭建&lt;code>7777&lt;/code>端口的Web服务, 并监听地址&lt;code>/yuepu/fetch&lt;/code>请求, &lt;code>C#&lt;/code>示例代码如下:&lt;/p>
&lt;pre>&lt;code>private void FetchPianoScore(HttpListenerContext httpListenerContext)
{
//传入参数样本 ?ypid=29189&amp;amp;sccode=0373ef7aa7c3e092b8c4e09748574186&amp;amp;r1=8538&amp;amp;r2=5971&amp;amp;input=123
Ypid = Convert.ToInt32(httpListenerContext.Request.QueryString[&amp;quot;ypid&amp;quot;]),
SheetUrl = string.Format(&amp;quot;http://www.和谐.com/flash_get_yp_info.php?ypid={0}&amp;amp;sccode={1}&amp;amp;r1={2}&amp;amp;r2={3}&amp;amp;input=123&amp;quot;,
httpListenerContext.Request.QueryString[&amp;quot;ypid&amp;quot;],
httpListenerContext.Request.QueryString[&amp;quot;sccode&amp;quot;],
httpListenerContext.Request.QueryString[&amp;quot;r1&amp;quot;],
httpListenerContext.Request.QueryString[&amp;quot;r2&amp;quot;])
}
&lt;/code>&lt;/pre>&lt;p>我们将得到的四个核心参数, 与真正的资源服务器地址结合, 再次组合成完整的URL后就可以获取乐谱资源了&lt;/p>
&lt;h2 id="后续步骤">后续步骤&lt;/h2>
&lt;p>后续就比较简单了, 主要就是自动抓取乐谱, 在&lt;code>C#&lt;/code>主要可以拆分为以下几个步骤&lt;/p>
&lt;ol>
&lt;li>自增得到一个乐谱ID, 通过&lt;code>Process.Start&lt;/code>启动Flash Player&lt;/li>
&lt;/ol>
&lt;pre>&lt;code> Process.Start(new ProcessStartInfo()
{
FileName = &amp;quot;flashplayer.exe&amp;quot;,
Arguments = &amp;quot;Main.swf?id=666&amp;quot;
});
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>某琴吧播放器在Flash Player中运行之后, 会主动发起一个HTTP请求到&lt;a class="link" href="" >http://localhost:7777/yuepu/fetch&lt;/a> 并附带关键参数&lt;/li>
&lt;li>Web服务接收到请求之后, 可以根据传入的乐谱ID参数, 来判断这个乐谱文件是否已经下载过, 如果已经下载过, 则不做任何操作, 如果没有下载过, 则开始执行下载操作&lt;/li>
&lt;/ol></description></item><item><title>基于Padavan路由器系统的远程网络唤醒(WOL)工具开发</title><link>/posts/embeded/wol/</link><pubDate>Mon, 06 Mar 2023 00:50:44 +0800</pubDate><guid>/posts/embeded/wol/</guid><description>&lt;img src="/posts/embeded/wol/cover.png" alt="Featured image of post 基于Padavan路由器系统的远程网络唤醒(WOL)工具开发" />&lt;h2 id="目录">目录&lt;/h2>
&lt;ol>
&lt;li>&lt;a class="link" href="#1" >需求&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#2" >准备工作&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#3" >基本思路&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#4" >编写服务端&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#5" >编写客户端&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#6" >测试效果&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#7" >遇到的问题&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id='1'>需求&lt;/h2>
&lt;p>由于有时需要远程家里的电脑所以是24小时待机的, 然而大部分时间其实都是用不上的, 后来发现家里电费居高不下跟电脑有很大的关系, 财库已空的我决定设置一套网络唤醒&lt;/p>
&lt;p>首先, 需要购买专用的唤醒设备例如网卡, 开关, 支持WOL的路由器之类的就不考虑了, 家里也没有多余的设备, 于是打算给路由器刷第三方系统之后由路由器来唤醒, 我的路由器是小米的AC2100, 刷了Padavan, 刷完后自带两个内网管理插件&lt;/p>
&lt;ul>
&lt;li>DDNS插件: 因为申请不到公网IP, 所以用不了&lt;/li>
&lt;li>Zerotier内网穿透插件: 配置后家里的网络连不上Zerotier服务, 查了一下说是被某些运营商屏蔽了(无语), 所以也用不了&lt;/li>
&lt;/ul>
&lt;p>虽然可以考虑刷支持其他内网穿透工具的固件, 但不想一个一个试, 且免费的内网穿透稳定性和速率通常都不太行, 最终决定自行编写一个WOL程序放到路由器执行&lt;/p>
&lt;h2 id='2'>准备工作&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>一台支持运行三方程序的路由器, OpenWRT或Padavan等. 在路由器「DHCP」管理页中为需要唤醒的电脑设置固定IP&lt;/p>
&lt;/li>
&lt;li>
&lt;p>电脑设置启用网络唤醒. &lt;a class="link" href="https://post.smzdm.com/p/a7d70m4g/" target="_blank" rel="noopener"
>如何设置网络唤醒?&lt;/a> 以我的设备为例:&lt;br>
主板「B460M AORUS ELITE (rev. 1.0) 」默认开启了网络唤醒, 无需修改任何设置.&lt;br>
网卡「Intel(R) Ethernet Connection (12) I219-V」设置如下:&lt;/p>
&lt;ul>
&lt;li>关闭「以太网节能」, &lt;strong>可以解决关机时间过长后无法唤醒的问题&lt;/strong>, 其他唤醒相关设置均已默认开启, 无需改动&lt;br>
&lt;figure style="flex-grow: 144; flex-basis: 347px">
&lt;a href="/posts/embeded/wol/1219v.png" data-size="434x300">&lt;img src="/posts/embeded/wol/1219v.png"
srcset="/posts/embeded/wol/1219v_hu86d9bce053bbd32edebd40d8cbe0794b_94779_480x0_resize_box_2.png 480w, /posts/embeded/wol/1219v_hu86d9bce053bbd32edebd40d8cbe0794b_94779_1024x0_resize_box_2.png 1024w"
width="434"
height="300"
loading="lazy"
alt="1219v">
&lt;/a>
&lt;figcaption>1219v&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>测试效果. 反复关机测试并不方便, 我们可以下载&lt;a class="link" href="http://www.cmsoft.cn/resource/102.html" target="_blank" rel="noopener"
>网络调试助手(NetAssist)&lt;/a>在开机状态下模拟接收&lt;/p>
&lt;ul>
&lt;li>协议类型选UDP&lt;/li>
&lt;li>本机主机地址填本机IP地址 (例: 192.168.1.123)&lt;/li>
&lt;li>端口填9, 因为魔术包是通过9端口收发的&lt;/li>
&lt;/ul>
&lt;p>当收到数据包时就会展示在右侧
&lt;figure style="flex-grow: 117; flex-basis: 282px">
&lt;a href="/posts/embeded/wol/test.png" data-size="664x565">&lt;img src="/posts/embeded/wol/test.png"
srcset="/posts/embeded/wol/test_huf6163f6eeade4c09a9bd5914ed7e17df_32695_480x0_resize_box_2.png 480w, /posts/embeded/wol/test_huf6163f6eeade4c09a9bd5914ed7e17df_32695_1024x0_resize_box_2.png 1024w"
width="664"
height="565"
loading="lazy"
alt="NetAssist">
&lt;/a>
&lt;figcaption>NetAssist&lt;/figcaption>
&lt;/figure>
然后可以在手机上微信搜索小程序「网络唤醒WakeOnLan」, 确保手机与电脑出于同一个网络, 如下图所示&lt;strong>填写真实IP和MAC&lt;/strong>
&lt;figure style="flex-grow: 53; flex-basis: 127px">
&lt;a href="/posts/embeded/wol/wc_wol.png" data-size="414x780">&lt;img src="/posts/embeded/wol/wc_wol.png"
srcset="/posts/embeded/wol/wc_wol_hud09f46f92c69fb9aff47413dc4456e66_38256_480x0_resize_box_2.png 480w, /posts/embeded/wol/wc_wol_hud09f46f92c69fb9aff47413dc4456e66_38256_1024x0_resize_box_2.png 1024w"
width="414"
height="780"
loading="lazy"
alt="测试效果">
&lt;/a>
&lt;figcaption>测试效果&lt;/figcaption>
&lt;/figure>
点击「唤醒WakeUp」即可看到电脑收到数据包了, 收包没有问题后可以关闭电脑测试&lt;/p>
&lt;/li>
&lt;li>
&lt;p>一台云服务器 (我这里用的是 &lt;a class="link" href="https://bilib.cn" target="_blank" rel="noopener"
>神秘哥们&lt;/a> 的服务器, 再次感谢 &lt;a class="link" href="https://bilib.cn" target="_blank" rel="noopener"
>神秘哥们&lt;/a> 的免费赞助)&lt;/p>
&lt;blockquote>
&lt;p>没有云服务器? 也可以, 例如在代码托管网站上传一个文本文件, 编写的程序去请求这个文件并解析内容, 0代表不需要开机, 1代表需要. 需要开机的时候登录托管网站修改内容即可&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>搭建开发环境. 我的路由器是MIPS架构处理器, 需要&lt;a class="link" href="../mipsel" >搭建MIPS交叉编译环境&lt;/a>, 其他架构自行查阅资料&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id='3'>基本思路&lt;/h2>
&lt;p>由于开机需求对时效性要求并不高, 所以程序周期执行即可, 由以下三部分组成:
&lt;figure style="flex-grow: 150; flex-basis: 360px">
&lt;a href="/posts/embeded/wol/framework.png" data-size="600x400">&lt;img src="/posts/embeded/wol/framework.png"
srcset="/posts/embeded/wol/framework_hud0745bef77914fa43b619abfd6d606fe_76772_480x0_resize_box_2.png 480w, /posts/embeded/wol/framework_hud0745bef77914fa43b619abfd6d606fe_76772_1024x0_resize_box_2.png 1024w"
width="600"
height="400"
loading="lazy"
alt="方案">
&lt;/a>
&lt;figcaption>方案&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>服务端&lt;/strong>: 即云服务器上运行的HTTP服务, 提供两个接口
&lt;ul>
&lt;li>接收命令: 接收来自控制端的命令&lt;/li>
&lt;li>查询命令: 提供查询最新的命令的接口给客户端&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>客户端&lt;/strong>: 运行在路由器上, 由crontab周期执行, 需要开机时唤醒电脑, Padavan可以在管理页面直接设置crontab, 如图所示, 填写 &lt;code>*/1 * * * * /var/wol&lt;/code> 表示每隔一分钟执行 &lt;code>/var&lt;/code> 目录下的「wol」程序
&lt;figure style="flex-grow: 95; flex-basis: 228px">
&lt;a href="/posts/embeded/wol/padavan-cron.png" data-size="869x912">&lt;img src="/posts/embeded/wol/padavan-cron.png"
srcset="/posts/embeded/wol/padavan-cron_hu77bca711fb0c121b8016295804c3abc6_386739_480x0_resize_box_2.png 480w, /posts/embeded/wol/padavan-cron_hu77bca711fb0c121b8016295804c3abc6_386739_1024x0_resize_box_2.png 1024w"
width="869"
height="912"
loading="lazy"
alt="crontab">
&lt;/a>
&lt;figcaption>crontab&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>据说路由器重启后crontab会失效, 相关帖子: &lt;a class="link" href="https://www.right.com.cn/forum/thread-5763615-1-1.html" target="_blank" rel="noopener"
>关于padavan的crontab&lt;/a>, 如果不放心的话, 配置好crontab后在图示位置点击「提交」即可
&lt;figure style="flex-grow: 103; flex-basis: 248px">
&lt;a href="/posts/embeded/wol/save_storage.png" data-size="869x838">&lt;img src="/posts/embeded/wol/save_storage.png"
srcset="/posts/embeded/wol/save_storage_hu870c801a1cd1cc22cf8f63a91295f4c3_362621_480x0_resize_box_2.png 480w, /posts/embeded/wol/save_storage_hu870c801a1cd1cc22cf8f63a91295f4c3_362621_1024x0_resize_box_2.png 1024w"
width="869"
height="838"
loading="lazy"
alt="storage">
&lt;/a>
&lt;figcaption>storage&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;/blockquote>
&lt;ol start="3">
&lt;li>&lt;strong>控制端&lt;/strong>: 由于接收命令是HTTP接口, 所以控制端可以用任何实现, 本文不提供实现, 仅通过&lt;code>curl&lt;/code>命令执行&lt;/li>
&lt;/ol>
&lt;h2 id='4'>编写服务端&lt;/h2>
&lt;p>服务端业务简单, 综合开发速度和服务器资源采用Go语言开发, 新建&lt;strong>wol-server&lt;/strong>项目, 添加main.go, 完整代码如下:&lt;/p>
&lt;pre>&lt;code>package main
import &amp;quot;fmt&amp;quot;
import &amp;quot;net/http&amp;quot;
var wol = 0
func main() {
http.HandleFunc(&amp;quot;/command/wol/push&amp;quot;, PushCommand)
http.HandleFunc(&amp;quot;/command/wol/fetch&amp;quot;, FetchCommand)
http.ListenAndServe(&amp;quot;:9080&amp;quot;, nil)
}
func FetchCommand(w http.ResponseWriter, r *http.Request) {
fmt.Fprintf(w, &amp;quot;%v&amp;quot;, wol)
wol = 0
}
func PushCommand(w http.ResponseWriter, r *http.Request) {
if r.Method != http.MethodPut {
http.Error(w, &amp;quot;0&amp;quot;, http.StatusMethodNotAllowed)
return
}
wol = 1
fmt.Fprintf(w, &amp;quot;%v&amp;quot;, wol)
}
&lt;/code>&lt;/pre>&lt;p>代码很少简单说明一下&lt;/p>
&lt;ul>
&lt;li>在9080端口开启HTTP服务, 暴露两个接口&lt;code>/command/wol/push&lt;/code>和&lt;code>/command/wol/fetch&lt;/code>, 分别对应实现&lt;code>PushCommand&lt;/code>和&lt;code>PushCommand&lt;/code>&lt;/li>
&lt;li>&lt;code>PushCommand&lt;/code>将由控制端调用, 为避免在浏览器误操作限制了一下请求方式只能为PUT, 收到请求后会将开机标识&lt;code>wol&lt;/code>设置为1&lt;/li>
&lt;li>&lt;code>FetchCommand&lt;/code>将由路由器调用, 收到请求后会首先返回开机标识&lt;code>wol&lt;/code>, 然后把&lt;code>wol&lt;/code>再次设置为0, 避免重复触发&lt;/li>
&lt;/ul>
&lt;p>云服务器是Linux 64位系统, 而开发环境是Windows 64, 我们需要交叉编译为Liunx的可执行文件&lt;/p>
&lt;ol>
&lt;li>在PowerShell中执行&lt;code>$Env:GOOS=&amp;quot;linux&amp;quot;&lt;/code>命令将目标系统设置为Linux&lt;/li>
&lt;li>在开发工具终端中进入项目目录, 执行&lt;code>go build&lt;/code>编译得到&lt;strong>wol-server&lt;/strong>可执行文件
&lt;figure style="flex-grow: 435; flex-basis: 1046px">
&lt;a href="/posts/embeded/wol/term.png" data-size="170x39">&lt;img src="/posts/embeded/wol/term.png"
srcset="/posts/embeded/wol/term_hu5a740896c23e062e205783a2c9d27d61_2096_480x0_resize_box_2.png 480w, /posts/embeded/wol/term_hu5a740896c23e062e205783a2c9d27d61_2096_1024x0_resize_box_2.png 1024w"
width="170"
height="39"
loading="lazy"
alt="build">
&lt;/a>
&lt;figcaption>build&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;li>复制&lt;strong>wol-server&lt;/strong>到Linux中并执行&lt;code>./wol-server&lt;/code>启动服务&lt;/li>
&lt;li>在CMD中执行命令&lt;code>curl http://服务器IP:9080/command/wol/fetch&lt;/code>预览效果&lt;/li>
&lt;/ol>
&lt;p>&lt;figure style="flex-grow: 409; flex-basis: 983px">
&lt;a href="/posts/embeded/wol/serve.png" data-size="586x143">&lt;img src="/posts/embeded/wol/serve.png"
srcset="/posts/embeded/wol/serve_hue3ad21d217f365254d21bfd7fa6a91db_4681_480x0_resize_box_2.png 480w, /posts/embeded/wol/serve_hue3ad21d217f365254d21bfd7fa6a91db_4681_1024x0_resize_box_2.png 1024w"
width="586"
height="143"
loading="lazy"
alt="preview1">
&lt;/a>
&lt;figcaption>preview1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>参考资料: &lt;a class="link" href="https://www.jianshu.com/p/1853a02cb440" target="_blank" rel="noopener"
>GO的交叉编译&lt;/a>&lt;/p>
&lt;h2 id='5'>编写路由器客户端&lt;/h2>
&lt;p>路由器容量和内存都很小, 所以客户端程序使用C来实现, 由于我刷入的Padavan系统支持&lt;code>curl&lt;/code>命令, 所以网络请求的部分直接调用&lt;code>curl&lt;/code>, 若想通过HTTP实现, 可以参考文章: &lt;a class="link" href="https://www.cnblogs.com/chorm590/p/c_http_get_201905081356.html" target="_blank" rel="noopener"
>如何使用C语言实现HTTP请求&lt;/a>&lt;/p>
&lt;p>创建CMake项目&lt;strong>wol-client&lt;/strong>并添加源文件&lt;strong>wol.c&lt;/strong>, 本文假设需要唤醒的电脑IP及MAC如下:&lt;br>
&lt;strong>IP&lt;/strong> 192.168.1.123&lt;br>
&lt;strong>MAC&lt;/strong> AA:BB:CC:DD:EE:FF&lt;/p>
&lt;ol>
&lt;li>&lt;strong>使用&lt;code>ping&lt;/code>命令检测电脑是否在线&lt;/strong>&lt;br>
因为程序每分钟会被执行一次, 我们可以通过函数&lt;code>popen()&lt;/code>去调用&lt;code>ping&lt;/code>命令来判断电脑是否在线, 当电脑在线的时候就没有必要从服务器查询开机命令了&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>FILE* file = popen(&amp;quot;ping -c 1 -W 1 192.168.1.123 | grep -c \&amp;quot;100% packet loss\&amp;quot;&amp;quot;, &amp;quot;r&amp;quot;);
&lt;/code>&lt;/pre>&lt;p>解释一下各项参数&lt;/p>
&lt;ul>
&lt;li>&lt;code>-c&lt;/code> 表示ping的次数, 这里我们只ping一次&lt;/li>
&lt;li>&lt;code>-W&lt;/code> 表示等待回复的超时时间, Linux上单位为秒, 这里设定成1秒, 因为局域网内在线的机器通常一秒内都能回复&lt;/li>
&lt;li>&lt;code>gerp&lt;/code> 的 &lt;code>-c&lt;/code> 表示只打印找到目标文本的行号, 这里我们使用&lt;code>gerp&lt;/code>查找「100% packet loss」这段字符, 如果目标不在线, 那么行号会等于1, 反之行号等于0&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>提示: 也可以通过&lt;code>system()&lt;/code>函数调用命令, 在命令中配合 &lt;code>&amp;gt;&lt;/code> 将输出结果存入文本文件, 然后再读取文件内容即可&lt;/p>
&lt;/blockquote>
&lt;ol start="2">
&lt;li>&lt;strong>读取命令执行结果&lt;/strong>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>char cmd_value = getc(file);
pclose(file);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;code>getc()&lt;/code>读取文件的第一个字符, 在上面&lt;code>ping&lt;/code>命令中读取到的结果只会是0或1&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>&lt;strong>使用&lt;code>curl&lt;/code>命令查询服务端数据, 同样将结果存入文件, 再次读取文件内容判断是否需要开机&lt;/strong>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>file = popen(&amp;quot;curl http://服务器IP:9080/command/wol/fetch&amp;quot;, &amp;quot;r&amp;quot;);
&lt;/code>&lt;/pre>&lt;ol start="4">
&lt;li>&lt;strong>实现发送魔术包函数, 并通过UDP发送, 唤醒电脑&lt;/strong>&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>/// &amp;lt;summary&amp;gt;
/// UDP方式发送魔术包
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&amp;quot;mac&amp;quot;&amp;gt;网卡的物理地址, 格式 XX:XX:XX:XX:XX:XX&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&amp;quot;ip&amp;quot;&amp;gt;局域网内的IP地址, 格式 XXX.XXX.XXX.XXX&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
int send_magic_pack(const char* mac, const char* ip)
{
int ret = -1;
int send_length = -1;
unsigned char packet[102] = { 0 };
struct sockaddr_in addr;
int sockfd, i, j, option_value = 1;
unsigned char mactohex[6] = { 0 };
sscanf(mac, &amp;quot;%02x:%02x:%02x:%02x:%02x:%02x&amp;quot;,
(unsigned int*)&amp;amp;mactohex[0],
(unsigned int*)&amp;amp;mactohex[1],
(unsigned int*)&amp;amp;mactohex[2],
(unsigned int*)&amp;amp;mactohex[3],
(unsigned int*)&amp;amp;mactohex[4],
(unsigned int*)&amp;amp;mactohex[5]);
//构建magic packet
for (i = 0; i &amp;lt; 6; i++) { //6对“FF”前缀
packet[i] = 0xFF;
}
for (i = 1; i &amp;lt; 17; i++) { //目标计算机的MAC地址，重复16次
for (j = 0; j &amp;lt; 6; j++) {
packet[i * 6 + j] = mactohex[j];
}
}
//UDP
sockfd = socket(AF_INET, SOCK_DGRAM, 0);
//广播
ret = setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, &amp;amp;option_value, sizeof(option_value));
if (ret &amp;lt; 0) {
//printf(&amp;quot;set socket opt failed, errno=%d\n&amp;quot;, errno);
close(sockfd);
return ret;
}
memset((void*)&amp;amp;addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(9);
addr.sin_addr.s_addr = inet_addr(ip);//UDP广播地址
//发送广播
send_length = sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr*)&amp;amp;addr, sizeof(addr));
close(sockfd);
return ret;
}
&lt;/code>&lt;/pre>&lt;p>之后在&lt;code>mian()&lt;/code>函数中调用即可. 参考资料: &lt;a class="link" href="https://blog.csdn.net/a18359388932/article/details/126949062" target="_blank" rel="noopener"
>魔术包和C语言实现&lt;/a>&lt;/p>
&lt;p>其他部分完整代码如下&lt;/p>
&lt;pre>&lt;code>#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;arpa/inet.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
int send_magic_pack(const char* mac, const char* ip);
int main(int argc, char *argv[])
{
//使用ping命令检测目标主机是否存在, -c 1 只ping一次, -W 1 超时时间1秒, gerp查找ping结果中100% packet loss字符, -c 只显示找到的行号
FILE* file = popen(&amp;quot;ping -c 1 -W 1 192.168.1.123 | grep -c \&amp;quot;100% packet loss\&amp;quot;&amp;quot;, &amp;quot;r&amp;quot;);
char cmd_value = getc(file);
pclose(file);
if (cmd_value == '0')
{
puts(&amp;quot;目标主机在线, 无需唤醒&amp;quot;);
return 0;
}
file = popen(&amp;quot;curl http://服务器IP:9080/command/wol/fetch&amp;quot;, &amp;quot;r&amp;quot;);
cmd_value = getc(file);
pclose(file);
if (cmd_value == '0')
{
puts(&amp;quot;当前无开机命令&amp;quot;);
return 0; //命令标记=0说明不需要开机
}
puts(&amp;quot;收到开机命令, 执行开机...&amp;quot;);
int ret = send_magic_pack(&amp;quot;AA:BB:CC:DD:EE:FF&amp;quot;, &amp;quot;192.168.1.255&amp;quot;);
if (ret == 0)
puts(&amp;quot;唤醒包已发送&amp;quot;);
return 0;
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>注意: 函数&lt;code>send_magic_pack()&lt;/code>目标IP参数可以是192.168.1.123, 但我这里传广播地址 192.168.1.255, 原因见后文&lt;/p>
&lt;/blockquote>
&lt;ol start="5">
&lt;li>&lt;strong>编译&lt;/strong>&lt;br>
在Linux中导航到源文件所在目录, 执行命令&lt;code>mipsel-linux-gnu-gcc wol.c -o wol -static&lt;/code>, 得到可执行文件&lt;strong>wol&lt;/strong>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>注意: 执行&lt;code>mipsel-linux-gnu-gcc&lt;/code>命令需要先&lt;a class="link" href="../mipsel" >搭建MIPS架构交叉编译环境&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id='6'>测试效果&lt;/h2>
&lt;p>全部编写好后, 将服务端发布到云服务器上并启动. 客户端可以通过WinSCP复制到路由器&lt;code>/var&lt;/code>目录并配置好crontab (方法参考上文). 然后关闭电脑&lt;/p>
&lt;p>此时用另一台电脑打开CMD, 输入&lt;code>curl -X PUT http://服务器IP:9080/command/wol/push&lt;/code>, 正常的话就可以看到电脑在一分钟内启动了&lt;/p>
&lt;p>如果此时没有另一台电脑, 也可以用手机打开终端(Android), 或者其他任意能够以PUT方式发送HTTP请求到服务器的也是一样的&lt;/p>
&lt;h2 id='7'>遇到的问题&lt;/h2>
&lt;p>&lt;strong>关机时间久了(大于1分钟)之后无法唤醒&lt;/strong>&lt;br>
可能的原因如下:&lt;/p>
&lt;ol>
&lt;li>网卡没有禁用节能, 例如我的网卡需要关闭「以太网节能」, 参考上文. 另外我的路由器没有开启APR绑定, 在路由器管理页设置「APR绑定」或许也能解决&lt;/li>
&lt;li>UDP发送的IP地址不对, 例如开始的时候发送包的目标IP是192.168.1.123, 刚关机可以唤醒, 但几分钟后就无法唤醒了, 后改成192.168.1.255后唤醒成功, 区别在于后者是广播地址, 关于广播的详细介绍可参考: &lt;a class="link" href="https://blog.csdn.net/weixin_47783699/article/details/127937448" target="_blank" rel="noopener"
>UDP广播&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>还有一个很奇怪的现象, 当时用自己编写的程序(以下简称WOL), 对比微信小程序「网络唤醒WakeOnLan」(以下简称小程序) 进行测试&lt;/p>
&lt;p>刚关机几分钟内, 通过小程序以及WOL都能够唤醒电脑. 当关机几分钟后, 使用小程序能够唤醒成功, 但是通过WOL就不能. 使用网络调试助手对比过两者发送的魔术包数据是完全一致的.&lt;/p>
&lt;p>后来将WOL发送的目标IP地址改成广播地址192.168.1.255之后就可以唤醒了, 但作为对比的小程序不论填192.168.1.123还是192.168.1.255还是255.255.255.255都可以唤醒, 推测可能还是因为没有设置「APR绑定」, 释放了IP, 而小程序有做特殊处理, 发送的也是广播IP&lt;/p></description></item><item><title>在Windows上使用基于WSL的Ubuntu搭建MIPSEL处理器的C语言交叉编译环境</title><link>/posts/embeded/mipsel/</link><pubDate>Fri, 03 Mar 2023 00:50:44 +0800</pubDate><guid>/posts/embeded/mipsel/</guid><description>&lt;img src="/posts/embeded/mipsel/cover.png" alt="Featured image of post 在Windows上使用基于WSL的Ubuntu搭建MIPSEL处理器的C语言交叉编译环境" />&lt;h2 id="目录">目录&lt;/h2>
&lt;ol>
&lt;li>&lt;a class="link" href="#1" >硬件准备&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#2" >Windows上的开发环境准备&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#3" >使用Ubuntu安装MIPSEL架构的交叉编译器&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#4" >使用C编写Hello Word!测试&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#5" >遇到的问题&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#6" >一点感想&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id='1'>硬件准备&lt;/h2>
&lt;ul>
&lt;li>一台基于Linux内核, 采用MIPS处理器的设备, 例如我的小米AC2100, Padavan系统&lt;/li>
&lt;li>一台支持Windows子系统(WSL)的Windows 10的电脑&lt;/li>
&lt;/ul>
&lt;h2 id='2'>Windows上的开发环境准备&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>安装&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a> 2019.9 或以上版本&lt;/strong>&lt;/li>
&lt;li>&lt;strong>&lt;a class="link" href="https://www.cnblogs.com/MIUMIUBLING/p/16566200.html" target="_blank" rel="noopener"
>添加Linux开发环境工具集&lt;/a> (安装时已勾选的可跳过)&lt;/strong>
&lt;ol>
&lt;li>在开始菜单中打开「Visual Studio Installer」&lt;/li>
&lt;li>找到Visual Studio 2019, 点击右侧的「修改」按钮&lt;/li>
&lt;li>找到「使用C++的Linux开发」, 并勾选保存&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>开启Windows子系统(WSL)并安装Ubuntu, &lt;a class="link" href="https://blog.csdn.net/VXzhangkaiOsLab/article/details/128205285" target="_blank" rel="noopener"
>如何启用Win10的WSL?&lt;/a>&lt;/strong>&lt;br>
安装好后, 以下可&lt;strong>按需&lt;/strong>修改
&lt;ul>
&lt;li>&lt;a class="link" href="https://blog.csdn.net/ximaiyao1984/article/details/128593271" target="_blank" rel="noopener"
>修改root密码&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cnblogs.com/oongxu/p/16911759.html" target="_blank" rel="noopener"
>设置默认以root启动&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://blog.csdn.net/Erictr/article/details/121729194" target="_blank" rel="noopener"
>修改镜像源&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>为&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>配置跨平台编译&lt;/strong>&lt;br>
具体配置方式可参考微软官方教程
&lt;ul>
&lt;li>&lt;a class="link" href="hhttps://devblogs.microsoft.com/cppblog/c-with-visual-studio-2019-and-windows-subsystem-for-linux-wsl/" >如何在Visual Studio 2019中配置WSL交叉编译环境?&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/zh-cn/cpp/build/walkthrough-build-debug-wsl2?view=msvc-170" target="_blank" rel="noopener"
>如何在Visual Studio 2022中配置WSL交叉编译环境?&lt;/a>&lt;br>
&lt;strong>需要注意的是, 开始菜单中直接搜索「wsl」可以打开一个命令窗口执行Linux命令, 而打开Ubuntu窗口也可以执行命令, 我是在Ubutnu中安装的编译工具, 因此在&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>的「WSL-GCC-Debug」配置中, 「WSL」一栏需要选「Ubuntu2204」&lt;/strong>
&lt;figure style="flex-grow: 228; flex-basis: 547px">
&lt;a href="/posts/embeded/mipsel/wslconf.png" data-size="1080x473">&lt;img src="/posts/embeded/mipsel/wslconf.png"
srcset="/posts/embeded/mipsel/wslconf_hu2ff68bc45ab4971343be632267931eef_61038_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/wslconf_hu2ff68bc45ab4971343be632267931eef_61038_1024x0_resize_box_2.png 1024w"
width="1080"
height="473"
loading="lazy"
alt="WSL配置">
&lt;/a>
&lt;figcaption>WSL配置&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id='3'>使用Ubuntu安装MIPSEL交叉编译器&lt;/h2>
&lt;p>在Ubuntu中执行下列命令&lt;/p>
&lt;pre>&lt;code>apt update
apt -y install gcc-mipsel-linux-gnu qemu qemu-user
&lt;/code>&lt;/pre>&lt;p>等待安装完毕后, 就可以使用 &lt;code>mipsel-linux-gnu-gcc&lt;/code> 命令了&lt;/p>
&lt;p>补充说明:&lt;/p>
&lt;ul>
&lt;li>建议更换阿里或清华镜像源后执行, 提升下载速度&lt;/li>
&lt;li>「gcc-mipsel-linux-gnu」是交叉编译器, 可将C语言源文件编译成MIPS处理器支持的可执行文件, 如果需要编译C++, 还需安装「g++-mipsel-linux-gnu」&lt;/li>
&lt;li>「qemu」是仿真器, 可以在Ubuntu上模拟运行MIPS架构程序, 节约测试时间&lt;/li>
&lt;li>MIPS可执行文件分为大端(big-endian)和小端(little-endian), 两者的可执行文件不能互相兼容, 通常以mips代指大端, mipsel代指小端&lt;/li>
&lt;/ul>
&lt;p>参考资料:&lt;br>
&lt;a class="link" href="https://noobient.com/2020/12/22/mips-cross-compilation-crash-course/" target="_blank" rel="noopener"
>MIPS跨平台编译教程&lt;/a>&lt;br>
&lt;a class="link" href="https://www.howtoinstall.me/ubuntu/18-04/gcc-mipsel-linux-gnu/" target="_blank" rel="noopener"
>Ubuntu中如何安装 gcc-mipsel-linux-gnu&lt;/a>&lt;br>
&lt;a class="link" href="https://baike.baidu.com/item/QEMU/1311178?fr=aladdin" target="_blank" rel="noopener"
>QEMU简介&lt;/a>&lt;/p>
&lt;h2 id='4'>使用C编写Hello Word!测试&lt;/h2>
&lt;p>回到&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>中, 在项目里创建源文件&lt;strong>hello.c&lt;/strong>并编写helloword测试代码, 编写完后可以通过以下三种方式运行&lt;/p>
&lt;p>&lt;strong>1. 直接在Visual Studio中运行&lt;/strong>&lt;br>
可以直接在&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>中启动运行或调试, &lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>会自动将源代码在WSL中编译并运行, 并打开一个控制台输出结果, 方便快速预览效果以及调试&lt;/p>
&lt;p>&lt;strong>2. 在qemu中模拟运行&lt;/strong>&lt;br>
使用qemu可以模拟在路由器中运行, 首先需要在Ubuntu中将源代码编译成可执行文件, 我们可以在Ubuntu中导航到&lt;strong>源文件目录&lt;/strong>并执行命令&lt;/p>
&lt;pre>&lt;code>mipsel-linux-gnu-gcc hello.c -o hello -static
&lt;/code>&lt;/pre>&lt;p>编译得到可执行文件&lt;strong>hello&lt;/strong>, 再通过 &lt;code>qemu-mipsel&lt;/code> 命令预览效果, 如下&lt;/p>
&lt;pre>&lt;code>$ qemu-mipsel -L /usr/mipsel-linux-gnu hello
Hello World !
&lt;/code>&lt;/pre>&lt;p>&lt;strong>3. 使用路由器运行&lt;/strong>&lt;br>
参考上文「&lt;em>&lt;strong>2. 在qemu中模拟运行&lt;/strong>&lt;/em>」生成可执行文件&lt;strong>hello&lt;/strong>, 再使用&lt;a class="link" href="https://winscp.net/eng/download.php" target="_blank" rel="noopener"
>WinSCP&lt;/a>将其上传至路由器 &lt;code>/var&lt;/code> 目录, 然后SSH到路由器执行以下命令运行并查看结果&lt;/p>
&lt;pre>&lt;code>chmod u+x ./var/hello
./var/hello
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 377; flex-basis: 905px">
&lt;a href="/posts/embeded/mipsel/hello.png" data-size="249x66">&lt;img src="/posts/embeded/mipsel/hello.png"
srcset="/posts/embeded/mipsel/hello_hua744cf37185bcafc47f58974947343cc_14186_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/hello_hua744cf37185bcafc47f58974947343cc_14186_1024x0_resize_box_2.png 1024w"
width="249"
height="66"
loading="lazy"
alt="运行结果">
&lt;/a>
&lt;figcaption>运行结果&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>补充说明:&lt;/p>
&lt;ul>
&lt;li>在基于WSL的Ubuntu中, 可以通过路径 &lt;strong>/mnt/Windows盘符/Windows路径&lt;/strong> 的方式便捷的访问Windows上的文件, 例如 &lt;code>cd /mnt/c/Windows&lt;/code>&lt;/li>
&lt;li>&lt;code>mipsel-linux-gnu-gcc&lt;/code> 中 &lt;code>-static&lt;/code> 可以将所需要的库一起打包, 缺点是导致文件体积偏大, 优点是可以确保目标系统能够在缺少动态链接库的情况下运行&lt;/li>
&lt;li>&lt;code>qemu-mipsel&lt;/code> 中 &lt;code>-L&lt;/code> 指定运行库路径, 位于Ubuntu的「/usr/mipsel-linux-gnu」目录中&lt;/li>
&lt;/ul>
&lt;h2 id='5'>过程中遇到的问题&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>配置好WSL后, 直接F5编译运行出错, 弹窗提示「&lt;font color='red'>Launch options string provided by the project system is invalid. Required attribute &amp;lsquo;program&amp;rsquo; is missing or has an invalid value.&lt;/font> 」&lt;/p>
&lt;p>原因是&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>版本过低(一开始用的2019.6), 更新到2019.16.11.24之后再运行就好了&lt;br>
参考资料: &lt;a class="link" href="https://developercommunity.visualstudio.com/t/wsl-cmake-debugging-does-not-work/1205601" target="_blank" rel="noopener"
>Exception from HRESULT: 0x80004004 (E_ABORT)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>跨平台连接管理器无法连接到Ubuntu
&lt;figure style="flex-grow: 153; flex-basis: 369px">
&lt;a href="/posts/embeded/mipsel/vsssh.png" data-size="738x480">&lt;img src="/posts/embeded/mipsel/vsssh.png"
srcset="/posts/embeded/mipsel/vsssh_hu83c9af1093391170c583cb748fe4ef33_42820_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/vsssh_hu83c9af1093391170c583cb748fe4ef33_42820_1024x0_resize_box_2.png 1024w"
width="738"
height="480"
loading="lazy"
alt="vs远程连接">
&lt;/a>
&lt;figcaption>vs远程连接&lt;/figcaption>
&lt;/figure>
首先 &lt;strong>基于本机WSL开发并不需要配置远程调试&lt;/strong>, 以往没有WSL的时候, 通过虚拟机或服务器的Linux跨平台开发时才需要配置. 如果依然希望使用远程调试本机WSL, 则需要配置WSL Ubuntu的openSSH, 更换SSH端口, 开启允许root登录, 然后重启ssh服务即可&lt;br>
参考资料: &lt;a class="link" href="http://www.360doc.com/content/22/0523/15/65840129_1032775434.shtml" target="_blank" rel="noopener"
>如何通过SSH连接到WSL?&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>WinSCP无法复制文件到路由器「&lt;font color='red'>Error code: 4&lt;/font>」&lt;/p>
&lt;p>&lt;figure style="flex-grow: 211; flex-basis: 507px">
&lt;a href="/posts/embeded/mipsel/sshfail.png" data-size="501x237">&lt;img src="/posts/embeded/mipsel/sshfail.png"
srcset="/posts/embeded/mipsel/sshfail_huc3a69099e5dcb6d270a8fe227416313f_61780_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/sshfail_huc3a69099e5dcb6d270a8fe227416313f_61780_1024x0_resize_box_2.png 1024w"
width="501"
height="237"
loading="lazy"
alt="winscp">
&lt;/a>
&lt;figcaption>winscp&lt;/figcaption>
&lt;/figure>&lt;br>
因为一开始是复制到 &lt;code>/user&lt;/code> 目录, 但此目录空间满了, 后来复制到 &lt;code>/var&lt;/code> 就成功了, 可以在根目录使用 &lt;code>df&lt;/code> 命令查看空间占用率&lt;br>
&lt;figure style="flex-grow: 419; flex-basis: 1006px">
&lt;a href="/posts/embeded/mipsel/df.png" data-size="503x120">&lt;img src="/posts/embeded/mipsel/df.png"
srcset="/posts/embeded/mipsel/df_huc9db960f5887b194616d3191f78750b9_4629_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/df_huc9db960f5887b194616d3191f78750b9_4629_1024x0_resize_box_2.png 1024w"
width="503"
height="120"
loading="lazy"
alt="空间占用">
&lt;/a>
&lt;figcaption>空间占用&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序运行出错「&lt;font color='red'>-sh: ./hello: Permission denied&lt;/font>」&lt;/p>
&lt;p>因为文件没有执行的权限, 执行命令&lt;/p>
&lt;pre>&lt;code>chmod u+x hello
&lt;/code>&lt;/pre>&lt;p>之后再执行程序即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序运行出错「&lt;font color='red'>line 1: syntax error: unexpected word (expecting &amp;ldquo;)&amp;quot;)&lt;/font>」&lt;/p>
&lt;p>因为编译出来的可执行文件的指令集, 或者位数(64/32)不符合目标平台的CPU, 我的小米路由器AC2100搭载的CPU为&lt;a class="link" href="https://www.mediatek.cn/products/home-networking/mt7621" target="_blank" rel="noopener"
>MT7621A&lt;/a>, 是一颗MIPS架构32位的CPU, 而最开始&lt;a class="link" href="https://visualstudio.microsoft.com/zh-hans/" target="_blank" rel="noopener"
>Visual Studio&lt;/a>使用默认编译环境生成的平台是Intel x64, 所以路由器无法执行.
解决方法是在Ubuntu上安装mips交叉编译器重新编译&lt;/p>
&lt;p>说一下发现过程:&lt;br>
MIPS同ARM类似是属于嵌入式CPU的一种, 由于没有接触过嵌入式Linux开发, 仅在官网CPU介绍界面看到了MIPS字样, 同时看到很多嵌入式编译提到ARM字样, 推测MIPS也有自己的编译工具, 但网上ARM教程居多, MIPS很少, 大部分MIPS都需要自己使用「buildroot」或「crosstool-NG」生成编译工具, 找了好久才找到能直接用的编译工具&lt;code>mips-linux-gnu-gcc&lt;/code>, 但编译出来的文件还是报一样的错, 一度怀疑是位数的问题, 但是加上参数指定位数&lt;code>mips-linux-gnu-gcc -mabi=32&lt;/code> 编译依然没有解决.&lt;/p>
&lt;p>后来我从路由器中复制出来一份自带的程序&lt;strong>zerotier-one&lt;/strong>, 用记事本打开并和我自己编译的程序对比, 显示两者都是以&lt;strong>ELF&lt;/strong>开头的后面接二进制数据, 说明我编译出来的确实是可执行文件.&lt;/p>
&lt;p>&lt;figure style="flex-grow: 316; flex-basis: 759px">
&lt;a href="/posts/embeded/mipsel/elf.png" data-size="329x104">&lt;img src="/posts/embeded/mipsel/elf.png"
srcset="/posts/embeded/mipsel/elf_hub34eb7eac1621353cbfdca82ef4e05c0_3363_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/elf_hub34eb7eac1621353cbfdca82ef4e05c0_3363_1024x0_resize_box_2.png 1024w"
width="329"
height="104"
loading="lazy"
alt="elf">
&lt;/a>
&lt;figcaption>elf&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再后来用 &lt;code>file&lt;/code> 命令分别查看两个文件, 显示&lt;strong>zerotier-one&lt;/strong>和我编译的有所不同.&lt;/p>
&lt;p>&lt;strong>hello&lt;/strong>的file信息&lt;/p>
&lt;pre>&lt;code>ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld.so.1, BuildID[sha1].&amp;gt; =5cffbd2c17c264eadb4b91fa4490d868de7e4e15, for GNU/Linux 3.2.0, not stripped
&lt;/code>&lt;/pre>&lt;p>&lt;strong>zerotier-one&lt;/strong>的file信息&lt;/p>
&lt;pre>&lt;code>ELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped
&lt;/code>&lt;/pre>&lt;p>可见最大的差别就是MSB和LSB, 查询资料后了解到是高低在前的问题, 两者的数据内容相反.&lt;/p>
&lt;p>参考资料: &lt;a class="link" href="https://blog.csdn.net/qq_22279697/article/details/80508624" target="_blank" rel="noopener"
>MSB和LSB区别&lt;/a>&lt;/p>
&lt;p>于是编译时加上参数 &lt;code>mips-linux-gnu-gcc -EL&lt;/code>&lt;/p>
&lt;pre>&lt;code>/usr/lib/gcc-cross/mips-linux-gnu/10/../../../../mips-linux-gnu/bin/ld: /usr/lib/gcc-cross/mips-linux-gnu/10/../../../../mips-linux-gnu/lib/../lib/libgcc_s.so.1: error adding symbols: file in wrong format
collect2: error: ld returned 1 exit status
&lt;/code>&lt;/pre>&lt;p>但是报错了(似乎应该是 &lt;code>-LE&lt;/code>, 未验证), 再后来注意到 &lt;strong>MIPS编译工具也是分为MIPS和MIPSEL的, MIPSEL编译结果是低位在前, 就是我们想要的LSB文件, 而我一开始安装的编译工具是「gcc-mips-linux-gnu」, 即生成高位在前的可执行文件&lt;/strong>, 而当我直接执行 &lt;code>mipsel-linux-gnu-gcc&lt;/code> 会提示未安装&lt;/p>
&lt;pre>&lt;code>Command 'mipsel-linux-gnu-gcc' not found, but can be installed with:
apt install gcc-mipsel-linux-gnu
&lt;/code>&lt;/pre>&lt;p>我们根据提示执行
&lt;code>apt install gcc-mipsel-linux-gnu&lt;/code>
安装后就可以使用 &lt;code>mipsel-linux-gnu-gcc&lt;/code> 命令了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行程序出错「&lt;font color='red'>-sh: ./hello: not found&lt;/font>」&lt;/p>
&lt;p>原因是缺少运行库, 可以从别的地方复制库过来并配置环境变量啥的, 也可以简单点编译的时候加上 &lt;code>-static&lt;/code> 参数直接把需要的库打包进程序里.&lt;br>
另外在WSL中, 所有目录以文件都位于Windows「C:\Users\用户名\AppData\Local\Packages\Ubuntu发行版号\LocalState\rootfs\」, 例如:「C:\Users\Administrator\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04LTS_79rhkp1fndgsc\LocalState\rootfs\」, 而编译时所需的库文件位于「usr\mipsel-linux-gnu\lib」&lt;/p>
&lt;p>参考资料: &lt;a class="link" href="https://blog.csdn.net/socbis/article/details/108001336" target="_blank" rel="noopener"
>linux 执行程序时，提示not found问题分析&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>其他探索&lt;/p>
&lt;ul>
&lt;li>可使用 &lt;code>cat /proc/cpuinfo&lt;/code> 命令查看CPU信息, 可得到关键信息32, MIPS, 1004K, MT7621, 然后查找相关资料&lt;/li>
&lt;li>可使用 &lt;code>uname -a&lt;/code> 命令查看系统信息, 但是不多,&lt;/li>
&lt;li>可使用 &lt;code>cat /proc/version&lt;/code> 命令查看系统信息, 如下&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>R2100:/proc # cat /proc/version
Linux version 3.4.113 (root@fv-az19-273) (gcc version 7.4.0 (crosstool-NG 1.24.0) ) #1 SMP Wed Oct 20 17:03:44 UTC 2021
&lt;/code>&lt;/pre>&lt;p>其中的 &lt;strong>crosstool-NG 1.24.0&lt;/strong>, 是交叉编译工具, 所以这套系统应该是用这个工具编译出来的, 同理应该可以用这套工具编译自己的程序, 但网上很难找到现成的, 需要自己构建&lt;/p>
&lt;ul>
&lt;li>可使用 &lt;code>readelf&lt;/code> 命令查看可执行文件信息, 查看hello的信息如下:
&lt;figure style="flex-grow: 207; flex-basis: 499px">
&lt;a href="/posts/embeded/mipsel/readelf1.png" data-size="678x326">&lt;img src="/posts/embeded/mipsel/readelf1.png"
srcset="/posts/embeded/mipsel/readelf1_hu6db303a8d1b0d5b981ac711e8eccf8e9_10594_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/readelf1_hu6db303a8d1b0d5b981ac711e8eccf8e9_10594_1024x0_resize_box_2.png 1024w"
width="678"
height="326"
loading="lazy"
alt="wol">
&lt;/a>
&lt;figcaption>wol&lt;/figcaption>
&lt;/figure>
而路由器中自带的程序 zerotier-one的elf信息如下
&lt;figure style="flex-grow: 207; flex-basis: 499px">
&lt;a href="/posts/embeded/mipsel/readelf1.png" data-size="678x326">&lt;img src="/posts/embeded/mipsel/readelf1.png"
srcset="/posts/embeded/mipsel/readelf1_hu6db303a8d1b0d5b981ac711e8eccf8e9_10594_480x0_resize_box_2.png 480w, /posts/embeded/mipsel/readelf1_hu6db303a8d1b0d5b981ac711e8eccf8e9_10594_1024x0_resize_box_2.png 1024w"
width="678"
height="326"
loading="lazy"
alt="zerotier-one">
&lt;/a>
&lt;figcaption>zerotier-one&lt;/figcaption>
&lt;/figure>
可见一眼看上去并没有明显差别, 都是MIPS&lt;/li>
&lt;li>路由器上可以执行shell脚本和curl, 但我需要发送UDP路由器上的系统无法实现, 例如 &lt;code>/dev/udp/xxx.xxx.xxx.xxx/x&lt;/code> 路由器并不支持, 还是只能用代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>最新发现&lt;br>
&lt;strong>Go语言原生支持Windows交叉编译MIPSEL&lt;/strong>, 在GO环境变量中将 &lt;code>GOOS&lt;/code> 设置为&lt;strong>linux&lt;/strong>, &lt;code>GOARCH&lt;/code> 设置为&lt;strong>mipsle&lt;/strong> (没有拼错), 就可以直接用 &lt;code>go build&lt;/code> 命令编译出MIPS架构LSB的可执行文件&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id='6'>一点感想&lt;/h2>
&lt;p>网上关于MIPS架构的资料太少了, 因为此前也没有这方面基础, 从开始到出结果可谓一波三折, 走了太多弯路, 所以这次记录下来便于以后查阅&lt;/p></description></item><item><title>某抑云音乐破解简化UI去广告去更新</title><link>/posts/hack/xeasemusic/</link><pubDate>Tue, 09 Nov 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xeasemusic/</guid><description>&lt;img src="/posts/hack/xeasemusic/cover.png" alt="Featured image of post 某抑云音乐破解简化UI去广告去更新" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>某抑云音乐随着版本更新, 加入了越来越多的垃圾功能和广告, 严重影响体验, 而且在歌单播放按钮上添加了购买VIP按钮, 不仅比播放按钮大, 还是延迟显示的, 非常容易误按, 就很生气, 于是决定干掉它们&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>精简某易云UI, 只留下自己需要的部分, 同时各个地方的广告和更新提示&lt;/p>
&lt;h2 id="受害者版本">受害者版本&lt;/h2>
&lt;p>V7.2.10.782837&lt;/p>
&lt;h2 id="app界面概览">APP界面概览&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 173; flex-basis: 417px">
&lt;a href="/posts/hack/xeasemusic/1.jpg" data-size="1000x575">&lt;img src="/posts/hack/xeasemusic/1.jpg"
srcset="/posts/hack/xeasemusic/1_hu394211d721ec1e75a700144baf4ad841_84090_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/1_hu394211d721ec1e75a700144baf4ad841_84090_1024x0_resize_q75_box.jpg 1024w"
width="1000"
height="575"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>直接用反编译工具&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 打开安装包即&lt;code>.apk&lt;/code>, 发现软件没有加壳, 可以顺利反编译出源码, 直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;blockquote>
&lt;p>虽然没有加壳, 但是经过了混淆, 阅读性非常差, 而且绝大部分字符串都经过了加密, 无法直接搜索, 可以说是非常猥琐了&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 148; flex-basis: 357px">
&lt;a href="/posts/hack/xeasemusic/2.jpg" data-size="892x599">&lt;img src="/posts/hack/xeasemusic/2.jpg"
srcset="/posts/hack/xeasemusic/2_hu0089b3dbce7d597175082fa79a450d13_52285_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/2_hu0089b3dbce7d597175082fa79a450d13_52285_1024x0_resize_q75_box.jpg 1024w"
width="892"
height="599"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="1去除多余标签">1.去除多余标签&lt;/h2>
&lt;p>首先去除本人用不上的标签页, 只需要留下&amp;quot;我的&amp;quot;标签页就行&lt;/p>
&lt;p>&lt;figure style="flex-grow: 316; flex-basis: 759px">
&lt;a href="/posts/hack/xeasemusic/3.jpg" data-size="462x146">&lt;img src="/posts/hack/xeasemusic/3.jpg"
srcset="/posts/hack/xeasemusic/3_hu406b6e60d83a327970afdc698b27c2a9_7407_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/3_hu406b6e60d83a327970afdc698b27c2a9_7407_1024x0_resize_q75_box.jpg 1024w"
width="462"
height="146"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>首先全局搜索文字&amp;quot;我的&amp;quot;&lt;/p>
&lt;p>&lt;figure style="flex-grow: 141; flex-basis: 339px">
&lt;a href="/posts/hack/xeasemusic/4.jpg" data-size="641x453">&lt;img src="/posts/hack/xeasemusic/4.jpg"
srcset="/posts/hack/xeasemusic/4_hu9caf4385ce48b002b831ac272cd33a9e_25881_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/4_hu9caf4385ce48b002b831ac272cd33a9e_25881_1024x0_resize_q75_box.jpg 1024w"
width="641"
height="453"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现能够完全匹配标签栏四组文字的, 在一个&lt;code>arrays.xml&lt;/code>文本里, 其中节点的&lt;code>name&lt;/code>为&lt;code>ap&lt;/code>, 于是搜索&lt;code>R.array.ap&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 168; flex-basis: 404px">
&lt;a href="/posts/hack/xeasemusic/5.jpg" data-size="650x386">&lt;img src="/posts/hack/xeasemusic/5.jpg"
srcset="/posts/hack/xeasemusic/5_hufa6fa374304e0e6fc4f95f0a44dcc12d_32751_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/5_hufa6fa374304e0e6fc4f95f0a44dcc12d_32751_1024x0_resize_q75_box.jpg 1024w"
width="650"
height="386"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以发现一处搜索结果, 位于&lt;code>MainActivity&lt;/code>, 应该就是需要找的目标了, 看看这个&lt;code>b&lt;/code>方法的实现&lt;/p>
&lt;p>&lt;figure style="flex-grow: 371; flex-basis: 891px">
&lt;a href="/posts/hack/xeasemusic/6.jpg" data-size="297x80">&lt;img src="/posts/hack/xeasemusic/6.jpg"
srcset="/posts/hack/xeasemusic/6_hubcf35791e8005caf432b6c4d673f5320_3500_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/6_hubcf35791e8005caf432b6c4d673f5320_3500_1024x0_resize_q75_box.jpg 1024w"
width="297"
height="80"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>发现此方法只是把&lt;code>xml&lt;/code>里的数组保存, 那么我只需要把这个入参的值修改一下, 应该就可以实现去除多余标签的作用了&lt;/strong>, 编写&lt;code>xposed&lt;/code>模块代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;com.马赛克ease.马赛克music.activity.r&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;b&amp;quot;,
String[].class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
param.args[0] = new String[]{&amp;quot;我的&amp;quot;};
}
}
);
&lt;/code>&lt;/pre>&lt;p>此代码将在&lt;code>b&lt;/code>方法执行前执行, 将原本带有4个节点的数组重新赋值为只有一个的数组, 实际执行效果如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 385; flex-basis: 926px">
&lt;a href="/posts/hack/xeasemusic/7.jpg" data-size="548x142">&lt;img src="/posts/hack/xeasemusic/7.jpg"
srcset="/posts/hack/xeasemusic/7_hu76efc633ffd4f100cda63de540a6c11c_5217_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/7_hu76efc633ffd4f100cda63de540a6c11c_5217_1024x0_resize_q75_box.jpg 1024w"
width="548"
height="142"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到除了&amp;quot;我的&amp;quot;以外的标签, 其他的都已经不再显示了&lt;/p>
&lt;h2 id="2去除用户vip信息">2.去除用户VIP信息&lt;/h2>
&lt;p>用户VIP信息如下, 纯属占位置又无用的一块节点&lt;/p>
&lt;p>&lt;figure style="flex-grow: 240; flex-basis: 576px">
&lt;a href="/posts/hack/xeasemusic/8.jpg" data-size="389x162">&lt;img src="/posts/hack/xeasemusic/8.jpg"
srcset="/posts/hack/xeasemusic/8_hu3c8b24f48ba4b556a63204eb0d0c716b_7178_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/8_hu3c8b24f48ba4b556a63204eb0d0c716b_7178_1024x0_resize_q75_box.jpg 1024w"
width="389"
height="162"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>首先在&lt;a class="link" href="https://developer.android.google.cn/studio/profile/monitor" target="_blank" rel="noopener"
>Android Device Monitor&lt;/a>查看一下VIP信息中头像节点的父节点&lt;code>id&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 292; flex-basis: 701px">
&lt;a href="/posts/hack/xeasemusic/12.jpg" data-size="1216x416">&lt;img src="/posts/hack/xeasemusic/12.jpg"
srcset="/posts/hack/xeasemusic/12_hu0c1a689cde821f071fb93ef8ea2299de_61354_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/12_hu0c1a689cde821f071fb93ef8ea2299de_61354_1024x0_resize_q75_box.jpg 1024w"
width="1216"
height="416"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到&lt;code>id&lt;/code>为&lt;code>headerMyInfo&lt;/code>, 在源码中全局搜索&lt;code>headerMyInfo&lt;/code>, 找到&lt;code>HeaderEntryListViewHolder&lt;/code>中有一处实际调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 169; flex-basis: 407px">
&lt;a href="/posts/hack/xeasemusic/11.jpg" data-size="665x392">&lt;img src="/posts/hack/xeasemusic/11.jpg"
srcset="/posts/hack/xeasemusic/11_hu832e869c1f67da6028994494a950c04c_45118_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/11_hu832e869c1f67da6028994494a950c04c_45118_1024x0_resize_q75_box.jpg 1024w"
width="665"
height="392"
loading="lazy"
alt="image-11">
&lt;/a>
&lt;figcaption>image-11&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>此处将&lt;code>headerMyInfo&lt;/code>的&lt;code>view&lt;/code>传入&lt;code>MyVipInfoViewHolder&lt;/code>作为参数, 之后创建了&lt;code>MyVipInfoViewHolder&lt;/code>, 因此只需要修改一下传入的&lt;code>headerMyInfo&lt;/code>布局参数, 即可隐藏这个节点&lt;/strong>, 编写&lt;code>xposed&lt;/code>代码如下:&lt;/p>
&lt;pre>&lt;code>findAndHookConstructor(
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.headerentry.MyVipInfoViewHolder&amp;quot;, loadPackageParam.classLoader,
View.class,
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.k&amp;quot;,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
View view = (View) param.args[0];
view.setVisibility(View.GONE);
}
}
)
&lt;/code>&lt;/pre>&lt;p>此代码拦截&lt;code>MyVipInfoViewHolder&lt;/code>的构造函数, 并将传入的参数&lt;code>headerMyInfo&lt;/code>修改显示方式为&lt;code>View.GONE&lt;/code>, 以达到隐藏的目的. 编写完后运行结果如下, 可以看到VIP节点已经成功隐藏&lt;/p>
&lt;blockquote>
&lt;p>注: 一个界面节点在创建之后可能会被多次调用, 直接删除节点可能会引起报错, 因为隐藏节点最为妥当&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 216; flex-basis: 520px">
&lt;a href="/posts/hack/xeasemusic/13.jpg" data-size="375x173">&lt;img src="/posts/hack/xeasemusic/13.jpg"
srcset="/posts/hack/xeasemusic/13_hu0695848f27144fc461faaa8c0baacc9f_3905_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/13_hu0695848f27144fc461faaa8c0baacc9f_3905_1024x0_resize_q75_box.jpg 1024w"
width="375"
height="173"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="3隐藏小程序标题以及小程序列表">3.隐藏小程序标题以及小程序列表&lt;/h2>
&lt;p>此处小程序列表本人也是从来不用, 而其所占位置之大令人发指&lt;/p>
&lt;p>&lt;figure style="flex-grow: 137; flex-basis: 330px">
&lt;a href="/posts/hack/xeasemusic/14.jpg" data-size="368x267">&lt;img src="/posts/hack/xeasemusic/14.jpg"
srcset="/posts/hack/xeasemusic/14_hu5ca81e96b348e5ca80fafffff0e83929_13108_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/14_hu5ca81e96b348e5ca80fafffff0e83929_13108_1024x0_resize_q75_box.jpg 1024w"
width="368"
height="267"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>在&lt;a class="link" href="https://developer.android.google.cn/studio/profile/monitor" target="_blank" rel="noopener"
>Android Device Monitor&lt;/a>中看到标题节点的父节点&lt;code>id&lt;/code>为&lt;code>miniAppListSection&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 343; flex-basis: 825px">
&lt;a href="/posts/hack/xeasemusic/17.jpg" data-size="1169x340">&lt;img src="/posts/hack/xeasemusic/17.jpg"
srcset="/posts/hack/xeasemusic/17_hu7de6e24118f7a4c3d6f38753608cd1d4_54708_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/17_hu7de6e24118f7a4c3d6f38753608cd1d4_54708_1024x0_resize_q75_box.jpg 1024w"
width="1169"
height="340"
loading="lazy"
alt="image-17">
&lt;/a>
&lt;figcaption>image-17&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>搜索这个&lt;code>id&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 161; flex-basis: 387px">
&lt;a href="/posts/hack/xeasemusic/15.jpg" data-size="645x399">&lt;img src="/posts/hack/xeasemusic/15.jpg"
srcset="/posts/hack/xeasemusic/15_hu1a128ee9791f0657a00d6c1cec64d39d_46174_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/15_hu1a128ee9791f0657a00d6c1cec64d39d_46174_1024x0_resize_q75_box.jpg 1024w"
width="645"
height="399"
loading="lazy"
alt="image-15">
&lt;/a>
&lt;figcaption>image-15&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现其在&lt;code>SimpleSectionViewHolder&lt;/code>的构造函数中被调用, 该构造函数代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 418; flex-basis: 1003px">
&lt;a href="/posts/hack/xeasemusic/16.jpg" data-size="393x94">&lt;img src="/posts/hack/xeasemusic/16.jpg"
srcset="/posts/hack/xeasemusic/16_hubad3e495962fbe1d107e61b82a970315_6020_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/16_hubad3e495962fbe1d107e61b82a970315_6020_1024x0_resize_q75_box.jpg 1024w"
width="393"
height="94"
loading="lazy"
alt="image-16">
&lt;/a>
&lt;figcaption>image-16&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出这里和刚才的VIP信息代码几乎一致, 因此可以采用刚才的方式进行隐藏, 但不同的是&lt;code>SimpleSectionViewHolder&lt;/code>这个类有多处调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 424; flex-basis: 1019px">
&lt;a href="/posts/hack/xeasemusic/18.jpg" data-size="603x142">&lt;img src="/posts/hack/xeasemusic/18.jpg"
srcset="/posts/hack/xeasemusic/18_huaaf2c9083ce854493f125c511512c4bb_16409_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/18_huaaf2c9083ce854493f125c511512c4bb_16409_1024x0_resize_q75_box.jpg 1024w"
width="603"
height="142"
loading="lazy"
alt="image-18">
&lt;/a>
&lt;figcaption>image-18&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>为了保证我们隐藏的&lt;code>view&lt;/code>参数是小程序的标题, 因此需要查看一下传入&lt;code>miniAppListSection&lt;/code>节点的资源&lt;code>id&lt;/code>&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>资源&lt;code>id&lt;/code>是安卓应用在编译后对应每个节点生成的唯一&lt;code>id&lt;/code>, 在编译期间可以使用&lt;code>R.id&lt;/code>/&lt;code>R.array&lt;/code>/&lt;code>R.layout&lt;/code>等其实都是引用了这个&lt;code>id&lt;/code>, 在编译后会生成在&lt;code>R.java&lt;/code>中, 还有一个&lt;code>public.xml&lt;/code>中存在一个同样的值与之对应&lt;/p>
&lt;/blockquote>
&lt;p>点击调用&lt;code>SimpleSectionViewHolder&lt;/code>构造函数中参数&lt;code>R.id.miniAppListSection&lt;/code>可以跳转到&lt;code>R.java&lt;/code>, &lt;strong>此时看到的资源&lt;code>id&lt;/code>为&lt;code>2131299470&lt;/code>&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 992; flex-basis: 2381px">
&lt;a href="/posts/hack/xeasemusic/19.jpg" data-size="387x39">&lt;img src="/posts/hack/xeasemusic/19.jpg"
srcset="/posts/hack/xeasemusic/19_hu19c3c30341cb02fc2539b98fb2cb0e45_4174_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/19_hu19c3c30341cb02fc2539b98fb2cb0e45_4174_1024x0_resize_q75_box.jpg 1024w"
width="387"
height="39"
loading="lazy"
alt="image-19">
&lt;/a>
&lt;figcaption>image-19&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>现在可以编写&lt;code>xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookConstructor(
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.SimpleSectionViewHolder&amp;quot;, loadPackageParam.classLoader,
View.class,
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.k&amp;quot;,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
RelativeLayout layout = (RelativeLayout) param.args[0];
if (layout.getId() == 2131299470) {
layout.setVisibility(View.GONE);
}
}
}
);
&lt;/code>&lt;/pre>&lt;p>这里拦截&lt;code>SimpleSectionViewHolder&lt;/code>的构造函数, 当资源节点的&lt;code>id&lt;/code>为&lt;code>2131299470&lt;/code>时, 将节点隐藏&lt;/p>
&lt;p>继续寻找小程序卡片的布局, 这里卡片节点没有合适的节点&lt;code>id&lt;/code>用于搜索, 因此找到他的父节点&lt;code>id&lt;/code>为&lt;code>myMusicRecyclerView&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 227; flex-basis: 547px">
&lt;a href="/posts/hack/xeasemusic/20.jpg" data-size="1224x537">&lt;img src="/posts/hack/xeasemusic/20.jpg"
srcset="/posts/hack/xeasemusic/20_hu6f26467958821e7a80072ee8126fa0f6_88317_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/20_hu6f26467958821e7a80072ee8126fa0f6_88317_1024x0_resize_q75_box.jpg 1024w"
width="1224"
height="537"
loading="lazy"
alt="image-20">
&lt;/a>
&lt;figcaption>image-20&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>全局搜索&lt;code>myMusicRecyclerView&lt;/code>, 得到多处结果, &lt;strong>但位于&lt;code>com.马赛克ease.马赛克music.module.mymusic.k&lt;/code>中因为使用到了类&lt;code>MiniAppListLinearViewHolder&lt;/code>, 根据名称推测&lt;code>MiniAppListLinearViewHolder&lt;/code>应该是用于创建卡片父节点列表的&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 106; flex-basis: 256px">
&lt;a href="/posts/hack/xeasemusic/21.jpg" data-size="642x601">&lt;img src="/posts/hack/xeasemusic/21.jpg"
srcset="/posts/hack/xeasemusic/21_hud3841ee369b293e4fcd2b0e740582ef5_81633_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/21_hud3841ee369b293e4fcd2b0e740582ef5_81633_1024x0_resize_q75_box.jpg 1024w"
width="642"
height="601"
loading="lazy"
alt="image-21">
&lt;/a>
&lt;figcaption>image-21&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>bindType&lt;/code>调用了&lt;code>MiniAppListLinearViewHolder.a()&lt;/code>, &lt;strong>跳转进去可以看到内部调用了构造函数&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 317; flex-basis: 762px">
&lt;a href="/posts/hack/xeasemusic/23.jpg" data-size="788x248">&lt;img src="/posts/hack/xeasemusic/23.jpg"
srcset="/posts/hack/xeasemusic/23_hueb1128d6c6eb0ca2b720c46bdf53de21_27859_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/23_hueb1128d6c6eb0ca2b720c46bdf53de21_27859_1024x0_resize_q75_box.jpg 1024w"
width="788"
height="248"
loading="lazy"
alt="image-23">
&lt;/a>
&lt;figcaption>image-23&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>看一眼&lt;code>MiniAppListLinearViewHolder&lt;/code>的构造函数代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 380; flex-basis: 913px">
&lt;a href="/posts/hack/xeasemusic/22.jpg" data-size="514x135">&lt;img src="/posts/hack/xeasemusic/22.jpg"
srcset="/posts/hack/xeasemusic/22_huf74679e539d3245467a8975b6f5f594e_11770_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/22_huf74679e539d3245467a8975b6f5f594e_11770_1024x0_resize_q75_box.jpg 1024w"
width="514"
height="135"
loading="lazy"
alt="image-22">
&lt;/a>
&lt;figcaption>image-22&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>实现也非常简单, 推测可以使用刚才的方式将隐藏, 编写&lt;code>xposed&lt;/code>代码如下:&lt;/p>
&lt;pre>&lt;code>findAndHookConstructor(
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.miniapp.linear.MiniAppListLinearViewHolder&amp;quot;, loadPackageParam.classLoader,
View.class,
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.k&amp;quot;,
int.class,
int.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
View miniAppListView = (View) param.args[0];
ViewGroup.LayoutParams layoutParams = miniAppListView.getLayoutParams();
layoutParams.height = 0;
}
}
);
&lt;/code>&lt;/pre>&lt;p>这里拦截&lt;code>MiniAppListLinearViewHolder&lt;/code>的构造函数, 并将布局高度改为0, 达到隐藏的目的, 运行效果如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 212; flex-basis: 511px">
&lt;a href="/posts/hack/xeasemusic/25.jpg" data-size="313x147">&lt;img src="/posts/hack/xeasemusic/25.jpg"
srcset="/posts/hack/xeasemusic/25_hu8332141b9c0de66db381fde3d6b1b944_6333_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/25_hu8332141b9c0de66db381fde3d6b1b944_6333_1024x0_resize_q75_box.jpg 1024w"
width="313"
height="147"
loading="lazy"
alt="image-25">
&lt;/a>
&lt;figcaption>image-25&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>在隐藏了这么多节点之后, 布局出现了一点问题&lt;/p>
&lt;p>&lt;figure style="flex-grow: 167; flex-basis: 402px">
&lt;a href="/posts/hack/xeasemusic/26.jpg" data-size="544x324">&lt;img src="/posts/hack/xeasemusic/26.jpg"
srcset="/posts/hack/xeasemusic/26_hu233a6adfa9ef11599db90c0c279167f9_10234_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/26_hu233a6adfa9ef11599db90c0c279167f9_10234_1024x0_resize_q75_box.jpg 1024w"
width="544"
height="324"
loading="lazy"
alt="image-26">
&lt;/a>
&lt;figcaption>image-26&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到&amp;quot;本地音乐&amp;quot;这一栏的按钮偏下了, 需要调整一下位置. 首先查看一下这一栏按钮父节点&lt;code>id&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 254; flex-basis: 609px">
&lt;a href="/posts/hack/xeasemusic/27.jpg" data-size="1123x442">&lt;img src="/posts/hack/xeasemusic/27.jpg"
srcset="/posts/hack/xeasemusic/27_hu1fa50c1c6e036cca9d008cdb718b15a0_67341_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/27_hu1fa50c1c6e036cca9d008cdb718b15a0_67341_1024x0_resize_q75_box.jpg 1024w"
width="1123"
height="442"
loading="lazy"
alt="image-27">
&lt;/a>
&lt;figcaption>image-27&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到父节点&lt;code>id&lt;/code>为&lt;code>centerContainer&lt;/code>, 全局搜索后可以找到一处调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 124; flex-basis: 299px">
&lt;a href="/posts/hack/xeasemusic/28.jpg" data-size="650x521">&lt;img src="/posts/hack/xeasemusic/28.jpg"
srcset="/posts/hack/xeasemusic/28_huc5e658d31af1f3bc559b839b22a97849_53411_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/28_huc5e658d31af1f3bc559b839b22a97849_53411_1024x0_resize_q75_box.jpg 1024w"
width="650"
height="521"
loading="lazy"
alt="image-28">
&lt;/a>
&lt;figcaption>image-28&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>这个节点被赋值为成员变量&lt;code>f15898e&lt;/code>, 而这个变量名是由反编译工具改名而来, 可以看到反编译提示原本变量名为&lt;code>e&lt;/code>&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 677; flex-basis: 1624px">
&lt;a href="/posts/hack/xeasemusic/29.jpg" data-size="501x74">&lt;img src="/posts/hack/xeasemusic/29.jpg"
srcset="/posts/hack/xeasemusic/29_hu14c4180027ad19686f63197c810992d3_5308_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/29_hu14c4180027ad19686f63197c810992d3_5308_1024x0_resize_q75_box.jpg 1024w"
width="501"
height="74"
loading="lazy"
alt="image-29">
&lt;/a>
&lt;figcaption>image-29&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>下面需要修改这个节点的布局参数, 编写&lt;code>xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookConstructor(
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.headerentry.HeaderEntryListViewHolder&amp;quot;, loadPackageParam.classLoader,
View.class,
&amp;quot;com.马赛克ease.马赛克music.module.mymusic.k&amp;quot;,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
LinearLayout view = (LinearLayout) getObjectField(param.thisObject, &amp;quot;e&amp;quot;);
FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
layoutParams.bottomMargin = 50;
layoutParams.gravity = Gravity.BOTTOM;
}
}
);
&lt;/code>&lt;/pre>&lt;p>此处拦截赋值部分的方法, 在&lt;code>HeaderEntryListViewHolder&lt;/code>的构造方法执行之后, 获取到成员变量&lt;code>e&lt;/code>并修改其布局为&lt;code>Gravity.BOTTOM&lt;/code>, 将节点靠底排列, &lt;code>bottomMargin=50&lt;/code>, 距离底部50个边距, 编译后运行效果如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 109; flex-basis: 262px">
&lt;a href="/posts/hack/xeasemusic/30.jpg" data-size="304x278">&lt;img src="/posts/hack/xeasemusic/30.jpg"
srcset="/posts/hack/xeasemusic/30_hu58f7ec5dbed2a5e311d503194b581b98_8743_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/30_hu58f7ec5dbed2a5e311d503194b581b98_8743_1024x0_resize_q75_box.jpg 1024w"
width="304"
height="278"
loading="lazy"
alt="image-30">
&lt;/a>
&lt;figcaption>image-30&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到按钮正常排列了&lt;/p>
&lt;blockquote>
&lt;p>按钮上方留白一段距离主要是为了设置背景的时候可以看到&lt;/p>
&lt;/blockquote>
&lt;p>至此, 首页全部整改完毕, 完整效果图如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 49; flex-basis: 117px">
&lt;a href="/posts/hack/xeasemusic/31.jpg" data-size="308x627">&lt;img src="/posts/hack/xeasemusic/31.jpg"
srcset="/posts/hack/xeasemusic/31_hu9b7acd5e3bb53edc812211b1adceecc9_21973_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/31_hu9b7acd5e3bb53edc812211b1adceecc9_21973_1024x0_resize_q75_box.jpg 1024w"
width="308"
height="627"
loading="lazy"
alt="image-31">
&lt;/a>
&lt;figcaption>image-31&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="4去除播放列表顶部广告按钮">4.去除播放列表顶部广告按钮&lt;/h2>
&lt;p>这个该死的广告按钮和播放按钮放一块非常容易误触&lt;/p>
&lt;p>&lt;figure style="flex-grow: 120; flex-basis: 290px">
&lt;a href="/posts/hack/xeasemusic/32.jpg" data-size="370x306">&lt;img src="/posts/hack/xeasemusic/32.jpg"
srcset="/posts/hack/xeasemusic/32_hu08659f642f1645c8da8481d4193472c9_17738_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/32_hu08659f642f1645c8da8481d4193472c9_17738_1024x0_resize_q75_box.jpg 1024w"
width="370"
height="306"
loading="lazy"
alt="image-32">
&lt;/a>
&lt;figcaption>image-32&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>首先查看节点&lt;code>id&lt;/code>, 得到&lt;code>exposureGuideIcon&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 394; flex-basis: 945px">
&lt;a href="/posts/hack/xeasemusic/33.jpg" data-size="1190x302">&lt;img src="/posts/hack/xeasemusic/33.jpg"
srcset="/posts/hack/xeasemusic/33_hu2b6f7c4011a2e048b3897d0ec08d26c5_48296_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/33_hu2b6f7c4011a2e048b3897d0ec08d26c5_48296_1024x0_resize_q75_box.jpg 1024w"
width="1190"
height="302"
loading="lazy"
alt="image-33">
&lt;/a>
&lt;figcaption>image-33&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>全局搜索, 发现在构造函数中有一处引用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 127; flex-basis: 305px">
&lt;a href="/posts/hack/xeasemusic/34.jpg" data-size="641x504">&lt;img src="/posts/hack/xeasemusic/34.jpg"
srcset="/posts/hack/xeasemusic/34_hu38cdb4460f6736c4127d1c61595aa739_45810_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/34_hu38cdb4460f6736c4127d1c61595aa739_45810_1024x0_resize_q75_box.jpg 1024w"
width="641"
height="504"
loading="lazy"
alt="image-34">
&lt;/a>
&lt;figcaption>image-34&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>通过搜索&lt;code>new ExposureGuideView&lt;/code>查看实例被创建的地方, 找到两处, 但当前界面是播放列表, 因此关注&lt;code>PlayListFragment&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 173; flex-basis: 416px">
&lt;a href="/posts/hack/xeasemusic/35.jpg" data-size="877x505">&lt;img src="/posts/hack/xeasemusic/35.jpg"
srcset="/posts/hack/xeasemusic/35_hu558718252af24ad66769987c7a3947aa_48012_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/35_hu558718252af24ad66769987c7a3947aa_48012_1024x0_resize_q75_box.jpg 1024w"
width="877"
height="505"
loading="lazy"
alt="image-35">
&lt;/a>
&lt;figcaption>image-35&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>实例在&lt;code>PlayListFragment&lt;/code>的&lt;code>cl&lt;/code>方法中被创建, 查看一下&lt;code>cl&lt;/code>的完整代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 104; flex-basis: 249px">
&lt;a href="/posts/hack/xeasemusic/36.jpg" data-size="707x679">&lt;img src="/posts/hack/xeasemusic/36.jpg"
srcset="/posts/hack/xeasemusic/36_hu47f624dd0aba93576ea00791222c361a_54606_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/36_hu47f624dd0aba93576ea00791222c361a_54606_1024x0_resize_q75_box.jpg 1024w"
width="707"
height="679"
loading="lazy"
alt="image-36">
&lt;/a>
&lt;figcaption>image-36&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>初步分析基本上都是干的和广告相关的事, 因此直接拦截取缔这个方法, 编写&lt;code>xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;com.马赛克ease.马赛克music.fragment.PlayListFragment&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;cl&amp;quot;,
new XC_MethodReplacement() {
@Override
protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable {
return null;
}
}
);
&lt;/code>&lt;/pre>&lt;p>此处代码直接替换原有方法执行, 不做任何事, 之后运行效果如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 160; flex-basis: 385px">
&lt;a href="/posts/hack/xeasemusic/37.jpg" data-size="535x333">&lt;img src="/posts/hack/xeasemusic/37.jpg"
srcset="/posts/hack/xeasemusic/37_hubf45c5b4a1a70a21657ac1a835f43ece_13167_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/37_hubf45c5b4a1a70a21657ac1a835f43ece_13167_1024x0_resize_q75_box.jpg 1024w"
width="535"
height="333"
loading="lazy"
alt="image-37">
&lt;/a>
&lt;figcaption>image-37&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到广告已经被移除了&lt;/p>
&lt;h2 id="5去除开屏广告">5.去除开屏广告&lt;/h2>
&lt;p>开屏广告非常烦人, 且严重影响启动速度, 必须移除&lt;/p>
&lt;blockquote>
&lt;p>以下修改均为2019年期间, 我也不记得当时具体是怎么找的了, 只能以现有结果大致推测&lt;/p>
&lt;/blockquote>
&lt;p>首先从启动类入手, 查看&lt;code>AndroidManifest.xml&lt;/code>, 找到&lt;code>intent-filter&lt;/code>为&lt;code>android.intent.category.LAUNCHER&lt;/code>的一项&lt;code>Actvity&lt;/code>即为启动类, 这里为&lt;code>LoadingActivity&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 321; flex-basis: 771px">
&lt;a href="/posts/hack/xeasemusic/38.jpg" data-size="765x238">&lt;img src="/posts/hack/xeasemusic/38.jpg"
srcset="/posts/hack/xeasemusic/38_hud4fce15e6959bece632e25be2b6d88f0_31103_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/38_hud4fce15e6959bece632e25be2b6d88f0_31103_1024x0_resize_q75_box.jpg 1024w"
width="765"
height="238"
loading="lazy"
alt="image-38">
&lt;/a>
&lt;figcaption>image-38&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查阅&lt;code>LoadingActivity&lt;/code>的代码, 会发现其重写了&lt;code>onActivityResult&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 238; flex-basis: 572px">
&lt;a href="/posts/hack/xeasemusic/39.jpg" data-size="453x190">&lt;img src="/posts/hack/xeasemusic/39.jpg"
srcset="/posts/hack/xeasemusic/39_hu3a68a8189dc04981b9d1b247ad6c58e1_10309_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/39_hu3a68a8189dc04981b9d1b247ad6c58e1_10309_1024x0_resize_q75_box.jpg 1024w"
width="453"
height="190"
loading="lazy"
alt="image-39">
&lt;/a>
&lt;figcaption>image-39&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接着深入查看一下&lt;code>h&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 132; flex-basis: 317px">
&lt;a href="/posts/hack/xeasemusic/40.jpg" data-size="200x151">&lt;img src="/posts/hack/xeasemusic/40.jpg"
srcset="/posts/hack/xeasemusic/40_hue291cbe0877007806e7e8c4444a30946_4005_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/40_hue291cbe0877007806e7e8c4444a30946_4005_1024x0_resize_q75_box.jpg 1024w"
width="200"
height="151"
loading="lazy"
alt="image-40">
&lt;/a>
&lt;figcaption>image-40&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再看看&lt;code>i&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 202; flex-basis: 485px">
&lt;a href="/posts/hack/xeasemusic/41.jpg" data-size="615x304">&lt;img src="/posts/hack/xeasemusic/41.jpg"
srcset="/posts/hack/xeasemusic/41_hu440009b23bcc71c983ca2877fb9cac68_30177_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/41_hu440009b23bcc71c983ca2877fb9cac68_30177_1024x0_resize_q75_box.jpg 1024w"
width="615"
height="304"
loading="lazy"
alt="image-41">
&lt;/a>
&lt;figcaption>image-41&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>这里出现了一个关键的类 &lt;code>LoadingAdFragment&lt;/code>, 看名字就像是一个读取广告的, 点进去查看一下类的代码可以看到, 在&lt;code>onCreate&lt;/code>的时候从&lt;code>Bundle&lt;/code>里尝试读取&lt;code>AdInfo&lt;/code>&lt;/strong>, 这越看越像广告&lt;/p>
&lt;p>&lt;figure style="flex-grow: 160; flex-basis: 385px">
&lt;a href="/posts/hack/xeasemusic/44.jpg" data-size="432x269">&lt;img src="/posts/hack/xeasemusic/44.jpg"
srcset="/posts/hack/xeasemusic/44_hue92639689ceb27d8dc11563d32b4fc4e_16869_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/44_hue92639689ceb27d8dc11563d32b4fc4e_16869_1024x0_resize_q75_box.jpg 1024w"
width="432"
height="269"
loading="lazy"
alt="image-44">
&lt;/a>
&lt;figcaption>image-44&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>那么看一下取的&lt;code>key&lt;/code>名称, 也就是变量&lt;code>f5823d&lt;/code>的值&lt;/p>
&lt;p>&lt;figure style="flex-grow: 293; flex-basis: 705px">
&lt;a href="/posts/hack/xeasemusic/43.jpg" data-size="476x162">&lt;img src="/posts/hack/xeasemusic/43.jpg"
srcset="/posts/hack/xeasemusic/43_hu07b44b2ae8472fff98065399b87b3e1a_13397_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/43_hu07b44b2ae8472fff98065399b87b3e1a_13397_1024x0_resize_q75_box.jpg 1024w"
width="476"
height="162"
loading="lazy"
alt="image-43">
&lt;/a>
&lt;figcaption>image-43&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>可以看到这个键的名称也是叫做&lt;code>adInfo&lt;/code>, 那么根据&lt;code>onCreate&lt;/code>里的代码来看,如果取不到&lt;code>adInfo&lt;/code>, 那应该就不会展示广告了吧&lt;/strong>, 而&lt;code>arguments&lt;/code>参数是从&lt;code>getArguments()&lt;/code>方法中获取的, 点进去看一下这个方法的实现&lt;/p>
&lt;p>&lt;figure style="flex-grow: 206; flex-basis: 495px">
&lt;a href="/posts/hack/xeasemusic/45.jpg" data-size="504x244">&lt;img src="/posts/hack/xeasemusic/45.jpg"
srcset="/posts/hack/xeasemusic/45_hu6325548375b8a613a6d3076fa4d99c71_18813_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/45_hu6325548375b8a613a6d3076fa4d99c71_18813_1024x0_resize_q75_box.jpg 1024w"
width="504"
height="244"
loading="lazy"
alt="image-45">
&lt;/a>
&lt;figcaption>image-45&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到&lt;code>getArguments()&lt;/code>只是返回了&lt;code>this.mArguments&lt;/code>, 而&lt;code>this.mArguments&lt;/code>是从&lt;code>setArguments(Bundle bundle)&lt;/code>赋值的, &lt;strong>那我只要拦截赋值方法将&lt;code>adInfo&lt;/code>这个广告过滤掉就可以了&lt;/strong>&lt;/p>
&lt;p>于是编写&lt;code>xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;androidx.fragment.app.Fragment&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;setArguments&amp;quot;,
Bundle.class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
Bundle arg = (Bundle) param.args[0];
if (arg == null || !arg.containsKey(&amp;quot;adInfo&amp;quot;)) {
return;
}
arg.putSerializable(&amp;quot;adInfo&amp;quot;, null);
}
}
);
&lt;/code>&lt;/pre>&lt;p>这里拦截了&lt;code>setArguments&lt;/code>, 判断传入的参数是否包含键为&lt;code>adInfo&lt;/code>的参数, 如果有的话, 把这个&lt;code>bundle&lt;/code>设置为&lt;code>null&lt;/code>&lt;/p>
&lt;p>但这并不完美, 因为只是隐藏了广告, 请求广告的代码任然会执行, 浪费资源, 因此继续深入追踪代码, 再经过一番我也不记得当时怎么找到现在也因为很复杂懒得找的寻找之后, 最终确定到&lt;code>com.马赛克ease.马赛克music.module.ad.a.a&lt;/code>类中的&lt;code>a(int, string)&lt;/code>是实际执行请求广告的代码, 如下:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 421; flex-basis: 1012px">
&lt;a href="/posts/hack/xeasemusic/46.jpg" data-size="1004x238">&lt;img src="/posts/hack/xeasemusic/46.jpg"
srcset="/posts/hack/xeasemusic/46_hu169fb9caf5cc741615e5f8bd116b3726_26246_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/46_hu169fb9caf5cc741615e5f8bd116b3726_26246_1024x0_resize_q75_box.jpg 1024w"
width="1004"
height="238"
loading="lazy"
alt="image-46">
&lt;/a>
&lt;figcaption>image-46&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这一部分代码无法反编译出来, 但问题不大, 反正不需要执行这部分代码, 直接编写&lt;code>xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;com.马赛克ease.马赛克music.module.ad.a&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;a&amp;quot;,
int.class,
String.class,
new XC_MethodReplacement() {
@Override
protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable {
return null;
}
}
);
&lt;/code>&lt;/pre>&lt;p>直接拦截并替换掉目标方法, 不做任何事情, 这样一来就不会再请求广告了, 编译后运行发现进入速度变快了也没有烦人的开屏广告了&lt;/p>
&lt;h2 id="6去除更新检查">6.去除更新检查&lt;/h2>
&lt;p>更新弹窗非常烦人, 必须干掉. 首先一般更新检查都是调用的同一个地方的代码, 直接来到APP的&amp;quot;关于&amp;quot;界面, 找到更新检查按钮, 通过&lt;a class="link" href="https://developer.android.google.cn/studio/profile/monitor" target="_blank" rel="noopener"
>Android Device Monitor&lt;/a>可以看到更新按钮的&lt;code>id&lt;/code>为&lt;code>updateVersionArea&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 226; flex-basis: 544px">
&lt;a href="/posts/hack/xeasemusic/47.jpg" data-size="1197x528">&lt;img src="/posts/hack/xeasemusic/47.jpg"
srcset="/posts/hack/xeasemusic/47_hud947ccd3a7c7b7136eb52056bb56732d_61563_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/47_hud947ccd3a7c7b7136eb52056bb56732d_61563_1024x0_resize_q75_box.jpg 1024w"
width="1197"
height="528"
loading="lazy"
alt="image-47">
&lt;/a>
&lt;figcaption>image-47&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>全局搜索这个&lt;code>id&lt;/code>, 在&lt;code>setOnClickListener&lt;/code>处有调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 127; flex-basis: 306px">
&lt;a href="/posts/hack/xeasemusic/48.jpg" data-size="646x506">&lt;img src="/posts/hack/xeasemusic/48.jpg"
srcset="/posts/hack/xeasemusic/48_hue442558403451ff61162f07f30f426d4_45011_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/48_hue442558403451ff61162f07f30f426d4_45011_1024x0_resize_q75_box.jpg 1024w"
width="646"
height="506"
loading="lazy"
alt="image-48">
&lt;/a>
&lt;figcaption>image-48&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这里直接通过调用方法传入了参数, 一路跟踪这个方法, 都是比较简单的调用, 这里的分支查看&lt;code>super.a(z)&lt;/code>的代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 502; flex-basis: 1206px">
&lt;a href="/posts/hack/xeasemusic/50.jpg" data-size="754x150">&lt;img src="/posts/hack/xeasemusic/50.jpg"
srcset="/posts/hack/xeasemusic/50_hu3c01c65140aac6ca3e8e56aaa092b83a_11725_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/50_hu3c01c65140aac6ca3e8e56aaa092b83a_11725_1024x0_resize_q75_box.jpg 1024w"
width="754"
height="150"
loading="lazy"
alt="image-50">
&lt;/a>
&lt;figcaption>image-50&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>最终会来到&lt;code>com.马赛克ease.马赛克music.appupdate.a.a&lt;/code>类, 看这个包名推测确实没找错地方, 而最终调用的&lt;code>a(boolean)&lt;/code>应该就是检查更新的核心代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 143; flex-basis: 345px">
&lt;a href="/posts/hack/xeasemusic/49.jpg" data-size="640x445">&lt;img src="/posts/hack/xeasemusic/49.jpg"
srcset="/posts/hack/xeasemusic/49_hu39405a5d90059febad4cd7ce50059634_31986_480x0_resize_q75_box.jpg 480w, /posts/hack/xeasemusic/49_hu39405a5d90059febad4cd7ce50059634_31986_1024x0_resize_q75_box.jpg 1024w"
width="640"
height="445"
loading="lazy"
alt="image-49">
&lt;/a>
&lt;figcaption>image-49&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>不多说直接编写&lt;code>xposed&lt;/code>代码进行拦截, 代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;com.马赛克ease.马赛克music.appupdate.a&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;a&amp;quot;,
boolean.class,
new XC_MethodReplacement() {
@Override
protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable {
return null;
}
}
);
&lt;/code>&lt;/pre>&lt;p>直接将拦截目标方法替换掉, 不执行任何业务, 编译后再次打开APP会发现已经去除了更新检查, 至此, 所有该整改都已经完成&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;hr>
&lt;ul>
&lt;li>&lt;em>由于这APP将所有字符串加密, 因此很多节点无法直接通过文本搜索, &lt;strong>经发现其解密部分的代码位于&lt;code>a.auu.a&lt;/code>的&lt;code>c(string)&lt;/code>方法&lt;/strong>, 可以通过&lt;code>xposed&lt;/code>拦截前后参数来获得解密前和解密后的数据, 代码如下&lt;/em>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;a.auu.a&amp;quot;, loadPackageParam.classLoader,
&amp;quot;c&amp;quot;,
String.class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
strBeforeDec = param.args[0];
}
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
MyLog.log(strBeforeDec.toString(), param.getResult().toString(), doLog);
}
}
);
&lt;/code>&lt;/pre>&lt;p>该代码先拦截入参, 把参数记录一下, 在解密方法执行完之后打印入参和出参, 除此之外, 也可以使用&lt;code>xposed&lt;/code>去主动调用解密方法, 代码如下&lt;/p>
&lt;pre>&lt;code>Class[] argCls = new Class[]{String.class};
Object result = callStaticMethod(findClass(&amp;quot;a.auu.a&amp;quot;, loadPackageParam.classLoader), &amp;quot;c&amp;quot;, argCls, &amp;quot;待解密&amp;quot;);
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>&lt;em>拦截存储目录&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>可以通过以下代码拦截APP能够获取到的储存目录&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(
&amp;quot;com.马赛克ease.马赛克music.utils.马赛克easeMusicUtils&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;c&amp;quot;,
boolean.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
}
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
}
}
);
&lt;/code>&lt;/pre>&lt;p>&lt;code>马赛克easeMusicUtils&lt;/code>工具类包含读取内置存储目录的方法, 可以在这里拦截并修改对应参数使得APP读取指定的目录&lt;/p>
&lt;blockquote>
&lt;p>当初是因为APP总是读取到我音乐文件夹以外的文件夹, APP自带的过滤器又没有效果, 只能我自己改了&lt;/p>
&lt;/blockquote>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>不得不说这混淆确实增加了很多麻烦, 尤其是当初找广告代码的时候, 不过随着经验的增加现在找起来比以前快了很多, 另外国产APP真就一个比一个流氓, 越更新越是增加乱七八糟的功能, 因为可以同步歌单才一直没卸载, 但随着版权越抓越紧, 它已经越来越不好用了, 现在移动端已经卸载换了一个纯粹的本地播放器, 希望PC端能够保持初心吧&lt;/p></description></item><item><title>Stellio Player破解专业版</title><link>/posts/hack/xstellio/</link><pubDate>Fri, 05 Nov 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xstellio/</guid><description>&lt;img src="/posts/hack/xstellio/cover.png" alt="Featured image of post Stellio Player破解专业版" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>最近发现一直在用的某抑云音乐越来越不行了, 没版权下架歌曲我可以理解, 但下架了也不告诉具体下架了哪些歌曲, 害得我都不知道该怎么找. 更无语的是我自己上传到某易云盘的歌曲都会因为版权问题无法添加到歌单, 而它自身的本地播放功能做的又太垃圾, 于是只能另谋出路, 在&lt;a class="link" href="https://play.google.com" target="_blank" rel="noopener"
>Google Play&lt;/a>上找到一款本地播放器, 兼顾美观和功能简单实用, 不过免费版有点小广告, 然后试了几款去广告的插件, 都不能完美去除, 而我作为强迫症决定一定要处理掉&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>去掉各处的广告以及订购按钮&lt;/p>
&lt;h2 id="受害者版本">受害者版本&lt;/h2>
&lt;p>V.6.2.15&lt;/p>
&lt;h2 id="app界面以及广告">APP界面以及广告&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 99; flex-basis: 237px">
&lt;a href="/posts/hack/xstellio/1.jpg" data-size="1000x1009">&lt;img src="/posts/hack/xstellio/1.jpg"
srcset="/posts/hack/xstellio/1_hu84a6b4f4679fa88e6820ec89f2ede010_102806_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/1_hu84a6b4f4679fa88e6820ec89f2ede010_102806_1024x0_resize_q75_box.jpg 1024w"
width="1000"
height="1009"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>打开&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 直接把安装包即&lt;code>.apk&lt;/code>文件拖进去, 发现软件没有加壳, 顺利反编译出了播放器源码, 然后直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 163; flex-basis: 392px">
&lt;a href="/posts/hack/xstellio/2.jpg" data-size="987x603">&lt;img src="/posts/hack/xstellio/2.jpg"
srcset="/posts/hack/xstellio/2_hu5986480b0f5e8dfb017c4fbe2792392b_64316_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/2_hu5986480b0f5e8dfb017c4fbe2792392b_64316_1024x0_resize_q75_box.jpg 1024w"
width="987"
height="603"
loading="lazy"
alt="源码">
&lt;/a>
&lt;figcaption>源码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到虽然源码没有加壳, 但还是有做混淆的, 不过问题不大, 首先通过&lt;a class="link" href="https://developer.android.google.cn/studio/profile/monitor" target="_blank" rel="noopener"
>Android Device Monitor&lt;/a>解析一下当前页面的布局&lt;/p>
&lt;p>&lt;figure style="flex-grow: 141; flex-basis: 340px">
&lt;a href="/posts/hack/xstellio/3.jpg" data-size="1066x752">&lt;img src="/posts/hack/xstellio/3.jpg"
srcset="/posts/hack/xstellio/3_hub75a98e0be4b7366ef30cfe4edbf1c62_89568_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/3_hub75a98e0be4b7366ef30cfe4edbf1c62_89568_1024x0_resize_q75_box.jpg 1024w"
width="1066"
height="752"
loading="lazy"
alt="布局">
&lt;/a>
&lt;figcaption>布局&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现主界面中的歌曲列表部分组件的&lt;code>id&lt;/code>为&lt;code>content&lt;/code>, 于是全局搜索&lt;code>@+id/content&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 147; flex-basis: 353px">
&lt;a href="/posts/hack/xstellio/4.jpg" data-size="927x630">&lt;img src="/posts/hack/xstellio/4.jpg"
srcset="/posts/hack/xstellio/4_hu5862e1bc09ddd38b5cf2cb54b8300228_88949_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/4_hu5862e1bc09ddd38b5cf2cb54b8300228_88949_1024x0_resize_q75_box.jpg 1024w"
width="927"
height="630"
loading="lazy"
alt="content">
&lt;/a>
&lt;figcaption>content&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现多处搜索结果, 根据当前APP所在界面以及布局文件命名推测&lt;code>mian_layout&lt;/code>应该是其布局文件, 分别看看上面的&lt;code>viewAnim&lt;/code>和&lt;code>viewAnimWithoutBackground&lt;/code>, 这两个&lt;code>id&lt;/code>在当前&lt;a class="link" href="https://developer.android.google.cn/studio/profile/monitor" target="_blank" rel="noopener"
>Android Device Monitor&lt;/a>解析的界面中都能找到对应节点, 验证了猜想, 如下图&lt;/p>
&lt;p>&lt;figure style="flex-grow: 170; flex-basis: 408px">
&lt;a href="/posts/hack/xstellio/5.jpg" data-size="1037x609">&lt;img src="/posts/hack/xstellio/5.jpg"
srcset="/posts/hack/xstellio/5_huce05d117b1ebe37ea498858ca09bf3a9_67148_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/5_huce05d117b1ebe37ea498858ca09bf3a9_67148_1024x0_resize_q75_box.jpg 1024w"
width="1037"
height="609"
loading="lazy"
alt="DDMS">
&lt;/a>
&lt;figcaption>DDMS&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>现在要找展示广告的组件了, 通过刚才的搜索结果可以看到, 在&lt;code>main_layout&lt;/code>中并没有存在疑似专门用于展示广告的节点, 所以还是很有可能是在运行过程中动态添加的, 于是我们直接搜索&lt;code>main_layout&lt;/code>, 找到使用到此布局的&lt;code>MainActivity&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 661; flex-basis: 1587px">
&lt;a href="/posts/hack/xstellio/6.jpg" data-size="926x140">&lt;img src="/posts/hack/xstellio/6.jpg"
srcset="/posts/hack/xstellio/6_hu8f009634a94c4a26e265e35517db6303_13865_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/6_hu8f009634a94c4a26e265e35517db6303_13865_1024x0_resize_q75_box.jpg 1024w"
width="926"
height="140"
loading="lazy"
alt="搜索Activity">
&lt;/a>
&lt;figcaption>搜索Activity&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>由于暂时没有其他线索, 先看看&lt;code>onCreate&lt;/code>源码能不能发现什么&lt;/p>
&lt;p>&lt;figure style="flex-grow: 214; flex-basis: 515px">
&lt;a href="/posts/hack/xstellio/7.jpg" data-size="702x327">&lt;img src="/posts/hack/xstellio/7.jpg"
srcset="/posts/hack/xstellio/7_hua2df446cae231cd1121fceeecb7400c6_22936_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/7_hua2df446cae231cd1121fceeecb7400c6_22936_1024x0_resize_q75_box.jpg 1024w"
width="702"
height="327"
loading="lazy"
alt="onCreate">
&lt;/a>
&lt;figcaption>onCreate&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到实现比较简单, 再看看在父类的代码, 来到&lt;code>D2&lt;/code>方法, 有多个实现, 这里看&lt;code>MainActivity&lt;/code>的实现&lt;/p>
&lt;p>&lt;figure style="flex-grow: 138; flex-basis: 332px">
&lt;a href="/posts/hack/xstellio/9.jpg" data-size="642x464">&lt;img src="/posts/hack/xstellio/9.jpg"
srcset="/posts/hack/xstellio/9_hud1b50cad1b408b933a257718d87e64da_37282_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/9_hud1b50cad1b408b933a257718d87e64da_37282_1024x0_resize_q75_box.jpg 1024w"
width="642"
height="464"
loading="lazy"
alt="D2">
&lt;/a>
&lt;figcaption>D2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>都是一些混淆代码, 咱也看不懂, 凭直觉都过一下, 此时在&lt;code>D2&lt;/code>中就发现可疑类&lt;code>GooglePlayPurchaseChecker&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 223; flex-basis: 536px">
&lt;a href="/posts/hack/xstellio/10.jpg" data-size="798x357">&lt;img src="/posts/hack/xstellio/10.jpg"
srcset="/posts/hack/xstellio/10_hu94a6d72fd6ef877b1ce6ac936a94f3df_36817_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/10_hu94a6d72fd6ef877b1ce6ac936a94f3df_36817_1024x0_resize_q75_box.jpg 1024w"
width="798"
height="357"
loading="lazy"
alt="D2实现">
&lt;/a>
&lt;figcaption>D2实现&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>考虑到APP是从&lt;a class="link" href="https://play.google.com" target="_blank" rel="noopener"
>Google Play&lt;/a>上下载的, 可以在&lt;a class="link" href="https://play.google.com" target="_blank" rel="noopener"
>Google Play&lt;/a>上购买进行解锁, 那么这个类名就显得很可疑了, 跟踪进去看看都写了啥&lt;/p>
&lt;p>&lt;figure style="flex-grow: 457; flex-basis: 1098px">
&lt;a href="/posts/hack/xstellio/11.jpg" data-size="888x194">&lt;img src="/posts/hack/xstellio/11.jpg"
srcset="/posts/hack/xstellio/11_hu6c81857d4a3858f4a5b853d12fbb51ba_15222_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/11_hu6c81857d4a3858f4a5b853d12fbb51ba_15222_1024x0_resize_q75_box.jpg 1024w"
width="888"
height="194"
loading="lazy"
alt="checker-1">
&lt;/a>
&lt;figcaption>checker-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>首先直接内部调用 &lt;code>aVar.g&lt;/code>, 继续跟踪&lt;/p>
&lt;p>&lt;figure style="flex-grow: 153; flex-basis: 368px">
&lt;a href="/posts/hack/xstellio/12.jpg" data-size="740x482">&lt;img src="/posts/hack/xstellio/12.jpg"
srcset="/posts/hack/xstellio/12_huc8ee2600bafdd860fa8d7688126cf3f6_42566_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/12_huc8ee2600bafdd860fa8d7688126cf3f6_42566_1024x0_resize_q75_box.jpg 1024w"
width="740"
height="482"
loading="lazy"
alt="checker-2">
&lt;/a>
&lt;figcaption>checker-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现这里的&lt;code>LinkedHashMap&lt;/code>中存放了名为&lt;code>stellio_all_inclusive&lt;/code>和&lt;code>stellio_premium&lt;/code>的键, 首先这俩键的名字就很可疑, 而他们的值存储为布尔, 此时注意到有枚举&lt;code>ResolvedLicense&lt;/code>用于分辨APP解锁状态&lt;/p>
&lt;p>&lt;figure style="flex-grow: 215; flex-basis: 517px">
&lt;a href="/posts/hack/xstellio/14.jpg" data-size="591x274">&lt;img src="/posts/hack/xstellio/14.jpg"
srcset="/posts/hack/xstellio/14_hu3787dc1eafc6c9c262e5e0d0fbf885d0_14878_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/14_hu3787dc1eafc6c9c262e5e0d0fbf885d0_14878_1024x0_resize_q75_box.jpg 1024w"
width="591"
height="274"
loading="lazy"
alt="枚举">
&lt;/a>
&lt;figcaption>枚举&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>综合起来推测这个&lt;code>Map&lt;/code>应该就是用于初始化一个授权值的, 以给定键的布尔值是否为&lt;code>true&lt;/code>来判断应用是否已经购买, 那么我只要在初始化的时候把这个&lt;code>Map&lt;/code>的值固定写死成&lt;code>true&lt;/code>, 应该就可以让APP认为已经购买过了, 编写&lt;code>Xposed&lt;/code>代码如下&lt;/strong>&lt;/p>
&lt;pre>&lt;code>findAndHookConstructor(
&amp;quot;air.stellio.player.Helpers.GooglePlayPurchaseChecker&amp;quot;,
loadPackageParam.classLoader,
&amp;quot;air.stellio.player.Activities.u&amp;quot;,
&amp;quot;org.solovyev.android.checkout.F&amp;quot;,
Map.class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
MyLog.log(&amp;quot;hookin GooglePlayPurchaseChecker()&amp;quot;, doLog);
Map&amp;lt;String, Boolean&amp;gt; arg3 = (Map&amp;lt;String, Boolean&amp;gt;) param.args[2];
if(null == arg3) {
arg3 = new LinkedHashMap&amp;lt;&amp;gt;();
param.args[2] = arg3;
}
arg3.put(&amp;quot;stellio_all_inclusive&amp;quot;, true);
arg3.put(&amp;quot;stellio_premium&amp;quot;, true);
}
}
);
&lt;/code>&lt;/pre>&lt;p>&lt;strong>观察&lt;code>GooglePlayPurchaseChecker&lt;/code>类中的赋值代码可以发现, 主要是通过构造函数将&lt;code>Map&lt;/code>的值存储的, 因此使用&lt;code>Xposed&lt;/code>的&lt;code>findAndHookConstructor&lt;/code>去挂钩&lt;code>GooglePlayPurchaseChecker&lt;/code>的构造函数, 在构造函数执行之前, 修改传入的第三个参数&lt;code>Map&lt;/code>, 把键为&lt;code>stellio_premium&lt;/code>和&lt;code>stellio_all_inclusive&lt;/code>的值存为&lt;code>true&lt;/code>, 这样当构造函数执行的时候, 会永远认为这是已订购的了&lt;/strong>&lt;/p>
&lt;p>安装模块并运行, 此时可以发现APP中的广告以及订购按钮都没有了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 98; flex-basis: 236px">
&lt;a href="/posts/hack/xstellio/15.jpg" data-size="956x970">&lt;img src="/posts/hack/xstellio/15.jpg"
srcset="/posts/hack/xstellio/15_hud7213b12b55b97141f54d09bb78f35c7_90789_480x0_resize_q75_box.jpg 480w, /posts/hack/xstellio/15_hud7213b12b55b97141f54d09bb78f35c7_90789_1024x0_resize_q75_box.jpg 1024w"
width="956"
height="970"
loading="lazy"
alt="Yeah">
&lt;/a>
&lt;figcaption>Yeah&lt;/figcaption>
&lt;/figure>&lt;/p></description></item><item><title>三星ONEUI修改记录</title><link>/posts/hack/xrom/oneui/</link><pubDate>Mon, 23 Aug 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xrom/oneui/</guid><description>&lt;img src="/posts/hack/xrom/oneui/cover.png" alt="Featured image of post 三星ONEUI修改记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>由于个人喜好, 比较喜欢直角屏的手机, 但市面上的手机放眼望去只有三星Note系列符合我的爱好, 遂购买三星Note 10御用, 然而这手机虽然造型是方方正正的, 但是UI却跟S系列一样到处都是圆角, 这让我很不舒服, 于是有了此文章&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>将系统UI的圆角修改为直角&lt;/p>
&lt;h2 id="三星oneui修改前后对比图">三星ONEUI修改前后对比图&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 95; flex-basis: 230px">
&lt;a href="/posts/hack/xrom/oneui/1.jpg" data-size="860x897">&lt;img src="/posts/hack/xrom/oneui/1.jpg"
srcset="/posts/hack/xrom/oneui/1_hu5d6c6fa8a81d3ddb6e788f41996e2afb_131804_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/1_hu5d6c6fa8a81d3ddb6e788f41996e2afb_131804_1024x0_resize_q75_box.jpg 1024w"
width="860"
height="897"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="基础知识">基础知识&lt;/h2>
&lt;p>&lt;strong>再开始之前, 首先需要了解一下基础知识&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1. 安卓系统的UI构成&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>安卓系统的界面呈现都是由内置在系统的APP构成的, 其APP一般位于 &lt;code>/system/app&lt;/code> 和 &lt;code>/system/priv-app&lt;/code>, 还有一个系统APP引用的公共框架APP, 位于 &lt;code>/system/framework/framework-res.apk&lt;/code>, 部分系统例如&lt;a class="link" href="https://www.flyme.com/" target="_blank" rel="noopener"
>Flyme&lt;/a>在此目录还会有另外一个自己的框架APP, 命名通常以自家OS命名, 此处不作过多介绍, 界面中比较常见的APP如下&lt;/li>
&lt;li>&lt;code>framework-res.apk&lt;/code> 系统应用引用的界面, 例如提示信息弹窗&lt;/li>
&lt;li>&lt;code>SystemUI.apk&lt;/code> 系统通知栏界面, 通知弹窗界面&lt;/li>
&lt;li>&lt;code>Settings.apk&lt;/code> 系统设置界面, OneUI中此APP名称为 &lt;code>SecSettings.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Messages.apk&lt;/code> 短信界面, OneUI中为&lt;code>SamsungMessages_11.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Gallery.apk&lt;/code> 相册界面, OneUI中为&lt;code>SamsungGallery2018.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Dialer.apk&lt;/code> 拨号器,通话记录,联系人界面, OneUI中为&lt;code>SamsungDialer.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Clock.apk&lt;/code> 时钟,闹钟,计时器界面, OneUI中为&lt;code>ClockPackage.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Finder.apk&lt;/code> OneUI启动器(桌面)独有的搜索组件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 安卓实现圆角的基本方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简单的实现安卓圆角可以通过&lt;code>&amp;lt;Shape&amp;gt;&lt;/code>来实现, 其中&lt;code>&amp;lt;Corner&amp;gt;&lt;/code>节点的属性&lt;code>xxxRadius&lt;/code>为关键属性, 例如&lt;code>bottomRightRadius&lt;/code>&lt;/li>
&lt;li>通常是APP开发者为了减少代码重复率, 会定义一个统一风格而定义的一个统一的资源文件&lt;code>dimens.xml&lt;/code>, 所有用到同样值的地方都会引用这个文件, 方便修改和风格统一&lt;/li>
&lt;/ul>
&lt;h2 id="开始修改">开始修改&lt;/h2>
&lt;p>首先修改&lt;code>framework-res.apk&lt;/code>, 由于需要对源码反编译和回编译, 所以需要用到安卓反编译工具 &lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>, 本人修改时使用的版本为&lt;code>v2.4.1&lt;/code>&lt;/p>
&lt;p>首先使用命令进行反编译&lt;/p>
&lt;pre>&lt;code>apktool d framework-res.apk
&lt;/code>&lt;/pre>&lt;p>中途没有错误则表示反编译成功&lt;/p>
&lt;p>&lt;figure style="flex-grow: 226; flex-basis: 542px">
&lt;a href="/posts/hack/xrom/oneui/4.jpg" data-size="441x195">&lt;img src="/posts/hack/xrom/oneui/4.jpg"
srcset="/posts/hack/xrom/oneui/4_huc7bba1b11dca74ac5172c1c46aa53bed_19048_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/4_huc7bba1b11dca74ac5172c1c46aa53bed_19048_1024x0_resize_q75_box.jpg 1024w"
width="441"
height="195"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>即可在当前目录生成反编译后的源码文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 304; flex-basis: 731px">
&lt;a href="/posts/hack/xrom/oneui/2.jpg" data-size="622x204">&lt;img src="/posts/hack/xrom/oneui/2.jpg"
srcset="/posts/hack/xrom/oneui/2_huf31c70d17decd1fd0d84732f531b198c_15664_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/2_huf31c70d17decd1fd0d84732f531b198c_15664_1024x0_resize_q75_box.jpg 1024w"
width="622"
height="204"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>目录简单介绍下&lt;/p>
&lt;ul>
&lt;li>&lt;code>assets&lt;/code> 为APP所用到的额外资源文件包, 可以是任何东西&lt;/li>
&lt;li>&lt;code>original&lt;/code> 顾名思义存放原始文件&lt;/li>
&lt;li>&lt;code>res&lt;/code> APP所用到的资源文件, 例如图标, 国际化文本, 图形, 布局文件等&lt;/li>
&lt;li>&lt;code>unknown&lt;/code> 工具无法解析的文件, 回编译后会按照原样编译进去&lt;/li>
&lt;li>&lt;code>AndroidManifest.xml&lt;/code> APP清单文件, 记录了版本号, 包名, 权限等重要信息&lt;/li>
&lt;li>&lt;code>apktool.yml&lt;/code> 记录了&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>回编译时需要参考的信息&lt;/li>
&lt;/ul>
&lt;p>可以看到在此&lt;code>framework-res.apk&lt;/code>中仅定义了资源文件, 并没有代码文件, 有代码的APP将在下文介绍, 在此&lt;code>framework-res.apk&lt;/code>中, 只需要关注&lt;code>res&lt;/code>文件夹下的资源文件就行, 我们把整个文件夹用IDEA打开, 然后根据圆角的基础知识, 直接简单粗暴先从搜索Radius开始&lt;/p>
&lt;p>&lt;figure style="flex-grow: 168; flex-basis: 403px">
&lt;a href="/posts/hack/xrom/oneui/3.jpg" data-size="548x326">&lt;img src="/posts/hack/xrom/oneui/3.jpg"
srcset="/posts/hack/xrom/oneui/3_huc0d768625189ac03a2f8780a6b2bc097_25101_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/3_huc0d768625189ac03a2f8780a6b2bc097_25101_1024x0_resize_q75_box.jpg 1024w"
width="548"
height="326"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现多处结果, 我们缩小一下搜索范围, 可以自己写一个小的安卓应用, 定义个圆角并尝试不同圆度, 根据多次测试观察到资源文件中圆度值为&lt;code>26.0dip&lt;/code>的比较符合, 因此搜索&lt;code>radius=&amp;quot;26.0dip&lt;/code>, 可以发现结果少了很多&lt;/p>
&lt;p>&lt;figure style="flex-grow: 185; flex-basis: 444px">
&lt;a href="/posts/hack/xrom/oneui/5.jpg" data-size="1108x598">&lt;img src="/posts/hack/xrom/oneui/5.jpg"
srcset="/posts/hack/xrom/oneui/5_hu9851f0a41ebb9e774553d5f13b36359e_93816_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/5_hu9851f0a41ebb9e774553d5f13b36359e_93816_1024x0_resize_q75_box.jpg 1024w"
width="1108"
height="598"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接着根据资源文件命名可以大致猜出这些对应的都是哪些部分的圆角, 例如&lt;code>notification_template_view_bg.xml&lt;/code>应该就是定义的通知模板背景, 根据经验这些都可以改成直角, &lt;strong>因此直接将所有的&lt;code>26.0dip&lt;/code>修改为&lt;code>0.0dip&lt;/code>&lt;/strong>&lt;/p>
&lt;p>之后, 为了更彻底的覆盖所有部分, 继续深入搜索, 只搜索&lt;code>26.0dip&lt;/code>, 发现更多结果&lt;/p>
&lt;p>&lt;figure style="flex-grow: 341; flex-basis: 819px">
&lt;a href="/posts/hack/xrom/oneui/6.jpg" data-size="570x167">&lt;img src="/posts/hack/xrom/oneui/6.jpg"
srcset="/posts/hack/xrom/oneui/6_hu54dfad81cf3ac8bdf8566165f6799c89_17839_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/6_hu54dfad81cf3ac8bdf8566165f6799c89_17839_1024x0_resize_q75_box.jpg 1024w"
width="570"
height="167"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>例如在&lt;code>dimens.xml&lt;/code>中定义的一些值为&lt;code>26.0dip&lt;/code>的数据, 需要仔细观察其&lt;code>name&lt;/code>, 因为不是所有值为&lt;code>26.0dip&lt;/code>的都需要修改, 例如第一行的&lt;code>car_seekbar_padding&lt;/code>看名字就知道是一个填充值, 这个是不需要修改的, 但是下面的&lt;code>sem_menu_popup_corner_radius&lt;/code>这种是需要修改的, 主要是经验和推测, 我们将这些需要修改的统统修改为&lt;code>0.0dip&lt;/code>&lt;/p>
&lt;p>所有圆角修改完之后, 开始回编译, 在反编译出来的目录下, 执行命令&lt;/p>
&lt;pre>&lt;code>apktool b framework-res
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 282; flex-basis: 677px">
&lt;a href="/posts/hack/xrom/oneui/7.jpg" data-size="500x177">&lt;img src="/posts/hack/xrom/oneui/7.jpg"
srcset="/posts/hack/xrom/oneui/7_huf413cbbe33fd397a6c45ad0312751bc7_12881_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/7_huf413cbbe33fd397a6c45ad0312751bc7_12881_1024x0_resize_q75_box.jpg 1024w"
width="500"
height="177"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>像这样没有错误说明回编译成功了, 打开&lt;code>framework-res&lt;/code>文件夹, 会发现里面多了两个文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 324; flex-basis: 778px">
&lt;a href="/posts/hack/xrom/oneui/8.jpg" data-size="581x179">&lt;img src="/posts/hack/xrom/oneui/8.jpg"
srcset="/posts/hack/xrom/oneui/8_hu48b4617a21b223dc5bee7c74403aeb16_15952_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/8_hu48b4617a21b223dc5bee7c74403aeb16_15952_1024x0_resize_q75_box.jpg 1024w"
width="581"
height="179"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>&lt;code>build&lt;/code> 回编译构建编译后的资源文件&lt;/li>
&lt;li>&lt;code>dist&lt;/code> 回编译后生成的APK文件&lt;/li>
&lt;/ul>
&lt;p>打开&lt;code>dist&lt;/code>文件夹, 可以看到生成的&lt;code>framework-res.apk&lt;/code>文件, 接下来需要将它替换到系统里去&lt;/p>
&lt;p>我们有四中方式替换&lt;/p>
&lt;ol>
&lt;li>使用电脑ADB工具执行命令行替换 (简单快捷, 有一定风险)&lt;/li>
&lt;li>复制到手机使用RE管理器替换 (风险较大)&lt;/li>
&lt;li>制作成单刷包替换 (安全性较好, 稍微麻烦一点)&lt;/li>
&lt;li>制作成ROM刷机替换 (性价比不高, 不考虑)&lt;/li>
&lt;/ol>
&lt;p>由于可能需要多次测试效果, 且有多个APK需要修改, 这里采用第一种方式, 需要ROOT&lt;/p>
&lt;p>步骤如下&lt;/p>
&lt;ol>
&lt;li>打开手机里的USB调试&lt;/li>
&lt;li>电脑安装手机的ADB驱动 (每个厂家的手机不一样), 装好后使用USB连接手机&lt;/li>
&lt;li>使用安卓ADB工具执行命令如下&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>//1.将新生成的APK复制到手机存储根目录
adb push framework-res.apk /sdcard/framework-res.apk
//2.执行shell
adb shell
//3.获取超级用户权限
su
//4.复制手机存储的framework-res.apk到系统框架目录
cp /sdcard/framework-res.apk /system/framework/framework-res.apk
//5.将复制进去的新APK重设rw-r-r权限
chmod 644 /system/framework/framework-res.apk
//6.退出shell
exit
//7.重启手机
adb reboot
&lt;/code>&lt;/pre>&lt;p>经过这一系列操作后, 如果没有出现意外, 手机重新开机后就可以看到修改后的效果了, 首先迎面而来的就是手机基础弹窗已经变成直角了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 129; flex-basis: 310px">
&lt;a href="/posts/hack/xrom/oneui/9.jpg" data-size="1080x834">&lt;img src="/posts/hack/xrom/oneui/9.jpg"
srcset="/posts/hack/xrom/oneui/9_hu19b5e1a56315d2e55023b018402d6291_55976_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/9_hu19b5e1a56315d2e55023b018402d6291_55976_1024x0_resize_q75_box.jpg 1024w"
width="1080"
height="834"
loading="lazy"
alt="image-9">
&lt;/a>
&lt;figcaption>image-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意!!! 通常为了防止意外情况发生导致无法开机,需要通过&lt;code>Recovery&lt;/code>备份一次系统,并将备份的系统复制到电脑以防万一,嫌麻烦的话至少也得有一份完整的刷机包,最好制作一份单刷包,如果修改后无法正常进入系统,推荐优先使用单刷包,如果单刷包无法生效,可以使用&lt;code>Recovery&lt;/code>还原系统,如果没有备份系统的,则使用完整的刷机包重刷,但将丢失所有数据(双清的情况),关于单刷包的制作,我将在文章尾部补充&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>但是这还远远不够, 接下来开始处理&lt;code>SecSettings.apk&lt;/code>, 仍然使用&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>按照上文命令进行反编译, 不过在此之前, 需要先给&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>安装&lt;code>framework-res.apk&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>由于系统APP会引用到框架APP, 因此需要给&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>安装框架APP, 才能继续反编译系统APP&lt;/p>
&lt;/blockquote>
&lt;p>通过如下命令安装&lt;code>framework-res.apk&lt;/code>&lt;/p>
&lt;pre>&lt;code>apktool if framework-res.apk
&lt;/code>&lt;/pre>&lt;p>安装之后就可以开始反编译&lt;code>SecSettings.apk&lt;/code>了, 反编译成功之后会发现相比较&lt;code>framework-res.apk&lt;/code>, 多出了几个文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 279; flex-basis: 670px">
&lt;a href="/posts/hack/xrom/oneui/10.jpg" data-size="637x228">&lt;img src="/posts/hack/xrom/oneui/10.jpg"
srcset="/posts/hack/xrom/oneui/10_hu299a94972a09ca962e3e66aec83764b5_19408_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/10_hu299a94972a09ca962e3e66aec83764b5_19408_1024x0_resize_q75_box.jpg 1024w"
width="637"
height="228"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>smali&lt;/code>和&lt;code>smali_classesX&lt;/code> 就是应用的源代码文件, 为&lt;code>.smali&lt;/code>格式的Java字节码, 类似&lt;code>C&lt;/code>程序反编译出来的汇编代码, 我们先使用上文的知识将圆角值为&lt;code>26.0dip&lt;/code>的圆角修改为&lt;code>0.0dip&lt;/code>, 替换进系统后发现只有一部分界面的圆角变成了直角&lt;/p>
&lt;blockquote>
&lt;p>文章编辑于2021年8月, 系统修改于2020年7月, 当时没有保留截图, 现在也没有重新替换的必要, 因此这部分只能描述了&lt;/p>
&lt;/blockquote>
&lt;p>继续检查所有可能造成圆角的值为&lt;code>26.0dip&lt;/code>的&lt;code>.xml&lt;/code>文件, 仍然无法找到可能存在问题的部分, 此时将检查范围扩大到源代码文件, 为了方便阅读, 首先使用&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>反编译&lt;code>SecSettings.apk&lt;/code>, 并将反编译后的&lt;code>.java&lt;/code>源码导入IDEA进行观察, 搜索&lt;code>26&lt;/code>发现一个可疑的方法&lt;code>initRoundedCorner&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 256; flex-basis: 616px">
&lt;a href="/posts/hack/xrom/oneui/11.jpg" data-size="575x224">&lt;img src="/posts/hack/xrom/oneui/11.jpg"
srcset="/posts/hack/xrom/oneui/11_huec727d92949131b085630ae6fb19653f_16918_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/11_huec727d92949131b085630ae6fb19653f_16918_1024x0_resize_q75_box.jpg 1024w"
width="575"
height="224"
loading="lazy"
alt="image-11">
&lt;/a>
&lt;figcaption>image-11&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>此处推测应该是初始化一个圆度为&lt;code>26.0dip&lt;/code>的圆角, 而且这个类是很多类的父类, 应该是从代码层指定了圆角的圆度, 但是此时的&lt;code>.java&lt;/code>源码无法直接修改, 我们回到&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>反编译出来而得到的&lt;code>.smali&lt;/code>源码, 根据类名方法名找到对应在&lt;code>.smali&lt;/code>代码中的&lt;code>initRoundedCorner&lt;/code>如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 188; flex-basis: 452px">
&lt;a href="/posts/hack/xrom/oneui/12.jpg" data-size="758x402">&lt;img src="/posts/hack/xrom/oneui/12.jpg"
srcset="/posts/hack/xrom/oneui/12_hu72d463b836552d68e8f98281bf1d334f_33255_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/12_hu72d463b836552d68e8f98281bf1d334f_33255_1024x0_resize_q75_box.jpg 1024w"
width="758"
height="402"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;code>smali&lt;/code>代码中的第一行也是定义了一个值为26的变量, 直接将&lt;code>0x26&lt;/code>改成&lt;code>0x0&lt;/code>, 然后回编译替换进系统观察效果, 此时可以看到界面基本上已经变成直角了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 47; flex-basis: 113px">
&lt;a href="/posts/hack/xrom/oneui/13.jpg" data-size="1080x2280">&lt;img src="/posts/hack/xrom/oneui/13.jpg"
srcset="/posts/hack/xrom/oneui/13_hu2910d42e718064d6d1e2e549aaa6cfcd_98010_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/13_hu2910d42e718064d6d1e2e549aaa6cfcd_98010_1024x0_resize_q75_box.jpg 1024w"
width="1080"
height="2280"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是进入某些功能的深层选项时会发现仍然有一小部分是圆角的, 不过仔细观察这部分的圆角角度值大概在&lt;code>15.0dip&lt;/code>到&lt;code>16.0dip&lt;/code>左右, 因此继续搜索圆角值为这些的部分, 根据名称将可能的地方修改为&lt;code>0.0dip&lt;/code>即可, 至此&lt;code>SecSettings.apk&lt;/code>全部改完&lt;/p>
&lt;p>接下来按照同样的步骤修改上文列出的剩余的系统APP即可&lt;/p>
&lt;h2 id="关于单刷包的制作">关于单刷包的制作&lt;/h2>
&lt;p>关于单刷包是什么, 有什么作用, 优缺点等网上已经有大量介绍, 此处不多说明, 仅介绍Note10下单刷包的制作&lt;/p>
&lt;p>&lt;strong>制作OneUI单刷包&lt;/strong>&lt;/p>
&lt;p>首先我们需要一个完整的&lt;code>.zip&lt;/code>刷机包, 以我的为例, 假定我们需要保留的文件为&lt;code>SecSettings.apk&lt;/code>, 需要删掉除&lt;code>SecSettings.apk&lt;/code>及其父文件夹以外的东西&lt;/p>
&lt;blockquote>
&lt;p>尽量不要解压修改, 有时候解压了修改再压缩回去会出现奇奇怪怪的问题, 导致签名无法识别, 无法刷入&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 187; flex-basis: 449px">
&lt;a href="/posts/hack/xrom/oneui/14.jpg" data-size="774x413">&lt;img src="/posts/hack/xrom/oneui/14.jpg"
srcset="/posts/hack/xrom/oneui/14_huec55957ac05bb0082d9337619d1bb6b6_40951_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/14_huec55957ac05bb0082d9337619d1bb6b6_40951_1024x0_resize_q75_box.jpg 1024w"
width="774"
height="413"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>例如此处图示的部分, 红框以外的都是可以删除的, 删完后如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 247; flex-basis: 593px">
&lt;a href="/posts/hack/xrom/oneui/15.jpg" data-size="517x209">&lt;img src="/posts/hack/xrom/oneui/15.jpg"
srcset="/posts/hack/xrom/oneui/15_hufce8372ee179d98e83f3be153d42f939_9963_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/15_hufce8372ee179d98e83f3be153d42f939_9963_1024x0_resize_q75_box.jpg 1024w"
width="517"
height="209"
loading="lazy"
alt="image-15">
&lt;/a>
&lt;figcaption>image-15&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>从原始刷机包删除目标以外的东西做成的单刷包通常用于备份恢复, 如果是为了替换成其他文件, 例如需要做成单刷修改后的&lt;code>SecSettings.apk&lt;/code>, 则删除多余文件后, 将修改后的&lt;code>SecSettings.apk&lt;/code>替换到单刷包里的对应目录即可&lt;/p>
&lt;/blockquote>
&lt;p>接下来需要修改刷机脚本, 原始的刷机脚本通常会做很多事, 但是单刷包不需要, 我们打开位于&lt;code>META-INF/com/google/android&lt;/code>下的&lt;code>updater-script&lt;/code>文件, 可以看到如下代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 103; flex-basis: 248px">
&lt;a href="/posts/hack/xrom/oneui/16.jpg" data-size="721x697">&lt;img src="/posts/hack/xrom/oneui/16.jpg"
srcset="/posts/hack/xrom/oneui/16_hudbfb903bb9a530e5c4b99a1c435d4a1d_67487_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/16_hudbfb903bb9a530e5c4b99a1c435d4a1d_67487_1024x0_resize_q75_box.jpg 1024w"
width="721"
height="697"
loading="lazy"
alt="image-16">
&lt;/a>
&lt;figcaption>image-16&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>脚本语言为&lt;code>updater-script&lt;/code>, 具体语法以及含义可以自行查阅, 此处不多作介绍, 我们将内容修改如下&lt;/p>
&lt;pre>&lt;code>ui_print(&amp;quot;Mounting system&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
mount(&amp;quot;ext4&amp;quot;, &amp;quot;EMMC&amp;quot;, &amp;quot;/dev/block/platform/soc/1d84000.ufshc/by-name/system&amp;quot;, &amp;quot;/system&amp;quot;);
ui_print(&amp;quot;Copying modules&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
package_extract_dir(&amp;quot;system&amp;quot;, &amp;quot;/system&amp;quot;);
ui_print(&amp;quot;Unmounting system&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
unmount(&amp;quot;/system&amp;quot;);
show_progress(0.100000, 0);
&lt;/code>&lt;/pre>&lt;p>其中关键代码为 &lt;code>mount&lt;/code>挂载&lt;code>/system&lt;/code>为可写分区, &lt;code>package_extract_dir&lt;/code>将压缩包中&lt;code>system&lt;/code>文件夹全部复制到系统的&lt;code>/system&lt;/code>目录, &lt;code>unmount&lt;/code>取消挂载, 其他的例如&lt;code>ui_print&lt;/code>和&lt;code>show_progress&lt;/code>仅为提示作用, 修改完成后, 一个单刷包就制作完毕了, 可以像普通刷机一样直接刷进系统&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>由于安卓的开源特性使得安卓的可玩性和定制性非常高, 我所入手的每一部安卓手机都会进行ROOT并做一定程度的修改, 最开始的时候参考前辈的教程修改了系统APK的各种背景, 特效, 音效, 性能调优, 开机动画之类的, 随着手机UI越来越美观功能以及本人时间精力越来越有限, 现在对这种定制需要也已经越来越少了, 加之谷歌对安卓开源的策略调整以厂商的限制, 进行定制也越来越麻烦了, 但我仍会继续热爱安卓, 希望安卓开放的特性能够保持下去&lt;/p></description></item><item><title>某加APP破解去除认证和更新</title><link>/posts/hack/xplus/</link><pubDate>Thu, 10 Jun 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xplus/</guid><description>&lt;img src="/posts/hack/xplus/cover.png" alt="Featured image of post 某加APP破解去除认证和更新" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>由于某些需要, 进入某大楼的时候必须用他们物业指定的APP刷门禁, 我安装的时候是6.5.0版本, 这会儿启动速度也还可以, 也没太多花里胡哨的功能. 然而没过多久就迎来了一波强制版本更新, 更新后的版本启动速度慢到令人发指, 且增加了商城, 我就怒了, 区区门禁软件竟然这样肆意妄为, 开工!&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>去除更新检查, 去掉实名认证&lt;/p>
&lt;blockquote>
&lt;p>某加在7.0.0版本更名为某品, 破解版本为6.5.0, 在此保持称呼其为某加&lt;/p>
&lt;/blockquote>
&lt;h2 id="受害者版本">受害者版本&lt;/h2>
&lt;p>6.5.0&lt;/p>
&lt;p>&lt;figure style="flex-grow: 48; flex-basis: 116px">
&lt;a href="/posts/hack/xplus/1.jpg" data-size="428x879">&lt;img src="/posts/hack/xplus/1.jpg"
srcset="/posts/hack/xplus/1_hu2d95ec83e3d4d01752f97536c451549d_53428_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/1_hu2d95ec83e3d4d01752f97536c451549d_53428_1024x0_resize_q75_box.jpg 1024w"
width="428"
height="879"
loading="lazy"
alt="首页">
&lt;/a>
&lt;figcaption>首页&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先尝试使用Android反编译大杀器&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 打开&lt;code>Jadx&lt;/code>, 直接把某加安装包即&lt;code>.apk&lt;/code>文件拖进去, 发现软件没有加壳, 可以看到&lt;code>Jadx&lt;/code>顺利反编译出了某加的源码&lt;/p>
&lt;blockquote>
&lt;p>7.0版本开始APP加了壳, 没记错的话是某数字安全软件的壳, 脱壳过于麻烦于是使用6.5.0版本破解&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 146; flex-basis: 350px">
&lt;a href="/posts/hack/xplus/2.jpg" data-size="969x663">&lt;img src="/posts/hack/xplus/2.jpg"
srcset="/posts/hack/xplus/2_hu349652975c97a7c5fc2ef7ec56ba8aea_76881_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/2_hu349652975c97a7c5fc2ef7ec56ba8aea_76881_1024x0_resize_q75_box.jpg 1024w"
width="969"
height="663"
loading="lazy"
alt="JADX-源码">
&lt;/a>
&lt;figcaption>JADX-源码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;h2 id="禁用强制升级">禁用强制升级&lt;/h2>
&lt;p>首先根据弹窗文字&amp;quot;发现新版本&amp;quot;搜索代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 133; flex-basis: 320px">
&lt;a href="/posts/hack/xplus/3.jpg" data-size="516x387">&lt;img src="/posts/hack/xplus/3.jpg"
srcset="/posts/hack/xplus/3_huecfdf6804dc5656d1adc2869cf9b626f_14908_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/3_huecfdf6804dc5656d1adc2869cf9b626f_14908_1024x0_resize_q75_box.jpg 1024w"
width="516"
height="387"
loading="lazy"
alt="更新弹窗">
&lt;/a>
&lt;figcaption>更新弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现全文匹配的仅有一处, 位于布局文件&lt;code>dialog_check_update.xml&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 374; flex-basis: 897px">
&lt;a href="/posts/hack/xplus/4.jpg" data-size="606x162">&lt;img src="/posts/hack/xplus/4.jpg"
srcset="/posts/hack/xplus/4_hue4475e29c1a510e088031ebe8ac250a6_13878_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/4_hue4475e29c1a510e088031ebe8ac250a6_13878_1024x0_resize_q75_box.jpg 1024w"
width="606"
height="162"
loading="lazy"
alt="结果1">
&lt;/a>
&lt;figcaption>结果1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查找使用该布局文件的地方, 仅有一个类&lt;code>UpdateNoticeDialog&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 327; flex-basis: 786px">
&lt;a href="/posts/hack/xplus/5.jpg" data-size="845x258">&lt;img src="/posts/hack/xplus/5.jpg"
srcset="/posts/hack/xplus/5_hua4120d517d4567fa7454cfab4a402f5d_39648_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/5_hua4120d517d4567fa7454cfab4a402f5d_39648_1024x0_resize_q75_box.jpg 1024w"
width="845"
height="258"
loading="lazy"
alt="结果2">
&lt;/a>
&lt;figcaption>结果2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查看&lt;code>UpdateNoticeDialog&lt;/code>的代码, 可以看出这是一个自定义的对话框, 和APP显示的更新弹出框一致&lt;/p>
&lt;p>&lt;figure style="flex-grow: 264; flex-basis: 633px">
&lt;a href="/posts/hack/xplus/6.jpg" data-size="470x178">&lt;img src="/posts/hack/xplus/6.jpg"
srcset="/posts/hack/xplus/6_hue4b7d0705f3de3ef847d77bbc0819788_12612_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/6_hue4b7d0705f3de3ef847d77bbc0819788_12612_1024x0_resize_q75_box.jpg 1024w"
width="470"
height="178"
loading="lazy"
alt="结果3">
&lt;/a>
&lt;figcaption>结果3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接着查找使用到了&lt;code>UpdateNoticeDialog&lt;/code>类的地方, 发现多处引用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 236; flex-basis: 567px">
&lt;a href="/posts/hack/xplus/7.jpg" data-size="605x256">&lt;img src="/posts/hack/xplus/7.jpg"
srcset="/posts/hack/xplus/7_hu6e22dec133ef02ae33ed651f7531c52c_26368_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/7_hu6e22dec133ef02ae33ed651f7531c52c_26368_1024x0_resize_q75_box.jpg 1024w"
width="605"
height="256"
loading="lazy"
alt="结果4">
&lt;/a>
&lt;figcaption>结果4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>而APP弹出更新提示的时候, 我正位于APP的首页, 可以推断出&lt;code>HomeActivity&lt;/code>应该就是我要寻找的弹框处, 查看&lt;code>HomeActivity&lt;/code>的代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 108; flex-basis: 261px">
&lt;a href="/posts/hack/xplus/8.jpg" data-size="800x735">&lt;img src="/posts/hack/xplus/8.jpg"
srcset="/posts/hack/xplus/8_hu0d04ef7bf6568aeec0b7dc1a72e4ac07_78371_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/8_hu0d04ef7bf6568aeec0b7dc1a72e4ac07_78371_1024x0_resize_q75_box.jpg 1024w"
width="800"
height="735"
loading="lazy"
alt="首页">
&lt;/a>
&lt;figcaption>首页&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这里将&lt;code>UpdateNoticeDialog&lt;/code>定义为成员变量, 然后在&lt;code>checkUpdate&lt;/code>中对&lt;code>UpdateNoticeDialog&lt;/code>赋值, 且其他操作都位于&lt;code>checkUpdate&lt;/code>中, 现在看看&lt;code>checkUpdate&lt;/code>完整代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 140; flex-basis: 338px">
&lt;a href="/posts/hack/xplus/9.jpg" data-size="710x504">&lt;img src="/posts/hack/xplus/9.jpg"
srcset="/posts/hack/xplus/9_hu0a58a8411c4b0c4596961a24b6ef84f2_53536_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/9_hu0a58a8411c4b0c4596961a24b6ef84f2_53536_1024x0_resize_q75_box.jpg 1024w"
width="710"
height="504"
loading="lazy"
alt="检查更新">
&lt;/a>
&lt;figcaption>检查更新&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这个方法并没有做除了更新检查以外的事, 那么我只需要在&lt;code>Xposed&lt;/code>中替换这个方法就可以了, 这样当APP调用&lt;code>checkUpdate&lt;/code>时, 将执行我定义的方法, &lt;code>Xposed&lt;/code>模块代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.马赛克.马赛克.home.HomeActivity&amp;quot;, loadPackageParam.classLoader,
&amp;quot;checkUpdate&amp;quot;,
new XC_MethodReplacement() {
@Override
protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
return null;
}
});
&lt;/code>&lt;/pre>&lt;p>这里直接使用&lt;code>replaceHookedMethod&lt;/code>, 用自己定义的方法代替&lt;code>checkUpdate&lt;/code>执行, &lt;strong>写好后重新运行可以发现首页更新弹窗已经被屏蔽了.&lt;/strong>&lt;/p>
&lt;p>然而后来手贱不小心退出登录了, 再启动APP时发现登录的时候也有更新认证, 现在可行的方法有二, 一是找到登录界面, 用同样的方法去除更新, 但是这样一来繁琐, 二来他可能还有其他的地方有更新检查, 所以使用第二种方法&lt;/p>
&lt;p>根据Android开发文档可以得知, &lt;strong>可以在APP的&lt;code>AndroidManifest.xml&lt;/code>中可以定义当前APP的版本号, 然后可以在&lt;code>Java&lt;/code>代码中使用&lt;code>PackageInfo&lt;/code>来获得当前APP的版本信息, 而定义版本主要分为版本号&lt;code>versionCode&lt;/code>和版本名&lt;code>versionName&lt;/code>, 一般使用&lt;code>versionCode&lt;/code>大小来判断是否需要更新, 而&lt;code>versionName&lt;/code>则主要用作展示&lt;/strong>, 查看某加APP的&lt;code>AndroidManifest.xml&lt;/code>文件, 发现其版本定义如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 451; flex-basis: 1082px">
&lt;a href="/posts/hack/xplus/10.jpg" data-size="546x121">&lt;img src="/posts/hack/xplus/10.jpg"
srcset="/posts/hack/xplus/10_hu96277694f98aa3c45610a16b3673614a_9450_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/10_hu96277694f98aa3c45610a16b3673614a_9450_1024x0_resize_q75_box.jpg 1024w"
width="546"
height="121"
loading="lazy"
alt="版本">
&lt;/a>
&lt;figcaption>版本&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>那么一般的做法只要将&lt;code>versionCode&lt;/code>的值修改成足够大, 就能达到免更新的目的, 但是实际操作下来发现这APP比较鸡贼, 判断版本是否更新并不是简单通过&lt;code>versionCode&lt;/code>大小来判断, 不过当时为了偷懒也没有进一步分析版本检查代码, 我只知道最新版本的&lt;code>versionName&lt;/code>是7.0.0, 所以直接使用&lt;code>Xposed&lt;/code>将返回的&lt;code>versionName&lt;/code>修改为固定的7.0.0&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;android.app.ApplicationPackageManager&amp;quot;, loadPackageParam.classLoader,
&amp;quot;getPackageInfo&amp;quot;,
String.class,
int.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
PackageInfo packageInfo = (PackageInfo) param.getResult();
if (null != packageInfo &amp;amp;&amp;amp; getTargetPackage().equals(packageInfo.packageName)) {
packageInfo.versionCode = Integer.MAX_VALUE;
packageInfo.versionName = &amp;quot;7.0.0&amp;quot;;
}
}
});
&lt;/code>&lt;/pre>&lt;p>此处使用&lt;code>Xposed&lt;/code>直接拦截Android系统的包管理器, 当某加需要获取版本名时, 直接返回7.0.0, 不过这样做的缺点是如果某加未来版本更新到7.0.0以上时, 需要修改代码, 然而从2020年12月破解至今, 某加都没有再发布过版本更新, 省了我不少事&lt;/p>
&lt;p>&lt;strong>至此重新打包运行, 发现登录的更新检查也被去除了&lt;/strong>&lt;/p>
&lt;p>然而新的风暴又出现了, 由于刚才的不慎退出, 现在需要重新上传实名认证资料了, 包括身份证号和照片, 由于我之前已经填过一次, 而且上传后需要重新审核, 所以不愿意再次填写, 于是开始寻找认证部分的代码&lt;/p>
&lt;h2 id="跳过实名认证">跳过实名认证&lt;/h2>
&lt;p>认证弹窗如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 136px">
&lt;a href="/posts/hack/xplus/11.jpg" data-size="530x931">&lt;img src="/posts/hack/xplus/11.jpg"
srcset="/posts/hack/xplus/11_hu96f99dea830a15ed6bd30d3c0d69bfe0_47957_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/11_hu96f99dea830a15ed6bd30d3c0d69bfe0_47957_1024x0_resize_q75_box.jpg 1024w"
width="530"
height="931"
loading="lazy"
alt="实名认证弹窗">
&lt;/a>
&lt;figcaption>实名认证弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>当我点击右下角的显示门禁卡二维码按钮的时候, 就会弹出认证弹窗, 我们知道&lt;code>Activity&lt;/code>会通过&lt;code>setContentView&lt;/code>加载一个布局文件, 此页面为APP首页, 所以在&lt;code>HomeActivity&lt;/code>中搜索&lt;code>setContentView&lt;/code>, 发现并没有结果&lt;/p>
&lt;p>&lt;figure style="flex-grow: 318; flex-basis: 765px">
&lt;a href="/posts/hack/xplus/12.jpg" data-size="679x213">&lt;img src="/posts/hack/xplus/12.jpg"
srcset="/posts/hack/xplus/12_hu82614e200c2ca9e6d3cff5f090370c74_23860_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/12_hu82614e200c2ca9e6d3cff5f090370c74_23860_1024x0_resize_q75_box.jpg 1024w"
width="679"
height="213"
loading="lazy"
alt="首页2">
&lt;/a>
&lt;figcaption>首页2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是&lt;code>HomeActivity&lt;/code>继承自&lt;code>BaseActivity_2019_8_22&lt;/code>, 于是在父类中找到了&lt;code>setContentView&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 251; flex-basis: 602px">
&lt;a href="/posts/hack/xplus/13.jpg" data-size="663x264">&lt;img src="/posts/hack/xplus/13.jpg"
srcset="/posts/hack/xplus/13_huc3f0c228985f9b08ea6c4fb72996e418_31164_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/13_huc3f0c228985f9b08ea6c4fb72996e418_31164_1024x0_resize_q75_box.jpg 1024w"
width="663"
height="264"
loading="lazy"
alt="设置布局">
&lt;/a>
&lt;figcaption>设置布局&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这里加载的布局是&lt;code>activity_only_linear_layout.xml&lt;/code>, 查看这个布局文件, 里面的代码非常简单&lt;/p>
&lt;p>&lt;figure style="flex-grow: 332; flex-basis: 798px">
&lt;a href="/posts/hack/xplus/14.jpg" data-size="892x268">&lt;img src="/posts/hack/xplus/14.jpg"
srcset="/posts/hack/xplus/14_hu18df4b0c8e4b20856bb7a5a1a40ccba6_38292_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/14_hu18df4b0c8e4b20856bb7a5a1a40ccba6_38292_1024x0_resize_q75_box.jpg 1024w"
width="892"
height="268"
loading="lazy"
alt="布局">
&lt;/a>
&lt;figcaption>布局&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>根据名称可以很容易的推断出id为&lt;code>fab_show_qr_code&lt;/code>的按钮组件就是首页显示二维码的组件, 搜索这个id查看他的点击事件&lt;/p>
&lt;p>&lt;figure style="flex-grow: 143; flex-basis: 344px">
&lt;a href="/posts/hack/xplus/15.jpg" data-size="724x504">&lt;img src="/posts/hack/xplus/15.jpg"
srcset="/posts/hack/xplus/15_hub70308bebefecd263604d35c1664b3cc_48846_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/15_hub70308bebefecd263604d35c1664b3cc_48846_1024x0_resize_q75_box.jpg 1024w"
width="724"
height="504"
loading="lazy"
alt="点击事件">
&lt;/a>
&lt;figcaption>点击事件&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>根据判断逻辑, 如果&lt;code>CacheUtils.getStatus()&lt;/code>返回为1, 就展示二维码弹窗, 不为1则执行&lt;code>checkStatus()&lt;/code>, 以防万一, 看看&lt;code>checkStatus()&lt;/code>的代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 390; flex-basis: 936px">
&lt;a href="/posts/hack/xplus/16.jpg" data-size="730x187">&lt;img src="/posts/hack/xplus/16.jpg"
srcset="/posts/hack/xplus/16_hu30e72add66bab6b7193b471be38a9d9a_17295_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/16_hu30e72add66bab6b7193b471be38a9d9a_17295_1024x0_resize_q75_box.jpg 1024w"
width="730"
height="187"
loading="lazy"
alt="检查状态">
&lt;/a>
&lt;figcaption>检查状态&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>显然&lt;code>checkIdentityStatus()&lt;/code>这名字就很直白的告诉我这个就是用来检查身份认证的了, 在回来看看&lt;code>CacheUtils.getStatus()&lt;/code>代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 294; flex-basis: 706px">
&lt;a href="/posts/hack/xplus/17.jpg" data-size="645x219">&lt;img src="/posts/hack/xplus/17.jpg"
srcset="/posts/hack/xplus/17_hub29dfd1774778c08e0d4594a749914d2_20243_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/17_hub29dfd1774778c08e0d4594a749914d2_20243_1024x0_resize_q75_box.jpg 1024w"
width="645"
height="219"
loading="lazy"
alt="获取状态">
&lt;/a>
&lt;figcaption>获取状态&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这里的逻辑也很简单, 就是从登录信息中获取认证状态, 那么我只要用&lt;code>Xposed&lt;/code>将&lt;code>getStatus()&lt;/code>的返回值修改为1就可以了, &lt;code>Xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.excegroup.community.utils.CacheUtils&amp;quot;, loadPackageParam.classLoader, &amp;quot;getStatus&amp;quot;,
String.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
param.setResult(&amp;quot;1&amp;quot;);
}
});
&lt;/code>&lt;/pre>&lt;p>拦截代码将在&lt;code>getStatus()&lt;/code>执行之后执行, 将其返回值为修改为1, 现在重新运行, &lt;strong>程序一切正常, 也没有身份认证弹窗了, 点击显示二维码按钮正常显示门禁二维码&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 64; flex-basis: 155px">
&lt;a href="/posts/hack/xplus/18.jpg" data-size="524x811">&lt;img src="/posts/hack/xplus/18.jpg"
srcset="/posts/hack/xplus/18_hu8be23d8c5d36ba9786790ce525914933_44600_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/18_hu8be23d8c5d36ba9786790ce525914933_44600_1024x0_resize_q75_box.jpg 1024w"
width="524"
height="811"
loading="lazy"
alt="ok">
&lt;/a>
&lt;figcaption>ok&lt;/figcaption>
&lt;/figure>&lt;/p></description></item><item><title>某鱼APP破解去广告</title><link>/posts/hack/xfish/</link><pubDate>Tue, 08 Jun 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xfish/</guid><description>&lt;img src="/posts/hack/xfish/cover.png" alt="Featured image of post 某鱼APP破解去广告" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>作为一个家徒四壁的打工人, 在某鱼上购买二手的闲置商品便成了我实现梦想的捷径, 但某鱼经过多次升级改版已经相当流氓, 在我搜索出想要的商品的结果页, 嵌入识别度很低的广告, 导致我经常手滑点错, 然后直接跳转启动某宝, 某宝的启动速度又慢的令人发指, 最终还得按下多次返回才能再次回到某鱼的搜索结果页, 忍无可忍的我只能对它做一些不可描述的事了&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>去除搜索结果页的广告, 同时去掉每次启动就弹窗的恼人的更新提示&lt;/p>
&lt;h2 id="受害者版本">受害者版本&lt;/h2>
&lt;p>6.7.40&lt;/p>
&lt;h2 id="某鱼的搜索结果页">某鱼的搜索结果页&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 134px">
&lt;a href="/posts/hack/xfish/adpage.jpg" data-size="540x961">&lt;img src="/posts/hack/xfish/adpage.jpg"
srcset="/posts/hack/xfish/adpage_hu1ba7e09bc24973772dcedd1129f840e8_86307_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/adpage_hu1ba7e09bc24973772dcedd1129f840e8_86307_1024x0_resize_q75_box.jpg 1024w"
width="540"
height="961"
loading="lazy"
alt="某鱼广告">
&lt;/a>
&lt;figcaption>某鱼广告&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>PS:一个屏幕总共就6个展位, 某鱼你这三个广告位良心不会痛吗&lt;/p>
&lt;/blockquote>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先尝试使用Android反编译大杀器&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 打开&lt;code>Jadx&lt;/code>, 直接把某鱼安装包即&lt;code>.apk&lt;/code>文件拖进去, 发现软件没有加壳, 可以看到&lt;code>Jadx&lt;/code>顺利反编译出了某鱼的源码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 139; flex-basis: 334px">
&lt;a href="/posts/hack/xfish/jadx_source.jpg" data-size="1173x842">&lt;img src="/posts/hack/xfish/jadx_source.jpg"
srcset="/posts/hack/xfish/jadx_source_hud0af3715194ff4882a261e5347d833be_127929_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/jadx_source_hud0af3715194ff4882a261e5347d833be_127929_1024x0_resize_q75_box.jpg 1024w"
width="1173"
height="842"
loading="lazy"
alt="JADX-源码">
&lt;/a>
&lt;figcaption>JADX-源码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;p>&lt;strong>首先从输入搜索目标后, 点击搜索的按钮开始入手&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 249; flex-basis: 599px">
&lt;a href="/posts/hack/xfish/search.jpg" data-size="537x215">&lt;img src="/posts/hack/xfish/search.jpg"
srcset="/posts/hack/xfish/search_hubb017e4f37f205bfbcd52d21910b75ab_11320_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/search_hubb017e4f37f205bfbcd52d21910b75ab_11320_1024x0_resize_q75_box.jpg 1024w"
width="537"
height="215"
loading="lazy"
alt="搜索面板">
&lt;/a>
&lt;figcaption>搜索面板&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>在代码中查找&amp;quot;搜索&amp;quot;关键字, 发现有多处匹配, 结合搜索面板底下的历史搜索布局, 推测该面板的布局文件应该是&lt;code>search_mid.xml&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 212; flex-basis: 510px">
&lt;a href="/posts/hack/xfish/searchlayout.jpg" data-size="1078x507">&lt;img src="/posts/hack/xfish/searchlayout.jpg"
srcset="/posts/hack/xfish/searchlayout_hu165f087e67dd8c3f20528ecb83d1223f_83048_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchlayout_hu165f087e67dd8c3f20528ecb83d1223f_83048_1024x0_resize_q75_box.jpg 1024w"
width="1078"
height="507"
loading="lazy"
alt="面板代码">
&lt;/a>
&lt;figcaption>面板代码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>搜索布局文件引用的地方, 发现其在&lt;code>SearchMidActivity&lt;/code>中被使用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 342; flex-basis: 821px">
&lt;a href="/posts/hack/xfish/uselayout.jpg" data-size="606x177">&lt;img src="/posts/hack/xfish/uselayout.jpg"
srcset="/posts/hack/xfish/uselayout_huf0a2434a3d7d0179055128c7c7a27089_13700_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/uselayout_huf0a2434a3d7d0179055128c7c7a27089_13700_1024x0_resize_q75_box.jpg 1024w"
width="606"
height="177"
loading="lazy"
alt="布局使用">
&lt;/a>
&lt;figcaption>布局使用&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再查看布局文件代码, 搜索按钮的组件ID为&lt;code>search_button&lt;/code>, 在&lt;code>SearchMidActivity&lt;/code>中查找相关引用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 316; flex-basis: 758px">
&lt;a href="/posts/hack/xfish/searchbtn1.jpg" data-size="351x111">&lt;img src="/posts/hack/xfish/searchbtn1.jpg"
srcset="/posts/hack/xfish/searchbtn1_hud7caf3cc5e731a5a19c2db74ba6f7cd8_6010_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn1_hud7caf3cc5e731a5a19c2db74ba6f7cd8_6010_1024x0_resize_q75_box.jpg 1024w"
width="351"
height="111"
loading="lazy"
alt="搜索点击1">
&lt;/a>
&lt;figcaption>搜索点击1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 277; flex-basis: 667px">
&lt;a href="/posts/hack/xfish/searchbtn2.jpg" data-size="795x286">&lt;img src="/posts/hack/xfish/searchbtn2.jpg"
srcset="/posts/hack/xfish/searchbtn2_hu43e90636119c85769bcd2cb8b226da7a_24664_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn2_hu43e90636119c85769bcd2cb8b226da7a_24664_1024x0_resize_q75_box.jpg 1024w"
width="795"
height="286"
loading="lazy"
alt="搜索点击2">
&lt;/a>
&lt;figcaption>搜索点击2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出按钮点击后, 首先会调用&lt;code>searchKeyAction&lt;/code>, 再经过层层调用最后到达&lt;code>searchNormal&lt;/code>, 之后就会通过 &lt;code>gotoResultActivity&lt;/code> 跳转到结果页, 继续跟踪&lt;code>gotoResultActivity&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 700; flex-basis: 1680px">
&lt;a href="/posts/hack/xfish/searchbtn3.jpg" data-size="525x75">&lt;img src="/posts/hack/xfish/searchbtn3.jpg"
srcset="/posts/hack/xfish/searchbtn3_hu5fb2147c87591b6c85c08e2046a0c2df_6451_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn3_hu5fb2147c87591b6c85c08e2046a0c2df_6451_1024x0_resize_q75_box.jpg 1024w"
width="525"
height="75"
loading="lazy"
alt="搜索点击3">
&lt;/a>
&lt;figcaption>搜索点击3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>此处出现&lt;code>searchresult&lt;/code>字符, 搜索这个字符&lt;/p>
&lt;p>&lt;figure style="flex-grow: 469; flex-basis: 1127px">
&lt;a href="/posts/hack/xfish/searchbtn4.jpg" data-size="780x166">&lt;img src="/posts/hack/xfish/searchbtn4.jpg"
srcset="/posts/hack/xfish/searchbtn4_hu3064fae03e259149ff91124b7637e5f8_29435_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn4_hu3064fae03e259149ff91124b7637e5f8_29435_1024x0_resize_q75_box.jpg 1024w"
width="780"
height="166"
loading="lazy"
alt="搜索点击4">
&lt;/a>
&lt;figcaption>搜索点击4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出这个字符串对应的页面应该是 &lt;code>SearchResultActivity&lt;/code>, 打开这个类之后一眼看不出什么重要的东西, 然后线索就这么中断了&lt;/p>
&lt;p>线索中断之后, 可以用&lt;code>Xposed&lt;/code>拦截某些可疑方法, 然后通过打印调用堆栈的方法, 继续分析, 比如此我找到的&lt;code>SearchResultInterrupter&lt;/code>中的&lt;code>checkInterrupt&lt;/code>方法&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Xposed&lt;/code>是一款&lt;code>Android&lt;/code>底层的框架, 能够从虚拟机层拦截系统所有执行代码, 而&lt;code>Xposed&lt;/code>模块是使用&lt;code>Xposed&lt;/code>提供的&lt;code>SDK&lt;/code>所开发的&lt;code>Android&lt;/code>应用, 能够借助&lt;code>Xposed&lt;/code>实现对所有关心代码的拦截, 详情请戳&lt;a class="link" href="https://repo.xposed.info/" target="_blank" rel="noopener"
>Xposed官网&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>Throwable ex = new Throwable();
StackTraceElement[] stackElements = ex.getStackTrace();
if (stackElements != null) {
for (int i = 0; i &amp;lt; stackElements.length; i++) {
MyLog.log(stackElements[i].getClassName() + &amp;quot; -&amp;gt; &amp;quot; +
stackElements[i].getMethodName() + &amp;quot;()&amp;quot;
, true);
}
}
&lt;/code>&lt;/pre>&lt;p>不过这样比较麻烦而且也不好找. 于是换个思路, 安装&lt;code>Xposed&lt;/code>模块&lt;a class="link" href="https://github.com/Palatis/XAppDebug" target="_blank" rel="noopener"
>XAppDebug&lt;/a>, 为某鱼强制开启&lt;code>Debug&lt;/code>模式, 此时查看控制台会显示所有某鱼打印的日志信息, 现在控制台显示了包括网络请求在内的日志信息&lt;/p>
&lt;p>&lt;figure style="flex-grow: 379; flex-basis: 911px">
&lt;a href="/posts/hack/xfish/motp.jpg" data-size="1136x299">&lt;img src="/posts/hack/xfish/motp.jpg"
srcset="/posts/hack/xfish/motp_hu728bdb3602c9c0a190a3b046fde1f8dd_69023_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/motp_hu728bdb3602c9c0a190a3b046fde1f8dd_69023_1024x0_resize_q75_box.jpg 1024w"
width="1136"
height="299"
loading="lazy"
alt="MTOP">
&lt;/a>
&lt;figcaption>MTOP&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>最终找到可疑类&lt;code>MtopResponse&lt;/code>, 分析代码可以推测这个类应该是一个封装了网络响应的类, 其成员变量&lt;code>bytedata&lt;/code>是主要数据源, &lt;code>bytedata&lt;/code>将会被转换成&lt;code>dataJsonObject&lt;/code>的&lt;code>JSON&lt;/code>对象储存, 然后被使用, 因此找到&lt;code>bytedata&lt;/code>赋值的方法&lt;code>setBytedata&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 287; flex-basis: 691px">
&lt;a href="/posts/hack/xfish/rep.jpg" data-size="478x166">&lt;img src="/posts/hack/xfish/rep.jpg"
srcset="/posts/hack/xfish/rep_huaa9da268be2d331c855d2c964a90ed3f_10820_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/rep_huaa9da268be2d331c855d2c964a90ed3f_10820_1024x0_resize_q75_box.jpg 1024w"
width="478"
height="166"
loading="lazy"
alt="响应模型">
&lt;/a>
&lt;figcaption>响应模型&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>破解时间于2020年8月, 文章编辑时间为2021年6月, 我也不记得当初是不是这样找到&lt;code>MtopResponse&lt;/code>类的, 没有记录下来是我的失误也是我的损失, 现在能找到这个类是因为当时开发&lt;code>Xposed&lt;/code>模块中的代码有这一段. 如果某天我突然想起来了或者有兴致花时间重新找的话, 会回来补充的&lt;/p>
&lt;/blockquote>
&lt;p>使用&lt;code>Xposed&lt;/code>拦截此函数, 并打印入参&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;mtopsdk.mtop.domain.MtopResponse&amp;quot;, loadPackageParam.classLoader,
&amp;quot;setBytedata&amp;quot;,
byte[].class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
String content = new String((byte[]) param.args[0]);
MyLog.log(content);
}
});
&lt;/code>&lt;/pre>&lt;p>得到入参截取如下&lt;/p>
&lt;pre>&lt;code>&amp;quot;data&amp;quot;: {
&amp;quot;item&amp;quot;: {
...
&amp;quot;main&amp;quot;: {
&amp;quot;clickParam&amp;quot;: {
&amp;quot;arg1&amp;quot;: &amp;quot;Item&amp;quot;,
&amp;quot;args&amp;quot;: {
...
&amp;quot;tagname&amp;quot;: &amp;quot;全新\/极好\/298人想要&amp;quot;,
&amp;quot;wantNum&amp;quot;: &amp;quot;298&amp;quot;,
&amp;quot;id&amp;quot;: &amp;quot;619312410203&amp;quot;,
&amp;quot;tag&amp;quot;: &amp;quot;new\/credit-6\/wantnum-298&amp;quot;,
&amp;quot;scm&amp;quot;: &amp;quot;1007.32845.224895.0&amp;quot;,
&amp;quot;publishTime&amp;quot;: &amp;quot;1590461455000&amp;quot;,
&amp;quot;i2i&amp;quot;: &amp;quot;相似&amp;quot;,
&amp;quot;search_tab_from&amp;quot;: null,
&amp;quot;item_id&amp;quot;: &amp;quot;619312410203&amp;quot;,
&amp;quot;biz_type&amp;quot;: &amp;quot;item&amp;quot;, //破解重点
&amp;quot;q&amp;quot;: &amp;quot;10700k&amp;quot;,
...
},
&amp;quot;page&amp;quot;: &amp;quot;Page_xySearchResult&amp;quot;
},
...
}
}
...
}
...
&lt;/code>&lt;/pre>&lt;p>此处截取了一条记录展示, 实际拦截到的参数中是一个数组, 包含本次结果页的所有商品, 其中就包括了搜索的商品, 广告商品, 推荐商品等, 通过对比发现, &lt;strong>搜索的商品数据在节点&lt;code>args&lt;/code> &amp;gt; &lt;code>biz_type&lt;/code> 的取值为 &lt;code>item&lt;/code>, 而广告等商品取值为&lt;code>ad&lt;/code>, &lt;code>Bagtag&lt;/code>, &lt;code>聚合卡片&lt;/code>&lt;/strong>, 那么接下来要做的事就很明确了, &lt;strong>解析这个字符串, 如果发现是广告商品则从数据中删除这条数据&lt;/strong>, 修改对&lt;code>setBytedate&lt;/code>的拦截代码如下&lt;/p>
&lt;pre>&lt;code>...
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
if (null == param.args[0] || ((byte[]) param.args[0]).length == 0) {
return;
}
String content = new String((byte[]) param.args[0]);
JSONObject jsonContent = new JSONObject(content);
JSONObject jsonData = jsonContent.optJSONObject(&amp;quot;data&amp;quot;);
if (null == jsonData || !jsonData.has(&amp;quot;resultList&amp;quot;)) {
return;
}
JSONArray resultList = jsonData.getJSONArray(&amp;quot;resultList&amp;quot;);
List&amp;lt;String&amp;gt; filterList = Arrays.asList(&amp;quot;ad&amp;quot;, &amp;quot;Bagtag&amp;quot;, &amp;quot;聚合卡片&amp;quot;);
for (int i = 0; i &amp;lt; resultList.length(); i++) {
JSONObject listItem = resultList.getJSONObject(i);
String bizType = listItem.getJSONObject(&amp;quot;data&amp;quot;).getJSONObject(&amp;quot;item&amp;quot;)
.getJSONObject(&amp;quot;main&amp;quot;).getJSONObject(&amp;quot;clickParam&amp;quot;).getJSONObject(&amp;quot;args&amp;quot;)
.getString(&amp;quot;biz_type&amp;quot;);
if (filterList.contains(bizType)) {
if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.KITKAT) {
resultList.remove(i);
i--;
}
}
}
param.args[0] = jsonContent.toString().getBytes();
}
...
&lt;/code>&lt;/pre>&lt;p>上述代码首先将&lt;code>byte&lt;/code>数组转换为&lt;code>json&lt;/code>对象, 然后遍历所有商品, 将找到的广告商品移除, 再将处理过后的字符串重新转换为&lt;code>byte&lt;/code>数组, 最后赋值给原始参数, 这样当某鱼实际代码&lt;code>setBytedata&lt;/code>得到的参数将会是我修改后的参数. 编译验证后可以看到广告已经不会再显示了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 136px">
&lt;a href="/posts/hack/xfish/noadresult.jpg" data-size="529x933">&lt;img src="/posts/hack/xfish/noadresult.jpg"
srcset="/posts/hack/xfish/noadresult_hufb7fc091ad8dd52f3bb83e2bc584be96_75816_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/noadresult_hufb7fc091ad8dd52f3bb83e2bc584be96_75816_1024x0_resize_q75_box.jpg 1024w"
width="529"
height="933"
loading="lazy"
alt="哇塞">
&lt;/a>
&lt;figcaption>哇塞&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="禁用恼人的升级弹窗">禁用恼人的升级弹窗&lt;/h2>
&lt;p>&lt;strong>由于本人不爱更新, 且破解后如果更新版本, 可能导致破解失效, 所以必须禁用更新&lt;/strong>&lt;/p>
&lt;p>首先根据弹窗文字搜索代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 309px">
&lt;a href="/posts/hack/xfish/updateprop.jpg" data-size="487x378">&lt;img src="/posts/hack/xfish/updateprop.jpg"
srcset="/posts/hack/xfish/updateprop_huc83cba95d5fbda156357bc25e87590dc_41270_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updateprop_huc83cba95d5fbda156357bc25e87590dc_41270_1024x0_resize_q75_box.jpg 1024w"
width="487"
height="378"
loading="lazy"
alt="更新弹窗">
&lt;/a>
&lt;figcaption>更新弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现仅有一处, 位于&lt;code>BaseUpgradeHandler&lt;/code>类的&lt;code>onUpgradeNeed()&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 136; flex-basis: 327px">
&lt;a href="/posts/hack/xfish/updatecode.jpg" data-size="609x446">&lt;img src="/posts/hack/xfish/updatecode.jpg"
srcset="/posts/hack/xfish/updatecode_hue08c2e2c8268d22c9b70d5b029bd39b2_29411_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecode_hue08c2e2c8268d22c9b70d5b029bd39b2_29411_1024x0_resize_q75_box.jpg 1024w"
width="609"
height="446"
loading="lazy"
alt="更新代码">
&lt;/a>
&lt;figcaption>更新代码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>跟踪方法调用, 在&lt;code>com.马赛克.马赛克fish.upgrade.traceable.Upgrade&lt;/code>类的&lt;code>c&lt;/code>方法中被调用, 而&lt;code>c&lt;/code>则被&lt;code>b&lt;/code>调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 189; flex-basis: 454px">
&lt;a href="/posts/hack/xfish/updatecall1.jpg" data-size="705x372">&lt;img src="/posts/hack/xfish/updatecall1.jpg"
srcset="/posts/hack/xfish/updatecall1_hu44c789f25140b4297b45caa6517061ba_31907_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecall1_hu44c789f25140b4297b45caa6517061ba_31907_1024x0_resize_q75_box.jpg 1024w"
width="705"
height="372"
loading="lazy"
alt="更新1">
&lt;/a>
&lt;figcaption>更新1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 290; flex-basis: 696px">
&lt;a href="/posts/hack/xfish/updatecall2.jpg" data-size="708x244">&lt;img src="/posts/hack/xfish/updatecall2.jpg"
srcset="/posts/hack/xfish/updatecall2_hu8b4e53f6efc16eee43e3c0879d76ef38_23057_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecall2_hu8b4e53f6efc16eee43e3c0879d76ef38_23057_1024x0_resize_q75_box.jpg 1024w"
width="708"
height="244"
loading="lazy"
alt="更新2">
&lt;/a>
&lt;figcaption>更新2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>重点代码摘要如下:&lt;/p>
&lt;pre>&lt;code>private void c(final UpgradeHandler handler) {
if (handler != null) {
...
handler.onUpgradeNeed(info, tracer);
...
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>c&lt;/code>中的代码的突破点在于, &lt;strong>如果传入的&lt;code>handler&lt;/code>不为&lt;code>null&lt;/code>, 才会执行更新检测并弹窗的方法&lt;/strong>, 那么我只需要让传入的&lt;code>handler&lt;/code>为&lt;code>null&lt;/code>就可以了. 在&lt;code>Xposed&lt;/code>模块中拦截&lt;code>Upgrade&lt;/code>类的&lt;code>b&lt;/code>方法, 将入参设置为&lt;code>null&lt;/code>&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.马赛克.马赛克fish.upgrade.traceable.Upgrade&amp;quot;,loadPackageParam.classLoader,
&amp;quot;b&amp;quot;,
&amp;quot;com.马赛克.马赛克fish.upgrade.traceable.UpgradeHandler&amp;quot;,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
//这里将入参设置为null
param.args[0] = null;
}
}
);
&lt;/code>&lt;/pre>&lt;p>重新进行测试, &lt;strong>一切正常且启动之后不再有更新弹窗了&lt;/strong>&lt;/p></description></item><item><title>某琴吧EXE播放器破解记录</title><link>/posts/hack/xtan/exe/</link><pubDate>Wed, 26 May 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xtan/exe/</guid><description>&lt;img src="/posts/hack/xtan/exe/cover.png" alt="Featured image of post 某琴吧EXE播放器破解记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>本文接另一篇文章 &lt;a class="link" href="../flash" >某琴吧Flash播放器破解记录&lt;/a>&lt;/p>
&lt;p>由于某琴吧改版正式使用exe播放器之后, 删除了所有的&lt;code>.ypa2&lt;/code>资源, 导致我没有及时下载的乐谱都无法继续使用Flash播放器播放了, 忍不了, 只能破解exe播放器了&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解该站的exe播放器, 使其能够免费播放VIP乐谱, 且可以完全脱机使用&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先安装网站的乐谱播放器, 打开安装目录发现文件结构如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 78; flex-basis: 188px">
&lt;a href="/posts/hack/xtan/exe/3.jpg" data-size="246x313">&lt;img src="/posts/hack/xtan/exe/3.jpg"
srcset="/posts/hack/xtan/exe/3_hue232319cf432e7036953df257266796c_12330_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/3_hue232319cf432e7036953df257266796c_12330_1024x0_resize_q75_box.jpg 1024w"
width="246"
height="313"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>xxxchrome.exe&lt;/code>相当于一个浏览器, 可以访问某琴吧, 点击&amp;quot;客户端播放&amp;quot;按钮即可打开播放器, 如下图&lt;/p>
&lt;p>&lt;figure style="flex-grow: 151; flex-basis: 363px">
&lt;a href="/posts/hack/xtan/exe/2.jpg" data-size="1116x736">&lt;img src="/posts/hack/xtan/exe/2.jpg"
srcset="/posts/hack/xtan/exe/2_hu497f65295a89ad86247035b74338bec2_76064_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/2_hu497f65295a89ad86247035b74338bec2_76064_1024x0_resize_q75_box.jpg 1024w"
width="1116"
height="736"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>而&lt;code>xxplayer.exe&lt;/code>才是播放器, 播放器启动后, 可以从任务管理器看到新增的进程&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 307px">
&lt;a href="/posts/hack/xtan/exe/1.jpg" data-size="926x722">&lt;img src="/posts/hack/xtan/exe/1.jpg"
srcset="/posts/hack/xtan/exe/1_hud35c019f213a619ddd7799f1e0fa3f93_112502_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/1_hud35c019f213a619ddd7799f1e0fa3f93_112502_1024x0_resize_q75_box.jpg 1024w"
width="926"
height="722"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>剩下的安装文件和库文件还有配置文件, 就不介绍了.&lt;/p>
&lt;p>首先播放一个免费的乐谱, 在任务管理器中查看一下&lt;code>xxplayer.exe&lt;/code>的启动参数&lt;/p>
&lt;p>&lt;figure style="flex-grow: 610; flex-basis: 1464px">
&lt;a href="/posts/hack/xtan/exe/4.jpg" data-size="946x155">&lt;img src="/posts/hack/xtan/exe/4.jpg"
srcset="/posts/hack/xtan/exe/4_hub8c1251db8423eeb57a6a376306d634c_30464_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/4_hub8c1251db8423eeb57a6a376306d634c_30464_1024x0_resize_q75_box.jpg 1024w"
width="946"
height="155"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>完整的启动参数如下&lt;/p>
&lt;pre>&lt;code>&amp;quot;C:\Program Files\马赛克music\out1\马赛克player.exe&amp;quot; &amp;quot;file=http://www.马赛克.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981&amp;quot;
&lt;/code>&lt;/pre>&lt;p>可以看到启动参数主要为&lt;/p>
&lt;ul>
&lt;li>&lt;code>file&lt;/code> 官网的乐谱页地址&lt;/li>
&lt;li>&lt;code>ypid&lt;/code> 乐谱ID&lt;/li>
&lt;li>&lt;code>uid&lt;/code> 用户ID&lt;/li>
&lt;li>&lt;code>token&lt;/code> 凭证&lt;/li>
&lt;/ul>
&lt;p>如果从&lt;code>xxxchrome.exe&lt;/code>打开一个VIP乐谱, 则会显示&lt;/p>
&lt;p>&lt;figure style="flex-grow: 103; flex-basis: 249px">
&lt;a href="/posts/hack/xtan/exe/5.jpg" data-size="441x425">&lt;img src="/posts/hack/xtan/exe/5.jpg"
srcset="/posts/hack/xtan/exe/5_hua261adef9b482683046becfc9484b40d_36483_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/5_hua261adef9b482683046becfc9484b40d_36483_1024x0_resize_q75_box.jpg 1024w"
width="441"
height="425"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>那么如果我不用他的&lt;code>xxxchrome.exe&lt;/code>, 直接从命令行启动&lt;code>xxplayer.exe&lt;/code>, 传入一个VIP乐谱ID, 会发生什么呢?&lt;/p>
&lt;p>将刚才的启动参数中的&lt;code>ypid&lt;/code>参数修改为一个VIP乐谱ID, 通过命令行&lt;/p>
&lt;pre>&lt;code>xxplayer.exe &amp;quot;file=http://www.马赛克.com/open_yp.php?ypid=33418&amp;amp;uid=999999999&amp;amp;token=4c6930a47090c3f04c7e9db3bf214078&amp;quot;
&lt;/code>&lt;/pre>&lt;p>启动&lt;code>xxplayer.exe&lt;/code>之后如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 307px">
&lt;a href="/posts/hack/xtan/exe/6.jpg" data-size="926x722">&lt;img src="/posts/hack/xtan/exe/6.jpg"
srcset="/posts/hack/xtan/exe/6_hu611ebb7a50cb9110ffdfa4a2b0b1f4b7_52562_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/6_hu611ebb7a50cb9110ffdfa4a2b0b1f4b7_52562_1024x0_resize_q75_box.jpg 1024w"
width="926"
height="722"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>非常的正常, 但是至少验证了 &lt;strong>&lt;code>xxplayer.exe&lt;/code>是可以脱离&lt;code>xxxchrome.exe&lt;/code>独立运行的&lt;/strong>, 那么既然要鉴权, 不请求服务器肯定是不行的吧? 于是打开&lt;code>Charles&lt;/code>开始抓包, 首先用命令行打开一个免费的乐谱, 捕获到网络请求如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 217; flex-basis: 520px">
&lt;a href="/posts/hack/xtan/exe/7.jpg" data-size="1109x511">&lt;img src="/posts/hack/xtan/exe/7.jpg"
srcset="/posts/hack/xtan/exe/7_hu0c0894aaf992bb2895aba54aaa8c3e13_42004_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/7_hu0c0894aaf992bb2895aba54aaa8c3e13_42004_1024x0_resize_q75_box.jpg 1024w"
width="1109"
height="511"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出主要请求接口为&lt;code>/codeindex.php&lt;/code>, 通过参数&lt;code>m&lt;/code>做不同功能的权限认证&lt;/p>
&lt;p>&lt;strong>当&lt;code>m=index&lt;/code>, 验证成功返回权限信息&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;responseCode&amp;quot;: &amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;: &amp;quot;\u6b63\u5e38&amp;quot;,
&amp;quot;power&amp;quot;: {
&amp;quot;openPower&amp;quot;: &amp;quot;1&amp;quot;,
&amp;quot;printPower&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;printCount&amp;quot;: &amp;quot;30&amp;quot;,
&amp;quot;vstPower&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;pdfPower&amp;quot;: &amp;quot;0&amp;quot;
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当&lt;code>m=getYpdsUrl&lt;/code>, 验证成功返回&lt;code>.ypdx&lt;/code>格式的播放文件地址&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;: {
&amp;quot;code&amp;quot;: &amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;: &amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;: {
&amp;quot;ypdsUrl&amp;quot;: &amp;quot;http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypds&amp;quot;,
&amp;quot;ypdxUrl&amp;quot;: &amp;quot;http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>最后再请求资源地址&lt;code>http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypdx&lt;/code>, 得到&lt;code>.ypdx&lt;/code>格式的播放文件&lt;/strong>&lt;/p>
&lt;p>现在再来通过命令行启动一个VIP乐谱,看看请求和响应会是怎样的&lt;/p>
&lt;p>&lt;figure style="flex-grow: 253; flex-basis: 609px">
&lt;a href="/posts/hack/xtan/exe/8.jpg" data-size="1421x560">&lt;img src="/posts/hack/xtan/exe/8.jpg"
srcset="/posts/hack/xtan/exe/8_hu3f37fa29dc05402f585297533b7b83ee_37005_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/8_hu3f37fa29dc05402f585297533b7b83ee_37005_1024x0_resize_q75_box.jpg 1024w"
width="1421"
height="560"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这次只有一个&lt;code>m=index&lt;/code>的请求, 且返回码不同于免费乐谱的&lt;code>1000&lt;/code>, 之后播放器弹出没有权限的弹窗, 那么思路就来了&lt;/p>
&lt;p>&lt;strong>如果我将篡改请求的响应,播放器应该就会认为我是有权限的,那不就可以播放了吗?&lt;/strong>&lt;/p>
&lt;p>首先使用&lt;code>Charles&lt;/code>进行断点, 针对&lt;code>m=index&lt;/code>的请求, 修改播放器请求VIP乐谱的返回值&lt;/p>
&lt;p>&lt;figure style="flex-grow: 297; flex-basis: 713px">
&lt;a href="/posts/hack/xtan/exe/9.jpg" data-size="1457x490">&lt;img src="/posts/hack/xtan/exe/9.jpg"
srcset="/posts/hack/xtan/exe/9_hu7ca9ec15f72904f15f25adfa64967b6c_45120_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/9_hu7ca9ec15f72904f15f25adfa64967b6c_45120_1024x0_resize_q75_box.jpg 1024w"
width="1457"
height="490"
loading="lazy"
alt="iamge-9">
&lt;/a>
&lt;figcaption>iamge-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>和我预料的一样, 修改&lt;code>m=index&lt;/code>的响应后, 这次发送了&lt;code>m=getYpdsUrl&lt;/code>的请求&lt;/strong>&lt;/p>
&lt;p>但是&lt;code>m=getYpdsUrl&lt;/code>仍然对用户权限进行了判断, 因此返回码不是正常的&lt;code>1000&lt;/code>, 且&lt;code>result&lt;/code>节点没有返回&lt;code>.ypdx&lt;/code>播放文件的资源地址, 看样子不是VIP用户是无法获得资源地址了&lt;/p>
&lt;h1 id="但是">但是&lt;/h1>
&lt;p>&lt;strong>在文章 &lt;a class="link" href="../flash" >某琴吧Flash播放器破解记录&lt;/a> 中, 使用&lt;code>getURL&lt;/code>生成的乐谱信息url去请求乐谱服务器得到的返回值里, 是包含&lt;code>.ypa2&lt;/code>格式的资源地址的, 只不过现在&lt;code>.ypa2&lt;/code>资源已经被删了, 不过观察刚才免费的乐谱&lt;code>.ypdx&lt;/code>资源地址后, 会发现这和&lt;code>.ypa2&lt;/code>的资源地址高度相似! 于是我将返回的&lt;code>.ypa2&lt;/code>资源地址修改后缀名为&lt;code>.ypdx&lt;/code>进行请求之后, 顺利得到了&lt;code>.ypdx&lt;/code>格式的播放文件!&lt;/strong>&lt;/p>
&lt;pre>&lt;code>//ypa2请求地址
http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypa2
//ypdx请求地址
http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypdx
&lt;/code>&lt;/pre>&lt;p>得到&lt;code>.ypdx&lt;/code>文件之后, 开启一个本地HTTP服务器, 开放一个地址用于返回&lt;code>.ypdx&lt;/code>文件, 然后用&lt;code>Charles&lt;/code>对VIP乐谱请求中&lt;code>m=getYpdsUrl&lt;/code>断点, 并修改响应中&lt;code>result&lt;/code>里对应的资源地址为本地HTTP服务器地址&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;:
{
&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;:&amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;:
{
&amp;quot;ypdsUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypds&amp;quot;,&amp;quot;ypdxUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>再次测试, &lt;strong>成功打开VIP乐谱, 并开始播放, 所有功能正常!&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 172; flex-basis: 412px">
&lt;a href="/posts/hack/xtan/exe/10.jpg" data-size="917x533">&lt;img src="/posts/hack/xtan/exe/10.jpg"
srcset="/posts/hack/xtan/exe/10_hud8451ede4dc6fa64d83d0d25cd237bd1_87539_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/10_hud8451ede4dc6fa64d83d0d25cd237bd1_87539_1024x0_resize_q75_box.jpg 1024w"
width="917"
height="533"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>确定伪造响应的方案确定可行之后, 下一步就是要让播放器请求我指定的地址了, 因为刚才是通过&lt;code>Charles&lt;/code>修改响应的, 但我不可能每次都使用&lt;code>Charles&lt;/code>断点, 我需要反编译&lt;code>xxplayer.exe&lt;/code>, 并修改服务请求地址为我监听的地址, 然后由我监听的地址返回所需数据&lt;/p>
&lt;p>使用&lt;code>OllyDbg&lt;/code>(以下简称&lt;code>OD&lt;/code>)反汇编&lt;code>xxplayer.exe&lt;/code>, 在菜单栏依次点击 &amp;ldquo;插件&amp;rdquo; -&amp;gt; &amp;ldquo;中文搜索引擎&amp;rdquo; -&amp;gt; &amp;ldquo;搜索UNICODE&amp;rdquo;, 以&lt;code>Charles&lt;/code>捕获到的url中的关键字&lt;code>codeindex&lt;/code>搜索, 发现一共有三处&lt;/p>
&lt;p>&lt;figure style="flex-grow: 157; flex-basis: 377px">
&lt;a href="/posts/hack/xtan/exe/11.jpg" data-size="873x555">&lt;img src="/posts/hack/xtan/exe/11.jpg"
srcset="/posts/hack/xtan/exe/11_huffee53a5592e1e02a42fb8e5ded3cf0f_112355_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/11_huffee53a5592e1e02a42fb8e5ded3cf0f_112355_1024x0_resize_q75_box.jpg 1024w"
width="873"
height="555"
loading="lazy"
alt="iamge-11">
&lt;/a>
&lt;figcaption>iamge-11&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>Warning: 此处我没有使用虚拟机打开, 建议各位反汇编的时候用虚拟机, 因为被反汇编的程序如果有反调试的代码, 轻则闪退重则格盘. 另外&lt;code>OD&lt;/code>本身是不带&amp;quot;中文搜索引擎&amp;quot;插件的, 需要自行下载安装&lt;/p>
&lt;/blockquote>
&lt;p>双击搜索到的第一处字符串, 跳转到引用代码段, 通过字符串格式可以看出, 其中&lt;code>%s&lt;/code>是要用参数替换的, 且通过前面的&lt;code>push&lt;/code>可以看出, 它自身也是作为参数被传递的, 那么只要跟踪下方离他最近的&lt;code>call&lt;/code>之前的变量, 就能确定需要修改哪一行了, 在可疑的&lt;code>push&lt;/code>处按&lt;code>F2&lt;/code>断点, &lt;code>F8&lt;/code>单步调试后, 发现&lt;code>push [local.7]&lt;/code>正是请求的域名&lt;/p>
&lt;p>&lt;figure style="flex-grow: 247; flex-basis: 593px">
&lt;a href="/posts/hack/xtan/exe/12.jpg" data-size="1382x559">&lt;img src="/posts/hack/xtan/exe/12.jpg"
srcset="/posts/hack/xtan/exe/12_hu2c3187806ba888f67c6ef154a52910a6_103478_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/12_hu2c3187806ba888f67c6ef154a52910a6_103478_1024x0_resize_q75_box.jpg 1024w"
width="1382"
height="559"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>为了修改字符串, 有两种方式&lt;/p>
&lt;ol>
&lt;li>如果修改前后字符串长度相同, 可以直接定位到字符串地址进行修改&lt;/li>
&lt;li>如果长度不同, 可以在程序空白处, 新增一段字符串, 然后将之前对字符串的地址引用改为新增的字符串地址&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>程序空白处是指在&lt;code>OD&lt;/code>左下角的数据面板, 拉到最下面, 可以看到一堆&lt;code>00 00 00 00 00 00 ...&lt;/code>, &lt;code>00&lt;/code>在汇编中就是啥都没有, 啥都不干, 也就是空白的意思&lt;/p>
&lt;/blockquote>
&lt;p>这里暂时不知道&lt;code>[local.7]&lt;/code>哪儿来的, 所以我选择第二种方式, 查看&lt;code>OD&lt;/code>左下角数据面板, 拉到最下面, 找到程序空白处, 双击空白地址, 在弹出的编辑窗口中取消勾选&amp;quot;Keep size&amp;quot;, 在&lt;code>UNICODE&lt;/code>栏输入&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 141; flex-basis: 338px">
&lt;a href="/posts/hack/xtan/exe/13.jpg" data-size="877x621">&lt;img src="/posts/hack/xtan/exe/13.jpg"
srcset="/posts/hack/xtan/exe/13_hudbbd87ddb0f3a147db74e9958487c023_140223_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/13_hudbbd87ddb0f3a147db74e9958487c023_140223_1024x0_resize_q75_box.jpg 1024w"
width="877"
height="621"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 183; flex-basis: 440px">
&lt;a href="/posts/hack/xtan/exe/14.jpg" data-size="674x367">&lt;img src="/posts/hack/xtan/exe/14.jpg"
srcset="/posts/hack/xtan/exe/14_hu04bc64c292e419c662d490484458d11b_82404_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/14_hu04bc64c292e419c662d490484458d11b_82404_1024x0_resize_q75_box.jpg 1024w"
width="674"
height="367"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>Q1: 为什么不在&lt;code>011808E0&lt;/code>行的&lt;code>6C 65 57&lt;/code>后面的&lt;code>00&lt;/code>处添加, 而是在&lt;code>00&lt;/code>的后面?&lt;/p>
&lt;blockquote>
&lt;p>因为汇编中字符串是以&lt;code>00&lt;/code>结尾, 且每个字符后面都跟一个&lt;code>00&lt;/code>, 为了尽量避免覆盖前面的数据块, 这里空开一个&lt;code>00&lt;/code>位置, 如果前面数据块明显是字符串,需要空开三个&lt;code>00&lt;/code>, 因为结束符&lt;code>00&lt;/code>后面也会跟一个&lt;code>00&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Q2: 为什么取消勾选&amp;quot;Keep size&amp;quot;&lt;/p>
&lt;blockquote>
&lt;p>Keep size的作用是保持长度字符串长度一致, 因为如果超过原来的长度会造成不可预知的错误, 但是这里是程序空白处, 后面都是空白行, 所以不需要保持长度, 有多少写多少&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>此时点击新增的字符串头&lt;code>6C&lt;/code>可以在底部栏看到新字符串的起始地址为&lt;code>0x11808E4&lt;/code>, 回到汇编面板, 双击刚才的&lt;code>push [local.7]&lt;/code>所在行, 在弹出的面板中修改为 &lt;code>push 0x11808E4&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>由于修改后的代码较之前的代码更少, 需要勾选&amp;quot;Fill with NOP`s&amp;quot;来保持长度一致&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 468; flex-basis: 1125px">
&lt;a href="/posts/hack/xtan/exe/15.jpg" data-size="661x141">&lt;img src="/posts/hack/xtan/exe/15.jpg"
srcset="/posts/hack/xtan/exe/15_hu57c63b4afeb55ac5b9b491851fbce9ac_27836_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/15_hu57c63b4afeb55ac5b9b491851fbce9ac_27836_1024x0_resize_q75_box.jpg 1024w"
width="661"
height="141"
loading="lazy"
alt="image-15">
&lt;/a>
&lt;figcaption>image-15&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到在汇编面板右侧已经自动显示了标记, 提示当前&lt;code>push&lt;/code>的值为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 494; flex-basis: 1187px">
&lt;a href="/posts/hack/xtan/exe/16.jpg" data-size="757x153">&lt;img src="/posts/hack/xtan/exe/16.jpg"
srcset="/posts/hack/xtan/exe/16_hu9bfdeefc21eab2638c1ebf03797105d7_27361_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/16_hu9bfdeefc21eab2638c1ebf03797105d7_27361_1024x0_resize_q75_box.jpg 1024w"
width="757"
height="153"
loading="lazy"
alt="image-16">
&lt;/a>
&lt;figcaption>image-16&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>现在选中刚才在数据面板添加的字符串十六进制代码块, 右键点击&amp;quot;复制到可执行文件&amp;quot;, 再选中汇编面板所有修改的行, 右键点击&amp;quot;复制到可执行文件&amp;quot; -&amp;gt; &amp;ldquo;选中行&amp;rdquo;, 在弹出的面板中右键&amp;quot;备份&amp;quot; -&amp;gt; &amp;ldquo;保存数据到文件&amp;quot;即可保存修改后的exe文件&lt;/p>
&lt;p>&lt;figure style="flex-grow: 169; flex-basis: 406px">
&lt;a href="/posts/hack/xtan/exe/36.jpg" data-size="490x289">&lt;img src="/posts/hack/xtan/exe/36.jpg"
srcset="/posts/hack/xtan/exe/36_hu404fc96720b3b7e3a08d11e39c71c904_39522_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/36_hu404fc96720b3b7e3a08d11e39c71c904_39522_1024x0_resize_q75_box.jpg 1024w"
width="490"
height="289"
loading="lazy"
alt="image-36">
&lt;/a>
&lt;figcaption>image-36&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>执行修改后的程序, 发现程序异常退出, 用&lt;code>OD&lt;/code>打开修改后的文件, 再次找到刚才修改&lt;code>push&lt;/code>的地方, 发现右侧没有显示&lt;code>localhost:7777&lt;/code>的标记&lt;/p>
&lt;p>&lt;figure style="flex-grow: 792; flex-basis: 1900px">
&lt;a href="/posts/hack/xtan/exe/17.jpg" data-size="800x101">&lt;img src="/posts/hack/xtan/exe/17.jpg"
srcset="/posts/hack/xtan/exe/17_huf607ca71409b4fad60df0a0bf04883f0_25000_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/17_huf607ca71409b4fad60df0a0bf04883f0_25000_1024x0_resize_q75_box.jpg 1024w"
width="800"
height="101"
loading="lazy"
alt="image-17">
&lt;/a>
&lt;figcaption>image-17&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再看看跳转地址&lt;code>0x11808E4&lt;/code>, 也不是刚才修改的字符串内容&lt;/p>
&lt;p>&lt;figure style="flex-grow: 223; flex-basis: 535px">
&lt;a href="/posts/hack/xtan/exe/18.jpg" data-size="705x316">&lt;img src="/posts/hack/xtan/exe/18.jpg"
srcset="/posts/hack/xtan/exe/18_hu399d950736d8f788e6f1fac9c27f058c_68183_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/18_hu399d950736d8f788e6f1fac9c27f058c_68183_1024x0_resize_q75_box.jpg 1024w"
width="705"
height="316"
loading="lazy"
alt="image-18">
&lt;/a>
&lt;figcaption>image-18&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>虽然不知道为什么, 但是看来&lt;code>push [local.x]&lt;/code>形式的代码不能这样简单的修改. 那么换个角度想想&lt;code>[local.7]&lt;/code>的值是哪里来的, 这时突然想到播放器启动的时候, 带的参数里是有一个网址的&lt;/p>
&lt;pre>&lt;code>file=http://www.马赛克.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981
&lt;/code>&lt;/pre>&lt;p>我将这个网址修改为百度的网址&lt;/p>
&lt;pre>&lt;code>file=http://www.baidu.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981
&lt;/code>&lt;/pre>&lt;p>重新运行, 抓包发现它真的去请求百度的&lt;code>/codeindex.php&lt;/code>接口了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 246; flex-basis: 591px">
&lt;a href="/posts/hack/xtan/exe/19.jpg" data-size="1201x487">&lt;img src="/posts/hack/xtan/exe/19.jpg"
srcset="/posts/hack/xtan/exe/19_hu0b7b1ef1c2d34dbfa1585c7679051785_39521_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/19_hu0b7b1ef1c2d34dbfa1585c7679051785_39521_1024x0_resize_q75_box.jpg 1024w"
width="1201"
height="487"
loading="lazy"
alt="image-19">
&lt;/a>
&lt;figcaption>image-19&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>于是我再将参数换成&lt;code>localhost:7777&lt;/code>, 重新运行, 结果发现程序异常退出, 进行跟踪调试发现&lt;code>[local.7]&lt;/code>的实际值被截取了不包含端口号的部分, 为&lt;code>localhost&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 698; flex-basis: 1676px">
&lt;a href="/posts/hack/xtan/exe/20.jpg" data-size="433x62">&lt;img src="/posts/hack/xtan/exe/20.jpg"
srcset="/posts/hack/xtan/exe/20_hu440de6aaab4215e0c9aec32fa24ecc7b_7055_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/20_hu440de6aaab4215e0c9aec32fa24ecc7b_7055_1024x0_resize_q75_box.jpg 1024w"
width="433"
height="62"
loading="lazy"
alt="image-20">
&lt;/a>
&lt;figcaption>image-20&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>尝试跟踪截取部分的代码, 但是太麻烦了决定放弃. 这时候我想到直接将整个url&lt;/p>
&lt;pre>&lt;code>%s://%s/codeindex.php?d=api&amp;amp;c=check马赛克playerPower&amp;amp;m=%s&amp;amp;ypid=%d&amp;amp;uid=%d&amp;amp;token=%s
&lt;/code>&lt;/pre>&lt;p>中第二个&lt;code>%s&lt;/code>直接替换成&lt;code>localhost:7777&lt;/code>不就可以了? 但是这样就少了一个&lt;code>%s&lt;/code>, 参数对不上后面的代码一定会报错, 于是我想到在&lt;code>?&lt;/code>后面再加一个参数, 参数名随意, 参数值就用&lt;code>[local.7]&lt;/code>, 反正对于串来说, &lt;code>%s&lt;/code>的数量能够对应参数的数量即可, 而对于HTTP请求来说, 多一个参数也没什么影响. 不过修改后字符串的长度就对不上了, 所以还是在程序空白处添加了一个新的字符串如下&lt;/p>
&lt;pre>&lt;code>%s://localhost:7777/codeindex.php?a=%s&amp;amp;d=api&amp;amp;c=check马赛克playerPower&amp;amp;m=%s&amp;amp;ypid=%d&amp;amp;uid=%d&amp;amp;token=%s
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 153; flex-basis: 367px">
&lt;a href="/posts/hack/xtan/exe/21.jpg" data-size="889x580">&lt;img src="/posts/hack/xtan/exe/21.jpg"
srcset="/posts/hack/xtan/exe/21_hu1c54f487ac9664d7c79f770f2f649700_141375_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/21_hu1c54f487ac9664d7c79f770f2f649700_141375_1024x0_resize_q75_box.jpg 1024w"
width="889"
height="580"
loading="lazy"
alt="image-21">
&lt;/a>
&lt;figcaption>image-21&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>a&lt;/code>就是新增的无用参数, &lt;code>a&lt;/code>后面跟的&lt;code>%s&lt;/code>将会被&lt;code>[local.7]&lt;/code>的值替换, 这样一来无论启动参数中的域名是什么都无所谓了. 记录新字符串的地址为&lt;code>0x11808E4&lt;/code>, 找到&lt;code>push&lt;/code>原来字符串的汇编代码, 修改&lt;code>push&lt;/code>地址为新的字符串地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 375; flex-basis: 901px">
&lt;a href="/posts/hack/xtan/exe/22.jpg" data-size="781x208">&lt;img src="/posts/hack/xtan/exe/22.jpg"
srcset="/posts/hack/xtan/exe/22_hue1957260a927d0c5dbb86391d75e28e1_43919_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/22_hue1957260a927d0c5dbb86391d75e28e1_43919_1024x0_resize_q75_box.jpg 1024w"
width="781"
height="208"
loading="lazy"
alt="image-22">
&lt;/a>
&lt;figcaption>image-22&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再次保存执行, 程序还是异常退出, 用&lt;code>OD&lt;/code>打开修改后的程序发现地址正确, 字符串正确, 但是还是会报错, 于是我怀疑不能用&lt;code>localhost&lt;/code>作为域名. 将&lt;code>localhost:7777&lt;/code>修改为&lt;code>127.0.0.1:7777&lt;/code>, 再次运行, 这次终于在后台收到了来自播放器的HTTP请求!&lt;/p>
&lt;p>&lt;figure style="flex-grow: 142; flex-basis: 341px">
&lt;a href="/posts/hack/xtan/exe/23.jpg" data-size="588x413">&lt;img src="/posts/hack/xtan/exe/23.jpg"
srcset="/posts/hack/xtan/exe/23_hue6d1dcff70949874743239655fec497d_58860_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/23_hue6d1dcff70949874743239655fec497d_58860_1024x0_resize_q75_box.jpg 1024w"
width="588"
height="413"
loading="lazy"
alt="image-23">
&lt;/a>
&lt;figcaption>image-23&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>所有参数也都正常接收, 接下来只要返回正确的响应就行了, 对于&lt;code>m=index&lt;/code>的直接返回&lt;/p>
&lt;pre>&lt;code>{&amp;quot;responseCode&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;power&amp;quot;:{&amp;quot;openPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printPower&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;,&amp;quot;vstPower&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;pdfPower&amp;quot;:&amp;quot;0&amp;quot;}}
&lt;/code>&lt;/pre>&lt;p>对于&lt;code>m=getYpdsUrl&lt;/code> 的则返回&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;:
{
&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;:&amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;:
{
&amp;quot;ypdsUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypds&amp;quot;,&amp;quot;ypdxUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>然后, 用同样的方式修改搜索&lt;code>codeindex&lt;/code>结果中的第二处, 再次运行就能正常播放了.&lt;/p>
&lt;h2 id="继续破解">继续破解&lt;/h2>
&lt;p>&lt;strong>现在虽然播放曲谱没有问题了, 但是现在还有如下几个VIP功能用不了, 要白嫖就白嫖到极致&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 143; flex-basis: 345px">
&lt;a href="/posts/hack/xtan/exe/24.jpg" data-size="233x162">&lt;img src="/posts/hack/xtan/exe/24.jpg"
srcset="/posts/hack/xtan/exe/24_hu900d4ace8f5f7a408779743848e939c7_8586_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/24_hu900d4ace8f5f7a408779743848e939c7_8586_1024x0_resize_q75_box.jpg 1024w"
width="233"
height="162"
loading="lazy"
alt="image-24">
&lt;/a>
&lt;figcaption>image-24&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>从音源开始下手, 点击&amp;quot;音源&amp;rdquo; -&amp;gt; &amp;ldquo;浏览&amp;quot;后, 播放器弹出没有权限的提示&lt;/p>
&lt;p>&lt;figure style="flex-grow: 204; flex-basis: 491px">
&lt;a href="/posts/hack/xtan/exe/25.jpg" data-size="346x169">&lt;img src="/posts/hack/xtan/exe/25.jpg"
srcset="/posts/hack/xtan/exe/25_hu59dd44e7ae9f17fbaea053064c4a0a8f_7285_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/25_hu59dd44e7ae9f17fbaea053064c4a0a8f_7285_1024x0_resize_q75_box.jpg 1024w"
width="346"
height="169"
loading="lazy"
alt="image-25">
&lt;/a>
&lt;figcaption>image-25&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查看&lt;code>Charles&lt;/code>发现期间并没有发出网络请求, 推测应该是在之前的请求里就响应过了, 这时想到最开始&lt;code>m=index&lt;/code>的请求中, &lt;code>power&lt;/code>节点有很多为&lt;code>0&lt;/code>的字段, 仔细一看这不就是对应的权限吗? 推测权限字段对应关系应该是&lt;/p>
&lt;ul>
&lt;li>&lt;code>openPower&lt;/code> 打开的权限&lt;/li>
&lt;li>&lt;code>printPower&lt;/code> 打印的权限&lt;/li>
&lt;li>&lt;code>printCount&lt;/code> 可打印的数量&lt;/li>
&lt;li>&lt;code>vstPower&lt;/code> 使用vst音源的权限&lt;/li>
&lt;li>&lt;code>pdfPower&lt;/code> 转换pdf的权限&lt;/li>
&lt;/ul>
&lt;p>参考正常响应中&lt;code>openPower&lt;/code>为1, 其他的为0, 因此把后台响应中所有为0改为1, 再次点击音源, 发现可以正常选择了&lt;/p>
&lt;pre>&lt;code>{&amp;quot;responseCode&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;power&amp;quot;:{&amp;quot;openPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;,&amp;quot;vstPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;pdfPower&amp;quot;:&amp;quot;1&amp;quot;}}
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 279; flex-basis: 669px">
&lt;a href="/posts/hack/xtan/exe/26.jpg" data-size="960x344">&lt;img src="/posts/hack/xtan/exe/26.jpg"
srcset="/posts/hack/xtan/exe/26_hu1bf099da9e3265a9d42b774a7d669a1d_27932_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/26_hu1bf099da9e3265a9d42b774a7d669a1d_27932_1024x0_resize_q75_box.jpg 1024w"
width="960"
height="344"
loading="lazy"
alt="image-26">
&lt;/a>
&lt;figcaption>image-26&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接下来看看点击转换PDF功能, 通过&lt;code>Charles&lt;/code>发现会发送一个权限请求&lt;/p>
&lt;p>&lt;figure style="flex-grow: 235; flex-basis: 565px">
&lt;a href="/posts/hack/xtan/exe/27.jpg" data-size="1355x575">&lt;img src="/posts/hack/xtan/exe/27.jpg"
srcset="/posts/hack/xtan/exe/27_hu4561b2c4374e5a889b57d6ec9aab22e2_42292_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/27_hu4561b2c4374e5a889b57d6ec9aab22e2_42292_1024x0_resize_q75_box.jpg 1024w"
width="1355"
height="575"
loading="lazy"
alt="image-27">
&lt;/a>
&lt;figcaption>image-27&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中接口仍然是&lt;code>/codeindex.php&lt;/code>, 但本次&lt;code>m&lt;/code>取值为&lt;code>addDynamic&lt;/code>, 在&lt;code>OD&lt;/code>中发现就是刚才上文&lt;code>codeindex&lt;/code>搜索结果中的第三处&lt;/p>
&lt;p>&lt;figure style="flex-grow: 326; flex-basis: 784px">
&lt;a href="/posts/hack/xtan/exe/28.jpg" data-size="1232x377">&lt;img src="/posts/hack/xtan/exe/28.jpg"
srcset="/posts/hack/xtan/exe/28_hu916247033dd02548bff370c15f18cd50_79605_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/28_hu916247033dd02548bff370c15f18cd50_79605_1024x0_resize_q75_box.jpg 1024w"
width="1232"
height="377"
loading="lazy"
alt="image-28">
&lt;/a>
&lt;figcaption>image-28&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>双击搜索结果字符串转到汇编代码,&lt;code>00F63EAE&lt;/code> 处的&lt;code>push&lt;/code>地址就是将要用来替换成请求域名的参数, 这个地址指向了某琴吧的域名, 所以这里采用同样的办法, 先在程序空白处添加字符串&lt;code>127.0.0.1:7777&lt;/code>, 然后修改&lt;code>push&lt;/code>原来串的地址修改为新增的字符串地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 121; flex-basis: 291px">
&lt;a href="/posts/hack/xtan/exe/29.jpg" data-size="863x711">&lt;img src="/posts/hack/xtan/exe/29.jpg"
srcset="/posts/hack/xtan/exe/29_hu38430dc1e6439a03884f24c857dc3df5_158665_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/29_hu38430dc1e6439a03884f24c857dc3df5_158665_1024x0_resize_q75_box.jpg 1024w"
width="863"
height="711"
loading="lazy"
alt="image-29">
&lt;/a>
&lt;figcaption>image-29&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>重新保存, 然后在乐谱工具中监听这个地址, 并参考&lt;code>m=index&lt;/code>的响应以下结果&lt;/p>
&lt;blockquote>
&lt;p>乐谱工具是我基于&lt;code>C#&lt;/code>开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自&lt;code>localhost:7777&lt;/code>的HTTP请求&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>{&amp;quot;data&amp;quot;:{&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;result&amp;quot;:{&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;}}}
&lt;/code>&lt;/pre>&lt;p>重新打开运行PDF保存, 发现可以转换并保存了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 134; flex-basis: 323px">
&lt;a href="/posts/hack/xtan/exe/30.jpg" data-size="820x608">&lt;img src="/posts/hack/xtan/exe/30.jpg"
srcset="/posts/hack/xtan/exe/30_hu8e914918ef7e0abf8766f87cc7afd2fe_39001_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/30_hu8e914918ef7e0abf8766f87cc7afd2fe_39001_1024x0_resize_q75_box.jpg 1024w"
width="820"
height="608"
loading="lazy"
alt="image-30">
&lt;/a>
&lt;figcaption>image-30&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>打印的功能和PDF的请求地址和参数&lt;code>m&lt;/code>是一样的, 只要返回同样的响应就可以了&lt;/p>
&lt;p>&lt;strong>至此VIP功能全部破解&lt;/strong>&lt;/p>
&lt;h2 id="但是尚不完美">但是尚不完美&lt;/h2>
&lt;p>最后做脱机测试的时候发现播放器会先检查网络连接状态, 没有网络连接则无法播放&lt;/p>
&lt;p>&lt;figure style="flex-grow: 138; flex-basis: 332px">
&lt;a href="/posts/hack/xtan/exe/31.jpg" data-size="234x169">&lt;img src="/posts/hack/xtan/exe/31.jpg"
srcset="/posts/hack/xtan/exe/31_hua7620923e16ce59bf6ec472d077d4bf8_5366_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/31_hua7620923e16ce59bf6ec472d077d4bf8_5366_1024x0_resize_q75_box.jpg 1024w"
width="234"
height="169"
loading="lazy"
alt="image-31">
&lt;/a>
&lt;figcaption>image-31&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是我的目标是播放器能够脱机使用, 而且实际上播放器被我修改后已经不需要再连上互联网, 只需要请求乐谱工具的HTTP服务地址就可以, 因此根据弹窗搜索字符串, 定位到相关代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 356; flex-basis: 854px">
&lt;a href="/posts/hack/xtan/exe/32.jpg" data-size="755x212">&lt;img src="/posts/hack/xtan/exe/32.jpg"
srcset="/posts/hack/xtan/exe/32_huc5c8a523870c7cfbc55a7f4c1592a244_51730_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/32_huc5c8a523870c7cfbc55a7f4c1592a244_51730_1024x0_resize_q75_box.jpg 1024w"
width="755"
height="212"
loading="lazy"
alt="image-32">
&lt;/a>
&lt;figcaption>image-32&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到播放器在&lt;code>00F693E2&lt;/code>处调用系统接口得到网络连接状态, 在&lt;code>00F693EC&lt;/code>处, 如果有网络连接则会跳转到&lt;code>00F6940A&lt;/code>处继续, 没有网络连接则会显示并中断运行, 那我只需要让这个判断失效就可以了, 双击&lt;code>00F693EC&lt;/code>打开编辑窗口, 将&lt;code>jnz&lt;/code> (不等于0则跳转) 修改为&lt;code>jmp&lt;/code> (无条件跳转), 这样运行至此的时候将不会判断网络连接状态, 直接运行后面的代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 258; flex-basis: 621px">
&lt;a href="/posts/hack/xtan/exe/34.jpg" data-size="725x280">&lt;img src="/posts/hack/xtan/exe/34.jpg"
srcset="/posts/hack/xtan/exe/34_hu97a16d2494720619905afeac8c214e7e_58677_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/34_hu97a16d2494720619905afeac8c214e7e_58677_1024x0_resize_q75_box.jpg 1024w"
width="725"
height="280"
loading="lazy"
alt="image-34">
&lt;/a>
&lt;figcaption>image-34&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 424; flex-basis: 1018px">
&lt;a href="/posts/hack/xtan/exe/35.jpg" data-size="734x173">&lt;img src="/posts/hack/xtan/exe/35.jpg"
srcset="/posts/hack/xtan/exe/35_hua827e34f01cf28e04ef01c9d17be5ee7_41039_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/35_hua827e34f01cf28e04ef01c9d17be5ee7_41039_1024x0_resize_q75_box.jpg 1024w"
width="734"
height="173"
loading="lazy"
alt="image-35">
&lt;/a>
&lt;figcaption>image-35&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>同样的, 在使用转换PDF功能时还会检测网络状态, 然后弹窗提示&amp;quot;没有检测到网络!&amp;rdquo;, 找到代码运行处, 修改&lt;code>00F75DDE&lt;/code>处的&lt;code>jnz&lt;/code>为&lt;code>jmp&lt;/code>即可&lt;/p>
&lt;p>&lt;figure style="flex-grow: 529; flex-basis: 1271px">
&lt;a href="/posts/hack/xtan/exe/33.jpg" data-size="694x131">&lt;img src="/posts/hack/xtan/exe/33.jpg"
srcset="/posts/hack/xtan/exe/33_huf3b00aaa9378afd32a3c2a50a118f246_35895_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/33_huf3b00aaa9378afd32a3c2a50a118f246_35895_1024x0_resize_q75_box.jpg 1024w"
width="694"
height="131"
loading="lazy"
alt="image-33">
&lt;/a>
&lt;figcaption>image-33&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>保存后重新运行, 现在脱机情况下播放器能够正常打开并请求乐谱工具的HTTP服务并正常播放乐谱了, 转存PDF文件等VIP功能也能够正常使用&lt;/p>
&lt;h2 id="至此exe版本宣告完美破解">至此exe版本宣告完美破解&lt;/h2></description></item><item><title>某琴吧Flash播放器破解记录</title><link>/posts/hack/xtan/flash/</link><pubDate>Tue, 25 May 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xtan/flash/</guid><description>&lt;img src="/posts/hack/xtan/flash/cover.png" alt="Featured image of post 某琴吧Flash播放器破解记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.&lt;/p>
&lt;p>同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用&lt;/p>
&lt;h2 id="网站乐谱页">网站乐谱页&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 105; flex-basis: 252px">
&lt;a href="/posts/hack/xtan/flash/1.jpg" data-size="829x789">&lt;img src="/posts/hack/xtan/flash/1.jpg"
srcset="/posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_1024x0_resize_q75_box.jpg 1024w"
width="829"
height="789"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>&lt;strong>首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>进入乐谱页面, 网站向服务端请求 &lt;code>player.swf&lt;/code>, 该 &lt;code>.swf&lt;/code> 文件即为乐谱播放器&lt;/li>
&lt;li>浏览器加载 &lt;code>player.swf&lt;/code> , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中&lt;/li>
&lt;li>点击播放按钮时, 播放器请求 &lt;code>Sounds.swf&lt;/code>,&lt;/li>
&lt;li>播放器请求接口 &lt;code>/flash_get_yp_info.php&lt;/code> 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址&lt;/li>
&lt;li>播放器下载并载入余下的 &lt;code>.png&lt;/code> 格式乐谱图片, 并加载 &lt;code>.ypa2&lt;/code> 格式的播放文件, 即可开始播放&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>基本过程已经明确了, 而所有的请求接口中, 只有第四步的&lt;code>/flash_get_yp_info.php&lt;/code>是需要对入参&lt;code>sccode&lt;/code>, &lt;code>r1&lt;/code>, &lt;code>r2&lt;/code>, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?&lt;/strong>&lt;/p>
&lt;p>首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 &lt;a class="link" href="https://github.com/wholesky/ffdec" target="_blank" rel="noopener"
>jpexs-decompiler&lt;/a>, 顺利反编译出&lt;code>player.swf&lt;/code>代码, 用IDEA新建为&lt;code>Flex&lt;/code>项目打开, 再百度其中的一些&lt;code>package&lt;/code>名称, 发现代码可基于 &lt;code>flex_sdk_3.6a&lt;/code> 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 120; flex-basis: 288px">
&lt;a href="/posts/hack/xtan/flash/2.jpg" data-size="965x803">&lt;img src="/posts/hack/xtan/flash/2.jpg"
srcset="/posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_1024x0_resize_q75_box.jpg 1024w"
width="965"
height="803"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>Main&lt;/code>为主类, &lt;code>init1&lt;/code> 为初始化函数, 这里可以得到入参, 参数传入形式为&lt;/p>
&lt;pre>&lt;code>player.swf?id=1
&lt;/code>&lt;/pre>&lt;p>而配置类&lt;code>Config&lt;/code>定义了服务端接口地址:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 167; flex-basis: 402px">
&lt;a href="/posts/hack/xtan/flash/3.png" data-size="825x492">&lt;img src="/posts/hack/xtan/flash/3.png"
srcset="/posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_480x0_resize_box_2.png 480w, /posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_1024x0_resize_box_2.png 1024w"
width="825"
height="492"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是很遗憾在&lt;code>player.swf&lt;/code>中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时&lt;code>Sounds.swf&lt;/code>就很可疑了, 通过阅读&lt;code>player.swf&lt;/code>的代码发现&lt;code>Sounds.swf&lt;/code>是点击播放按钮之后, 作为一个函数库被加载进来的, 这里&lt;code>load&lt;/code>的地址就是&lt;code>Config&lt;/code>里定义了&lt;code>Sounds.swf&lt;/code>资源地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 699; flex-basis: 1677px">
&lt;a href="/posts/hack/xtan/flash/4.jpg" data-size="734x105">&lt;img src="/posts/hack/xtan/flash/4.jpg"
srcset="/posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_1024x0_resize_q75_box.jpg 1024w"
width="734"
height="105"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>请求响应之后通过回调函数&lt;code>onSwComplete&lt;/code>将其载入并储存到&lt;code>Clib&lt;/code>类的成员变量&lt;code>clib&lt;/code>中&lt;/p>
&lt;p>&lt;figure style="flex-grow: 318; flex-basis: 764px">
&lt;a href="/posts/hack/xtan/flash/5.jpg" data-size="771x242">&lt;img src="/posts/hack/xtan/flash/5.jpg"
srcset="/posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_1024x0_resize_q75_box.jpg 1024w"
width="771"
height="242"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>然后就可以通过&lt;code>utils.Clib.clib.xxx&lt;/code>的方式调用函数, 再深入跟踪代码, 发现&lt;code>Clib&lt;/code>中的&lt;code>getURL&lt;/code>非常可疑&lt;/p>
&lt;p>&lt;figure style="flex-grow: 379; flex-basis: 910px">
&lt;a href="/posts/hack/xtan/flash/6.jpg" data-size="353x93">&lt;img src="/posts/hack/xtan/flash/6.jpg"
srcset="/posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_1024x0_resize_q75_box.jpg 1024w"
width="353"
height="93"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>找到他被调用的地方, 加一行日志跟踪一下输出&lt;/p>
&lt;p>&lt;figure style="flex-grow: 555; flex-basis: 1333px">
&lt;a href="/posts/hack/xtan/flash/7.jpg" data-size="400x72">&lt;img src="/posts/hack/xtan/flash/7.jpg"
srcset="/posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_1024x0_resize_q75_box.jpg 1024w"
width="400"
height="72"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>调试运行之后输出的字符串为:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 469; flex-basis: 1127px">
&lt;a href="/posts/hack/xtan/flash/14.jpg" data-size="902x192">&lt;img src="/posts/hack/xtan/flash/14.jpg"
srcset="/posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_1024x0_resize_q75_box.jpg 1024w"
width="902"
height="192"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>这个地址跟第四步的请求地址就是同一个地址!&lt;/strong> 这就是我要找的东西, 现在只需要反编译&lt;code>Sounds.swf&lt;/code>, 把&lt;code>getURL&lt;/code>的算法抄下来就可以了! 想法很美好, 但现实很骨感, &lt;code>Sounds.swf&lt;/code>反编译后发现经过了加密混淆, 反编译出来的代码是这样的&lt;/p>
&lt;p>&lt;figure style="flex-grow: 116; flex-basis: 280px">
&lt;a href="/posts/hack/xtan/flash/8.jpg" data-size="821x702">&lt;img src="/posts/hack/xtan/flash/8.jpg"
srcset="/posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_1024x0_resize_q75_box.jpg 1024w"
width="821"
height="702"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 327; flex-basis: 786px">
&lt;a href="/posts/hack/xtan/flash/9.jpg" data-size="678x207">&lt;img src="/posts/hack/xtan/flash/9.jpg"
srcset="/posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_1024x0_resize_q75_box.jpg 1024w"
width="678"
height="207"
loading="lazy"
alt="image-9">
&lt;/a>
&lt;figcaption>image-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这url不就是刚才输出的地址吗, 显然此处的代码是将url中的&lt;code>%s&lt;/code>, &lt;code>%d&lt;/code>替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个&lt;code>Sounds.swf&lt;/code>是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用&lt;code>getURL&lt;/code>这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询&lt;code>ActionScript&lt;/code>资料, 发现可以通过&lt;code>ExternalInterface&lt;/code>, 让&lt;code>.swf&lt;/code>将接口暴露出来提供外部Flash容器调用, 对于&lt;code>player.swf&lt;/code>来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用&lt;code>WinForm&lt;/code>的&lt;code>Shockwave Flash&lt;/code>组件.&lt;/p>
&lt;p>于是修改&lt;code>player.swf&lt;/code>的源码, 在&lt;code>Main&lt;/code>中定义一段可供外部调用的函数&lt;/p>
&lt;p>&lt;figure style="flex-grow: 210; flex-basis: 505px">
&lt;a href="/posts/hack/xtan/flash/10.jpg" data-size="825x392">&lt;img src="/posts/hack/xtan/flash/10.jpg"
srcset="/posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_1024x0_resize_q75_box.jpg 1024w"
width="825"
height="392"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中函数名为&lt;code>swfExtGetypURL&lt;/code>, 入参为&lt;code>string&lt;/code>类型的乐谱ID, 函数首先检查&lt;code>clib&lt;/code>是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用&lt;code>Clib&lt;/code>的&lt;code>getURL&lt;/code>返回乐谱信息url.&lt;/p>
&lt;p>上文提到&lt;code>clib&lt;/code>是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化&lt;code>clib&lt;/code>的函数&lt;code>onSwComplete&lt;/code>, 仿照其代码, 在&lt;code>Clib&lt;/code>中写一段初始化代码如下:&lt;/p>
&lt;pre>&lt;code>public static function myLoadSwf() : void
{
swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady);
swfLoader.load(new URLRequest(Config.flash_sound_lib_URL));
}
internal static function onSoundsReady(arg1:Event) : void
{
swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
var loc2:* = loc1.getDefinition(&amp;quot;Sounds&amp;quot;) as Class;
CLib.clib = loc2.cLibInit();
}
&lt;/code>&lt;/pre>&lt;p>并将原来的初始化代码&lt;code>loadSwf&lt;/code>修改为:&lt;/p>
&lt;pre>&lt;code>//修改前
public static function loadSwf(arg1:Function):void
{
swfLoadCompleteCallBack = arg1;
swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
ui.HUD.show(&amp;quot;加载音色库&amp;quot;, 0);
swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
swfLoadCompleteCallBack();
return;
}
//修改后
public static function loadSwf(arg1:Function):void
{
swfLoadCompleteCallBack = arg1;
if(null == CLib.clib)
{
swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
ui.HUD.show(&amp;quot;加载音色库&amp;quot;, 0);
swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
} else {
swfLoadCompleteCallBack();
}
return;
}
&lt;/code>&lt;/pre>&lt;p>最后在&lt;code>Mian&lt;/code>类的初始化函数&lt;code>init1&lt;/code>中调用&lt;code>myLoadSwf&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 190; flex-basis: 456px">
&lt;a href="/posts/hack/xtan/flash/12.jpg" data-size="574x302">&lt;img src="/posts/hack/xtan/flash/12.jpg"
srcset="/posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_1024x0_resize_q75_box.jpg 1024w"
width="574"
height="302"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>大功告成, 现在 &lt;code>player.swf&lt;/code> 在启动的时候就会调用我添加的 &lt;code>myLoadSwf&lt;/code> 函数, 开始加载 &lt;code>Sounds.swf&lt;/code> 并初始化到 &lt;code>Clib&lt;/code> 中. 而原来的&lt;code>loadSwf&lt;/code>会先判断&lt;code>Sounds.swf&lt;/code>有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过&lt;code>Shockwave Flash&lt;/code>组件调用&lt;code>player.swf&lt;/code>暴露出来的外部接口就可以了, 调用方式如下:&lt;/p>
&lt;pre>&lt;code>axShockwaveFlash.CallFunction(
string.Format(&amp;quot;&amp;lt;invoke name=\&amp;quot;swfExtGetypURL\&amp;quot; returntype=\&amp;quot;xml\&amp;quot;&amp;gt;&amp;lt;arguments&amp;gt;&amp;lt;string&amp;gt;{0}&amp;lt;/string&amp;gt;&amp;lt;/arguments&amp;gt;&amp;lt;/invoke&amp;gt;&amp;quot;, ypid));
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>axShockwaveFlash&lt;/code> 是我在c#代码中定义的Flash容器组件成员变量, 它加载了&lt;code>player.swf&lt;/code>作为内容, 代码中调用到的扩展函数名称为&lt;code>swfExtGetypURL&lt;/code>, 也就是刚才在&lt;code>player.swf&lt;/code>的&lt;code>Main&lt;/code>中定义的&lt;code>ExternalInterface&lt;/code>类型的函数, 参数为&lt;code>string&lt;/code>类型的乐谱ID&lt;/p>
&lt;/blockquote>
&lt;p>得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:&lt;/p>
&lt;pre>&lt;code>&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;yp_create_time=&amp;lt;yp_create_time&amp;gt;1601587012&amp;lt;/yp_create_time&amp;gt; &amp;lt;br/&amp;gt;
yp_title=&amp;lt;yp_title&amp;gt;Summer（菊次郎的夏天）&amp;lt;/yp_title&amp;gt; &amp;lt;br/&amp;gt;
yp_page_count=&amp;lt;yp_page_count&amp;gt;5&amp;lt;/yp_page_count&amp;gt; &amp;lt;br/&amp;gt;
yp_page_width=&amp;lt;yp_page_width&amp;gt;1051&amp;lt;/yp_page_width&amp;gt; &amp;lt;br/&amp;gt;
yp_page_height=&amp;lt;yp_page_height&amp;gt;1487&amp;lt;/yp_page_height&amp;gt; &amp;lt;br/&amp;gt;
yp_is_dadiao=&amp;lt;yp_is_dadiao&amp;gt;1&amp;lt;/yp_is_dadiao&amp;gt; &amp;lt;br/&amp;gt;
yp_key_note=&amp;lt;yp_key_note&amp;gt;2&amp;lt;/yp_key_note&amp;gt; &amp;lt;br/&amp;gt;
yp_is_yanyin=&amp;lt;yp_is_yanyin&amp;gt;0&amp;lt;/yp_is_yanyin&amp;gt; &amp;lt;br/&amp;gt;
ypad_url=&amp;lt;ypad_url&amp;gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad&amp;lt;/ypad_url&amp;gt;ypad_url2=&amp;lt;ypad_url2&amp;gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2&amp;lt;/ypad_url2&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>接下来, 只需要解析响应并下载资源就可以了&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>解析 &lt;code>yp_page_count&lt;/code> 节点可以得到乐谱的总页数&lt;/li>
&lt;li>解析&lt;code>ypad_url&lt;/code>节点, 并在节点中url的最后拼接&lt;code>.乐谱页数.png&lt;/code>, 即可得到真实的乐谱图片地址&lt;/li>
&lt;li>解析&lt;code>ypad_url&lt;/code>节点, 截取 &lt;code>_&lt;/code> 的前半部分, 再拼接 &lt;code>_prev.jpg&lt;/code>还可以得到乐谱的封面图&lt;/li>
&lt;li>解析&lt;code>ypad_url2&lt;/code>节点即可获取真实的&lt;code>.ypa2&lt;/code>格式的播放文件&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式&lt;/p>
&lt;/blockquote>
&lt;p>以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对&lt;code>player.swf&lt;/code>和&lt;code>Sounds.swf&lt;/code>做一些修改, 首先修改&lt;code>player.swf&lt;/code>的&lt;code>Config&lt;/code>类, 把其中关键的加载&lt;code>Sounds.swf&lt;/code>和获取封面的地址修改为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;pre>&lt;code>//获取曲谱封面的地址
public static const flash_prev_yp_info_URL:String = &amp;quot;http://localhost:7777/yuepu/preview&amp;quot;;
//获取Sounds.swf的地址
public static const flash_sound_lib_URL:String = &amp;quot;http://localhost:7777/yuepu/flash/sound&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>然后修改&lt;code>Sounds.swf&lt;/code>在上文查找到的生成url串, 把串的前缀修改为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;pre>&lt;code>gstaticInitter.asciz = &amp;quot;http://localhost:7777/yuepu/info?ypid=%d&amp;amp;sccode=%s&amp;amp;r1=%d&amp;amp;r2=%d&amp;amp;input=%s&amp;quot;;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>此处&lt;code>Sounds.swf&lt;/code>修改url后, 调用&lt;code>getURL&lt;/code>返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求&lt;/p>
&lt;/blockquote>
&lt;p>最后在乐谱工具中开启一个端口为&lt;code>7777&lt;/code>的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了&lt;/p>
&lt;blockquote>
&lt;p>乐谱工具是我基于&lt;code>C#&lt;/code>开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自&lt;code>localhost:7777&lt;/code>的HTTP请求&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 101; flex-basis: 243px">
&lt;a href="/posts/hack/xtan/flash/13.jpg" data-size="602x593">&lt;img src="/posts/hack/xtan/flash/13.jpg"
srcset="/posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_1024x0_resize_q75_box.jpg 1024w"
width="602"
height="593"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;hr>
&lt;h2 id="adobe-flash彻底停用后的补偿方案">Adobe Flash彻底停用后的补偿方案&lt;/h2>
&lt;p>过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具&lt;code>WinForm&lt;/code>的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, &lt;strong>直接导致&lt;code>Shockwave Flash&lt;/code>也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.&lt;/strong>&lt;/p>
&lt;p>既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的&lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的&lt;code>.swf&lt;/code>文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令&lt;/p>
&lt;pre>&lt;code>flashplayer_sa_debug.exe player.swf?id=1
&lt;/code>&lt;/pre>&lt;p>即可启动 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a> 并打开作为参数的 &lt;code>.swf&lt;/code> 文件, 在&lt;code>C#&lt;/code>中则可以使用&lt;code>Process&lt;/code>启动, 代码如下:&lt;/p>
&lt;pre>&lt;code>Process.Start(&amp;quot;flashplayer_sa_debug.exe&amp;quot;, &amp;quot;Main.swf?id=1&amp;quot;);
&lt;/code>&lt;/pre>&lt;p>但是在实际使用中, 发现通过命令行或者程序启动的 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a> 打开的&lt;code>player.swf&lt;/code>无法发送&lt;code>localhost&lt;/code>的网络请求, 弹窗报错如下:&lt;/p>
&lt;pre>&lt;code>SecurityError: Error #2119: 安全沙箱冲突
&lt;/code>&lt;/pre>&lt;p>但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求&lt;code>localhost&lt;/code>是因为他在用户文件夹下&lt;code>\AppData\Roaming\Macromediax\Flash Player\#Security\FlashPlayerTrust&lt;/code>创建了信任文件&lt;code>intellij_idea.cfg&lt;/code>, 文件内容即IDEA生成&lt;code>.swf&lt;/code>的完整文件夹路径&lt;/p>
&lt;pre>&lt;code>E:\flash\bin-debug
&lt;/code>&lt;/pre>&lt;p>&lt;strong>所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求&lt;code>localhost&lt;/code>了&lt;/strong>&lt;/p>
&lt;p>现在解决了乐谱无法播放的问题, 但是由于&lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>不支持&lt;code>ExternalInterface&lt;/code>, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用&lt;code>getURL&lt;/code>获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.&lt;/p>
&lt;p>首先删除会引起报错的&lt;code>player.swf&lt;/code>中使用&lt;code>ExternalInterface&lt;/code>定义的接口&lt;code>swfExtGetypURL&lt;/code>, 修改 &lt;code>myLoadSwf&lt;/code>中定义的回调函数 &lt;code>onSoundsReady&lt;/code>, 在此前初始化&lt;code>clib&lt;/code>的基础上加上调用&lt;code>getURL&lt;/code>返回的url, 并提取参数请求&lt;code>localhost:7777&lt;/code>, 修改后的代码如下:&lt;/p>
&lt;pre>&lt;code>internal static function onSoundsReady(arg1:Event) : void
{
swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
var loc2:* = loc1.getDefinition(&amp;quot;Sounds&amp;quot;) as Class;
CLib.clib = loc2.cLibInit();
//添加的部分
if(utils.Func.ypadId != 0) {
var url:* = CLib.getURL(utils.Func.ypadId);
var args:* = &amp;quot;?&amp;quot; + url.split(&amp;quot;?&amp;quot;)[1]
urlLoader3 = new flash.net.URLLoader();
urlLoader3.load(new flash.net.URLRequest(&amp;quot;http://localhost:7777/yuepu/fetch&amp;quot; + args));
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>utils.Func.ypadId&lt;/code>中存储了播放器启动时传入的乐谱ID参数&lt;/p>
&lt;/blockquote>
&lt;p>此时当&lt;code>clib&lt;/code>初始化完成之后, 会使用传入的乐谱ID直接调用&lt;code>getURL&lt;/code>, 截取返回url的参数部分, 再将参数通过HTTP请求上报到&lt;code>localhost:7777&lt;/code>. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题&lt;/p>
&lt;pre>&lt;code>//监听曲谱地址
if (httpListenerContext.Request.Url.LocalPath.Equals(&amp;quot;/yuepu/fetch&amp;quot;))
{
httpListenerContext.Request.QueryString[&amp;quot;ypid&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;sccode&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;r1&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;r2&amp;quot;];
...
}
&lt;/code>&lt;/pre>&lt;p>不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用&lt;code>Process&lt;/code>启动的指定&lt;code>WindowStyle&lt;/code>为&lt;code>ProcessWindowStyle.Hidden&lt;/code>就可以无感使用了&lt;/p>
&lt;pre>&lt;code>Process.Start(new ProcessStartInfo()
{
FileName = &amp;quot;flashplayer_sa_debug.exe&amp;quot;,
WindowStyle = ProcessWindowStyle.Hidden,//关键代码
Arguments = &amp;quot;Main.swf?id=64&amp;quot;,
})
&lt;/code>&lt;/pre>&lt;h2 id="至此已经彻底解决flash停用的影响了-但是仍然存在另一个问题-adobe禁用flash之后-某琴吧也对播放器进行了换代-停用了旧的flash播放器-改用安装版的exe播放器-同时exe播放器不再使用flash用的ypa2格式播放器文件-且删除了所有ypa2资源-并采用新的ypdx文件-新格式的文件flash无法播放-因此破解exe版本的播放器又被放在日程上了">至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的&lt;code>.ypa2&lt;/code>格式播放器文件, 且删除了所有&lt;code>.ypa2&lt;/code>资源, 并采用新的&lt;code>.ypdx&lt;/code>文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了&amp;hellip;&lt;/h2></description></item></channel></rss>