<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Acgnu+</title><link>/</link><description>Recent content on Acgnu+</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 23 Aug 2021 00:50:44 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>三星ONEUI修改记录</title><link>/posts/hack/xrom/oneui/</link><pubDate>Mon, 23 Aug 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xrom/oneui/</guid><description>&lt;img src="/posts/hack/xrom/oneui/cover.png" alt="Featured image of post 三星ONEUI修改记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>由于个人喜好, 比较喜欢直角屏的手机, 但市面上的手机放眼望去只有三星Note系列符合我的爱好, 遂购买三星Note 10御用, 然而这手机虽然造型是方方正正的, 但是UI却跟S系列一样到处都是圆角, 这让我很不舒服, 于是有了此文章&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>将系统UI的圆角修改为直角&lt;/p>
&lt;h2 id="三星oneui修改前后对比图">三星ONEUI修改前后对比图&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 95; flex-basis: 230px">
&lt;a href="/posts/hack/xrom/oneui/1.jpg" data-size="860x897">&lt;img src="/posts/hack/xrom/oneui/1.jpg"
srcset="/posts/hack/xrom/oneui/1_hu5d6c6fa8a81d3ddb6e788f41996e2afb_131804_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/1_hu5d6c6fa8a81d3ddb6e788f41996e2afb_131804_1024x0_resize_q75_box.jpg 1024w"
width="860"
height="897"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="基础知识">基础知识&lt;/h2>
&lt;p>&lt;strong>再开始之前, 首先需要了解一下基础知识&lt;/strong>&lt;/p>
&lt;p>&lt;strong>1. 安卓系统的UI构成&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>安卓系统的界面呈现都是由内置在系统的APP构成的, 其APP一般位于 &lt;code>/system/app&lt;/code> 和 &lt;code>/system/priv-app&lt;/code>, 还有一个系统APP引用的公共框架APP, 位于 &lt;code>/system/framework/framework-res.apk&lt;/code>, 部分系统例如&lt;a class="link" href="https://www.flyme.com/" target="_blank" rel="noopener"
>Flyme&lt;/a>在此目录还会有另外一个自己的框架APP, 命名通常以自家OS命名, 此处不作过多介绍, 界面中比较常见的APP如下&lt;/li>
&lt;li>&lt;code>framework-res.apk&lt;/code> 系统应用引用的界面, 例如提示信息弹窗&lt;/li>
&lt;li>&lt;code>SystemUI.apk&lt;/code> 系统通知栏界面, 通知弹窗界面&lt;/li>
&lt;li>&lt;code>Settings.apk&lt;/code> 系统设置界面, OneUI中此APP名称为 &lt;code>SecSettings.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Messages.apk&lt;/code> 短信界面, OneUI中为&lt;code>SamsungMessages_11.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Gallery.apk&lt;/code> 相册界面, OneUI中为&lt;code>SamsungGallery2018.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Dialer.apk&lt;/code> 拨号器,通话记录,联系人界面, OneUI中为&lt;code>SamsungDialer.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Clock.apk&lt;/code> 时钟,闹钟,计时器界面, OneUI中为&lt;code>ClockPackage.apk&lt;/code>&lt;/li>
&lt;li>&lt;code>Finder.apk&lt;/code> OneUI启动器(桌面)独有的搜索组件&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 安卓实现圆角的基本方式&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简单的实现安卓圆角可以通过&lt;code>&amp;lt;Shape&amp;gt;&lt;/code>来实现, 其中&lt;code>&amp;lt;Corner&amp;gt;&lt;/code>节点的属性&lt;code>xxxRadius&lt;/code>为关键属性, 例如&lt;code>bottomRightRadius&lt;/code>&lt;/li>
&lt;li>通常是APP开发者为了减少代码重复率, 会定义一个统一风格而定义的一个统一的资源文件&lt;code>dimens.xml&lt;/code>, 所有用到同样值的地方都会引用这个文件, 方便修改和风格统一&lt;/li>
&lt;/ul>
&lt;h2 id="开始修改">开始修改&lt;/h2>
&lt;p>首先修改&lt;code>framework-res.apk&lt;/code>, 由于需要对源码反编译和回编译, 所以需要用到安卓反编译工具 &lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>, 本人修改时使用的版本为&lt;code>v2.4.1&lt;/code>&lt;/p>
&lt;p>首先使用命令进行反编译&lt;/p>
&lt;pre>&lt;code>apktool d framework-res.apk
&lt;/code>&lt;/pre>&lt;p>中途没有错误则表示反编译成功&lt;/p>
&lt;p>&lt;figure style="flex-grow: 226; flex-basis: 542px">
&lt;a href="/posts/hack/xrom/oneui/4.jpg" data-size="441x195">&lt;img src="/posts/hack/xrom/oneui/4.jpg"
srcset="/posts/hack/xrom/oneui/4_huc7bba1b11dca74ac5172c1c46aa53bed_19048_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/4_huc7bba1b11dca74ac5172c1c46aa53bed_19048_1024x0_resize_q75_box.jpg 1024w"
width="441"
height="195"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>即可在当前目录生成反编译后的源码文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 304; flex-basis: 731px">
&lt;a href="/posts/hack/xrom/oneui/2.jpg" data-size="622x204">&lt;img src="/posts/hack/xrom/oneui/2.jpg"
srcset="/posts/hack/xrom/oneui/2_huf31c70d17decd1fd0d84732f531b198c_15664_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/2_huf31c70d17decd1fd0d84732f531b198c_15664_1024x0_resize_q75_box.jpg 1024w"
width="622"
height="204"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>目录简单介绍下&lt;/p>
&lt;ul>
&lt;li>&lt;code>assets&lt;/code> 为APP所用到的额外资源文件包, 可以是任何东西&lt;/li>
&lt;li>&lt;code>original&lt;/code> 顾名思义存放原始文件&lt;/li>
&lt;li>&lt;code>res&lt;/code> APP所用到的资源文件, 例如图标, 国际化文本, 图形, 布局文件等&lt;/li>
&lt;li>&lt;code>unknown&lt;/code> 工具无法解析的文件, 回编译后会按照原样编译进去&lt;/li>
&lt;li>&lt;code>AndroidManifest.xml&lt;/code> APP清单文件, 记录了版本号, 包名, 权限等重要信息&lt;/li>
&lt;li>&lt;code>apktool.yml&lt;/code> 记录了&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>回编译时需要参考的信息&lt;/li>
&lt;/ul>
&lt;p>可以看到在此&lt;code>framework-res.apk&lt;/code>中仅定义了资源文件, 并没有代码文件, 有代码的APP将在下文介绍, 在此&lt;code>framework-res.apk&lt;/code>中, 只需要关注&lt;code>res&lt;/code>文件夹下的资源文件就行, 我们把整个文件夹用IDEA打开, 然后根据圆角的基础知识, 直接简单粗暴先从搜索Radius开始&lt;/p>
&lt;p>&lt;figure style="flex-grow: 168; flex-basis: 403px">
&lt;a href="/posts/hack/xrom/oneui/3.jpg" data-size="548x326">&lt;img src="/posts/hack/xrom/oneui/3.jpg"
srcset="/posts/hack/xrom/oneui/3_huc0d768625189ac03a2f8780a6b2bc097_25101_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/3_huc0d768625189ac03a2f8780a6b2bc097_25101_1024x0_resize_q75_box.jpg 1024w"
width="548"
height="326"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现多处结果, 我们缩小一下搜索范围, 可以自己写一个小的安卓应用, 定义个圆角并尝试不同圆度, 根据多次测试观察到资源文件中圆度值为&lt;code>26.0dip&lt;/code>的比较符合, 因此搜索&lt;code>radius=&amp;quot;26.0dip&lt;/code>, 可以发现结果少了很多&lt;/p>
&lt;p>&lt;figure style="flex-grow: 185; flex-basis: 444px">
&lt;a href="/posts/hack/xrom/oneui/5.jpg" data-size="1108x598">&lt;img src="/posts/hack/xrom/oneui/5.jpg"
srcset="/posts/hack/xrom/oneui/5_hu9851f0a41ebb9e774553d5f13b36359e_93816_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/5_hu9851f0a41ebb9e774553d5f13b36359e_93816_1024x0_resize_q75_box.jpg 1024w"
width="1108"
height="598"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接着根据资源文件命名可以大致猜出这些对应的都是哪些部分的圆角, 例如&lt;code>notification_template_view_bg.xml&lt;/code>应该就是定义的通知模板背景, 根据经验这些都可以改成直角, &lt;strong>因此直接将所有的&lt;code>26.0dip&lt;/code>修改为&lt;code>0.0dip&lt;/code>&lt;/strong>&lt;/p>
&lt;p>之后, 为了更彻底的覆盖所有部分, 继续深入搜索, 只搜索&lt;code>26.0dip&lt;/code>, 发现更多结果&lt;/p>
&lt;p>&lt;figure style="flex-grow: 341; flex-basis: 819px">
&lt;a href="/posts/hack/xrom/oneui/6.jpg" data-size="570x167">&lt;img src="/posts/hack/xrom/oneui/6.jpg"
srcset="/posts/hack/xrom/oneui/6_hu54dfad81cf3ac8bdf8566165f6799c89_17839_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/6_hu54dfad81cf3ac8bdf8566165f6799c89_17839_1024x0_resize_q75_box.jpg 1024w"
width="570"
height="167"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>例如在&lt;code>dimens.xml&lt;/code>中定义的一些值为&lt;code>26.0dip&lt;/code>的数据, 需要仔细观察其&lt;code>name&lt;/code>, 因为不是所有值为&lt;code>26.0dip&lt;/code>的都需要修改, 例如第一行的&lt;code>car_seekbar_padding&lt;/code>看名字就知道是一个填充值, 这个是不需要修改的, 但是下面的&lt;code>sem_menu_popup_corner_radius&lt;/code>这种是需要修改的, 主要是经验和推测, 我们将这些需要修改的统统修改为&lt;code>0.0dip&lt;/code>&lt;/p>
&lt;p>所有圆角修改完之后, 开始回编译, 在反编译出来的目录下, 执行命令&lt;/p>
&lt;pre>&lt;code>apktool b framework-res
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 282; flex-basis: 677px">
&lt;a href="/posts/hack/xrom/oneui/7.jpg" data-size="500x177">&lt;img src="/posts/hack/xrom/oneui/7.jpg"
srcset="/posts/hack/xrom/oneui/7_huf413cbbe33fd397a6c45ad0312751bc7_12881_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/7_huf413cbbe33fd397a6c45ad0312751bc7_12881_1024x0_resize_q75_box.jpg 1024w"
width="500"
height="177"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>像这样没有错误说明回编译成功了, 打开&lt;code>framework-res&lt;/code>文件夹, 会发现里面多了两个文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 324; flex-basis: 778px">
&lt;a href="/posts/hack/xrom/oneui/8.jpg" data-size="581x179">&lt;img src="/posts/hack/xrom/oneui/8.jpg"
srcset="/posts/hack/xrom/oneui/8_hu48b4617a21b223dc5bee7c74403aeb16_15952_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/8_hu48b4617a21b223dc5bee7c74403aeb16_15952_1024x0_resize_q75_box.jpg 1024w"
width="581"
height="179"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;ul>
&lt;li>&lt;code>build&lt;/code> 回编译构建编译后的资源文件&lt;/li>
&lt;li>&lt;code>dist&lt;/code> 回编译后生成的APK文件&lt;/li>
&lt;/ul>
&lt;p>打开&lt;code>dist&lt;/code>文件夹, 可以看到生成的&lt;code>framework-res.apk&lt;/code>文件, 接下来需要将它替换到系统里去&lt;/p>
&lt;p>我们有四中方式替换&lt;/p>
&lt;ol>
&lt;li>使用电脑ADB工具执行命令行替换 (简单快捷, 有一定风险)&lt;/li>
&lt;li>复制到手机使用RE管理器替换 (风险较大)&lt;/li>
&lt;li>制作成单刷包替换 (安全性较好, 稍微麻烦一点)&lt;/li>
&lt;li>制作成ROM刷机替换 (性价比不高, 不考虑)&lt;/li>
&lt;/ol>
&lt;p>由于可能需要多次测试效果, 且有多个APK需要修改, 这里采用第一种方式, 需要ROOT&lt;/p>
&lt;p>步骤如下&lt;/p>
&lt;ol>
&lt;li>打开手机里的USB调试&lt;/li>
&lt;li>电脑安装手机的ADB驱动 (每个厂家的手机不一样), 装好后使用USB连接手机&lt;/li>
&lt;li>使用安卓ADB工具执行命令如下&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>//1.将新生成的APK复制到手机存储根目录
adb push framework-res.apk /sdcard/framework-res.apk
//2.执行shell
adb shell
//3.获取超级用户权限
su
//4.复制手机存储的framework-res.apk到系统框架目录
cp /sdcard/framework-res.apk /system/framework/framework-res.apk
//5.将复制进去的新APK重设rw-r-r权限
chmod 644 /system/framework/framework-res.apk
//6.退出shell
exit
//7.重启手机
adb reboot
&lt;/code>&lt;/pre>&lt;p>经过这一系列操作后, 如果没有出现意外, 手机重新开机后就可以看到修改后的效果了, 首先迎面而来的就是手机基础弹窗已经变成直角了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 129; flex-basis: 310px">
&lt;a href="/posts/hack/xrom/oneui/9.jpg" data-size="1080x834">&lt;img src="/posts/hack/xrom/oneui/9.jpg"
srcset="/posts/hack/xrom/oneui/9_hu19b5e1a56315d2e55023b018402d6291_55976_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/9_hu19b5e1a56315d2e55023b018402d6291_55976_1024x0_resize_q75_box.jpg 1024w"
width="1080"
height="834"
loading="lazy"
alt="image-9">
&lt;/a>
&lt;figcaption>image-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>注意!!! 通常为了防止意外情况发生导致无法开机,需要通过&lt;code>Recovery&lt;/code>备份一次系统,并将备份的系统复制到电脑以防万一,嫌麻烦的话至少也得有一份完整的刷机包,最好制作一份单刷包,如果修改后无法正常进入系统,推荐优先使用单刷包,如果单刷包无法生效,可以使用&lt;code>Recovery&lt;/code>还原系统,如果没有备份系统的,则使用完整的刷机包重刷,但将丢失所有数据(双清的情况),关于单刷包的制作,我将在文章尾部补充&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>但是这还远远不够, 接下来开始处理&lt;code>SecSettings.apk&lt;/code>, 仍然使用&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>按照上文命令进行反编译, 不过在此之前, 需要先给&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>安装&lt;code>framework-res.apk&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>由于系统APP会引用到框架APP, 因此需要给&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>安装框架APP, 才能继续反编译系统APP&lt;/p>
&lt;/blockquote>
&lt;p>通过如下命令安装&lt;code>framework-res.apk&lt;/code>&lt;/p>
&lt;pre>&lt;code>apktool if framework-res.apk
&lt;/code>&lt;/pre>&lt;p>安装之后就可以开始反编译&lt;code>SecSettings.apk&lt;/code>了, 反编译成功之后会发现相比较&lt;code>framework-res.apk&lt;/code>, 多出了几个文件夹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 279; flex-basis: 670px">
&lt;a href="/posts/hack/xrom/oneui/10.jpg" data-size="637x228">&lt;img src="/posts/hack/xrom/oneui/10.jpg"
srcset="/posts/hack/xrom/oneui/10_hu299a94972a09ca962e3e66aec83764b5_19408_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/10_hu299a94972a09ca962e3e66aec83764b5_19408_1024x0_resize_q75_box.jpg 1024w"
width="637"
height="228"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>smali&lt;/code>和&lt;code>smali_classesX&lt;/code> 就是应用的源代码文件, 为&lt;code>.smali&lt;/code>格式的Java字节码, 类似&lt;code>C&lt;/code>程序反编译出来的汇编代码, 我们先使用上文的知识将圆角值为&lt;code>26.0dip&lt;/code>的圆角修改为&lt;code>0.0dip&lt;/code>, 替换进系统后发现只有一部分界面的圆角变成了直角&lt;/p>
&lt;blockquote>
&lt;p>文章编辑于2021年8月, 系统修改于2020年7月, 当时没有保留截图, 现在也没有重新替换的必要, 因此这部分只能描述了&lt;/p>
&lt;/blockquote>
&lt;p>继续检查所有可能造成圆角的值为&lt;code>26.0dip&lt;/code>的&lt;code>.xml&lt;/code>文件, 仍然无法找到可能存在问题的部分, 此时将检查范围扩大到源代码文件, 为了方便阅读, 首先使用&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>反编译&lt;code>SecSettings.apk&lt;/code>, 并将反编译后的&lt;code>.java&lt;/code>源码导入IDEA进行观察, 搜索&lt;code>26&lt;/code>发现一个可疑的方法&lt;code>initRoundedCorner&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 256; flex-basis: 616px">
&lt;a href="/posts/hack/xrom/oneui/11.jpg" data-size="575x224">&lt;img src="/posts/hack/xrom/oneui/11.jpg"
srcset="/posts/hack/xrom/oneui/11_huec727d92949131b085630ae6fb19653f_16918_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/11_huec727d92949131b085630ae6fb19653f_16918_1024x0_resize_q75_box.jpg 1024w"
width="575"
height="224"
loading="lazy"
alt="image-11">
&lt;/a>
&lt;figcaption>image-11&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>此处推测应该是初始化一个圆度为&lt;code>26.0dip&lt;/code>的圆角, 而且这个类是很多类的父类, 应该是从代码层指定了圆角的圆度, 但是此时的&lt;code>.java&lt;/code>源码无法直接修改, 我们回到&lt;a class="link" href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="noopener"
>ApkTool&lt;/a>反编译出来而得到的&lt;code>.smali&lt;/code>源码, 根据类名方法名找到对应在&lt;code>.smali&lt;/code>代码中的&lt;code>initRoundedCorner&lt;/code>如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 188; flex-basis: 452px">
&lt;a href="/posts/hack/xrom/oneui/12.jpg" data-size="758x402">&lt;img src="/posts/hack/xrom/oneui/12.jpg"
srcset="/posts/hack/xrom/oneui/12_hu72d463b836552d68e8f98281bf1d334f_33255_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/12_hu72d463b836552d68e8f98281bf1d334f_33255_1024x0_resize_q75_box.jpg 1024w"
width="758"
height="402"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;code>smali&lt;/code>代码中的第一行也是定义了一个值为26的变量, 直接将&lt;code>0x26&lt;/code>改成&lt;code>0x0&lt;/code>, 然后回编译替换进系统观察效果, 此时可以看到界面基本上已经变成直角了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 47; flex-basis: 113px">
&lt;a href="/posts/hack/xrom/oneui/13.jpg" data-size="1080x2280">&lt;img src="/posts/hack/xrom/oneui/13.jpg"
srcset="/posts/hack/xrom/oneui/13_hu2910d42e718064d6d1e2e549aaa6cfcd_98010_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/13_hu2910d42e718064d6d1e2e549aaa6cfcd_98010_1024x0_resize_q75_box.jpg 1024w"
width="1080"
height="2280"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是进入某些功能的深层选项时会发现仍然有一小部分是圆角的, 不过仔细观察这部分的圆角角度值大概在&lt;code>15.0dip&lt;/code>到&lt;code>16.0dip&lt;/code>左右, 因此继续搜索圆角值为这些的部分, 根据名称将可能的地方修改为&lt;code>0.0dip&lt;/code>即可, 至此&lt;code>SecSettings.apk&lt;/code>全部改完&lt;/p>
&lt;p>接下来按照同样的步骤修改上文列出的剩余的系统APP即可&lt;/p>
&lt;h2 id="关于单刷包的制作">关于单刷包的制作&lt;/h2>
&lt;p>关于单刷包是什么, 有什么作用, 优缺点等网上已经有大量介绍, 此处不多说明, 仅介绍Note10下单刷包的制作&lt;/p>
&lt;p>&lt;strong>制作OneUI单刷包&lt;/strong>&lt;/p>
&lt;p>首先我们需要一个完整的&lt;code>.zip&lt;/code>刷机包, 以我的为例, 假定我们需要保留的文件为&lt;code>SecSettings.apk&lt;/code>, 需要删掉除&lt;code>SecSettings.apk&lt;/code>及其父文件夹以外的东西&lt;/p>
&lt;blockquote>
&lt;p>尽量不要解压修改, 有时候解压了修改再压缩回去会出现奇奇怪怪的问题, 导致签名无法识别, 无法刷入&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 187; flex-basis: 449px">
&lt;a href="/posts/hack/xrom/oneui/14.jpg" data-size="774x413">&lt;img src="/posts/hack/xrom/oneui/14.jpg"
srcset="/posts/hack/xrom/oneui/14_huec55957ac05bb0082d9337619d1bb6b6_40951_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/14_huec55957ac05bb0082d9337619d1bb6b6_40951_1024x0_resize_q75_box.jpg 1024w"
width="774"
height="413"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>例如此处图示的部分, 红框以外的都是可以删除的, 删完后如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 247; flex-basis: 593px">
&lt;a href="/posts/hack/xrom/oneui/15.jpg" data-size="517x209">&lt;img src="/posts/hack/xrom/oneui/15.jpg"
srcset="/posts/hack/xrom/oneui/15_hufce8372ee179d98e83f3be153d42f939_9963_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/15_hufce8372ee179d98e83f3be153d42f939_9963_1024x0_resize_q75_box.jpg 1024w"
width="517"
height="209"
loading="lazy"
alt="image-15">
&lt;/a>
&lt;figcaption>image-15&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>从原始刷机包删除目标以外的东西做成的单刷包通常用于备份恢复, 如果是为了替换成其他文件, 例如需要做成单刷修改后的&lt;code>SecSettings.apk&lt;/code>, 则删除多余文件后, 将修改后的&lt;code>SecSettings.apk&lt;/code>替换到单刷包里的对应目录即可&lt;/p>
&lt;/blockquote>
&lt;p>接下来需要修改刷机脚本, 原始的刷机脚本通常会做很多事, 但是单刷包不需要, 我们打开位于&lt;code>META-INF/com/google/android&lt;/code>下的&lt;code>updater-script&lt;/code>文件, 可以看到如下代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 103; flex-basis: 248px">
&lt;a href="/posts/hack/xrom/oneui/16.jpg" data-size="721x697">&lt;img src="/posts/hack/xrom/oneui/16.jpg"
srcset="/posts/hack/xrom/oneui/16_hudbfb903bb9a530e5c4b99a1c435d4a1d_67487_480x0_resize_q75_box.jpg 480w, /posts/hack/xrom/oneui/16_hudbfb903bb9a530e5c4b99a1c435d4a1d_67487_1024x0_resize_q75_box.jpg 1024w"
width="721"
height="697"
loading="lazy"
alt="image-16">
&lt;/a>
&lt;figcaption>image-16&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>脚本语言为&lt;code>updater-script&lt;/code>, 具体语法以及含义可以自行查阅, 此处不多作介绍, 我们将内容修改如下&lt;/p>
&lt;pre>&lt;code>ui_print(&amp;quot;Mounting system&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
mount(&amp;quot;ext4&amp;quot;, &amp;quot;EMMC&amp;quot;, &amp;quot;/dev/block/platform/soc/1d84000.ufshc/by-name/system&amp;quot;, &amp;quot;/system&amp;quot;);
ui_print(&amp;quot;Copying modules&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
package_extract_dir(&amp;quot;system&amp;quot;, &amp;quot;/system&amp;quot;);
ui_print(&amp;quot;Unmounting system&amp;quot;);
ui_print(&amp;quot;&amp;quot;);
unmount(&amp;quot;/system&amp;quot;);
show_progress(0.100000, 0);
&lt;/code>&lt;/pre>&lt;p>其中关键代码为 &lt;code>mount&lt;/code>挂载&lt;code>/system&lt;/code>为可写分区, &lt;code>package_extract_dir&lt;/code>将压缩包中&lt;code>system&lt;/code>文件夹全部复制到系统的&lt;code>/system&lt;/code>目录, &lt;code>unmount&lt;/code>取消挂载, 其他的例如&lt;code>ui_print&lt;/code>和&lt;code>show_progress&lt;/code>仅为提示作用, 修改完成后, 一个单刷包就制作完毕了, 可以像普通刷机一样直接刷进系统&lt;/p>
&lt;h2 id="结语">结语&lt;/h2>
&lt;p>由于安卓的开源特性使得安卓的可玩性和定制性非常高, 我所入手的每一部安卓手机都会进行ROOT并做一定程度的修改, 最开始的时候参考前辈的教程修改了系统APK的各种背景, 特效, 音效, 性能调优, 开机动画之类的, 随着手机UI越来越美观功能以及本人时间精力越来越有限, 现在对这种定制需要也已经越来越少了, 加之谷歌对安卓开源的策略调整以厂商的限制, 进行定制也越来越麻烦了, 但我仍会继续热爱安卓, 希望安卓开放的特性能够保持下去&lt;/p></description></item><item><title>某加APP破解去除认证和更新</title><link>/posts/hack/xplus/</link><pubDate>Thu, 10 Jun 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xplus/</guid><description>&lt;img src="/posts/hack/xplus/cover.png" alt="Featured image of post 某加APP破解去除认证和更新" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>由于某些需要, 进入某大楼的时候必须用他们物业指定的APP刷门禁, 我安装的时候是6.5.0版本, 这会儿启动速度也还可以, 也没太多花里胡哨的功能. 然而没过多久就迎来了一波强制版本更新, 更新后的版本启动速度慢到令人发指, 且增加了商城, 我就怒了, 区区门禁软件竟然这样肆意妄为, 开工!&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解某加(版本: 6.5.0)去除更新检查, 去掉实名认证&lt;/p>
&lt;blockquote>
&lt;p>某加在7.0.0版本更名为某品, 破解版本为6.5.0, 在此保持称呼其为某加&lt;/p>
&lt;/blockquote>
&lt;p>某加APP(版本6.5.0)界面&lt;/p>
&lt;p>&lt;figure style="flex-grow: 48; flex-basis: 116px">
&lt;a href="/posts/hack/xplus/1.jpg" data-size="428x879">&lt;img src="/posts/hack/xplus/1.jpg"
srcset="/posts/hack/xplus/1_hu2d95ec83e3d4d01752f97536c451549d_53428_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/1_hu2d95ec83e3d4d01752f97536c451549d_53428_1024x0_resize_q75_box.jpg 1024w"
width="428"
height="879"
loading="lazy"
alt="首页">
&lt;/a>
&lt;figcaption>首页&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先尝试使用Android反编译大杀器&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 打开&lt;code>Jadx&lt;/code>, 直接把某加安装包即&lt;code>.apk&lt;/code>文件拖进去, 发现软件没有加壳, 可以看到&lt;code>Jadx&lt;/code>顺利反编译出了某加的源码&lt;/p>
&lt;blockquote>
&lt;p>7.0版本开始APP加了壳, 没记错的话是某数字安全软件的壳, 脱壳过于麻烦于是使用6.5.0版本破解&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 146; flex-basis: 350px">
&lt;a href="/posts/hack/xplus/2.jpg" data-size="969x663">&lt;img src="/posts/hack/xplus/2.jpg"
srcset="/posts/hack/xplus/2_hu349652975c97a7c5fc2ef7ec56ba8aea_76881_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/2_hu349652975c97a7c5fc2ef7ec56ba8aea_76881_1024x0_resize_q75_box.jpg 1024w"
width="969"
height="663"
loading="lazy"
alt="JADX-源码">
&lt;/a>
&lt;figcaption>JADX-源码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;h2 id="禁用强制升级">禁用强制升级&lt;/h2>
&lt;p>首先根据弹窗文字&amp;quot;发现新版本&amp;quot;搜索代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 133; flex-basis: 320px">
&lt;a href="/posts/hack/xplus/3.jpg" data-size="516x387">&lt;img src="/posts/hack/xplus/3.jpg"
srcset="/posts/hack/xplus/3_huecfdf6804dc5656d1adc2869cf9b626f_14908_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/3_huecfdf6804dc5656d1adc2869cf9b626f_14908_1024x0_resize_q75_box.jpg 1024w"
width="516"
height="387"
loading="lazy"
alt="更新弹窗">
&lt;/a>
&lt;figcaption>更新弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现全文匹配的仅有一处, 位于布局文件&lt;code>dialog_check_update.xml&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 374; flex-basis: 897px">
&lt;a href="/posts/hack/xplus/4.jpg" data-size="606x162">&lt;img src="/posts/hack/xplus/4.jpg"
srcset="/posts/hack/xplus/4_hue4475e29c1a510e088031ebe8ac250a6_13878_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/4_hue4475e29c1a510e088031ebe8ac250a6_13878_1024x0_resize_q75_box.jpg 1024w"
width="606"
height="162"
loading="lazy"
alt="结果1">
&lt;/a>
&lt;figcaption>结果1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查找使用该布局文件的地方, 仅有一个类&lt;code>UpdateNoticeDialog&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 327; flex-basis: 786px">
&lt;a href="/posts/hack/xplus/5.jpg" data-size="845x258">&lt;img src="/posts/hack/xplus/5.jpg"
srcset="/posts/hack/xplus/5_hua4120d517d4567fa7454cfab4a402f5d_39648_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/5_hua4120d517d4567fa7454cfab4a402f5d_39648_1024x0_resize_q75_box.jpg 1024w"
width="845"
height="258"
loading="lazy"
alt="结果2">
&lt;/a>
&lt;figcaption>结果2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查看&lt;code>UpdateNoticeDialog&lt;/code>的代码, 可以看出这是一个自定义的对话框, 和APP显示的更新弹出框一致&lt;/p>
&lt;p>&lt;figure style="flex-grow: 264; flex-basis: 633px">
&lt;a href="/posts/hack/xplus/6.jpg" data-size="470x178">&lt;img src="/posts/hack/xplus/6.jpg"
srcset="/posts/hack/xplus/6_hue4b7d0705f3de3ef847d77bbc0819788_12612_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/6_hue4b7d0705f3de3ef847d77bbc0819788_12612_1024x0_resize_q75_box.jpg 1024w"
width="470"
height="178"
loading="lazy"
alt="结果3">
&lt;/a>
&lt;figcaption>结果3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接着查找使用到了&lt;code>UpdateNoticeDialog&lt;/code>类的地方, 发现多处引用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 236; flex-basis: 567px">
&lt;a href="/posts/hack/xplus/7.jpg" data-size="605x256">&lt;img src="/posts/hack/xplus/7.jpg"
srcset="/posts/hack/xplus/7_hu6e22dec133ef02ae33ed651f7531c52c_26368_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/7_hu6e22dec133ef02ae33ed651f7531c52c_26368_1024x0_resize_q75_box.jpg 1024w"
width="605"
height="256"
loading="lazy"
alt="结果4">
&lt;/a>
&lt;figcaption>结果4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>而APP弹出更新提示的时候, 我正位于APP的首页, 可以推断出&lt;code>HomeActivity&lt;/code>应该就是我要寻找的弹框处, 查看&lt;code>HomeActivity&lt;/code>的代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 108; flex-basis: 261px">
&lt;a href="/posts/hack/xplus/8.jpg" data-size="800x735">&lt;img src="/posts/hack/xplus/8.jpg"
srcset="/posts/hack/xplus/8_hu0d04ef7bf6568aeec0b7dc1a72e4ac07_78371_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/8_hu0d04ef7bf6568aeec0b7dc1a72e4ac07_78371_1024x0_resize_q75_box.jpg 1024w"
width="800"
height="735"
loading="lazy"
alt="首页">
&lt;/a>
&lt;figcaption>首页&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这里将&lt;code>UpdateNoticeDialog&lt;/code>定义为成员变量, 然后在&lt;code>checkUpdate&lt;/code>中对&lt;code>UpdateNoticeDialog&lt;/code>赋值, 且其他操作都位于&lt;code>checkUpdate&lt;/code>中, 现在看看&lt;code>checkUpdate&lt;/code>完整代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 140; flex-basis: 338px">
&lt;a href="/posts/hack/xplus/9.jpg" data-size="710x504">&lt;img src="/posts/hack/xplus/9.jpg"
srcset="/posts/hack/xplus/9_hu0a58a8411c4b0c4596961a24b6ef84f2_53536_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/9_hu0a58a8411c4b0c4596961a24b6ef84f2_53536_1024x0_resize_q75_box.jpg 1024w"
width="710"
height="504"
loading="lazy"
alt="检查更新">
&lt;/a>
&lt;figcaption>检查更新&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这个方法并没有做除了更新检查以外的事, 那么我只需要在&lt;code>Xposed&lt;/code>中替换这个方法就可以了, 这样当APP调用&lt;code>checkUpdate&lt;/code>时, 将执行我定义的方法, &lt;code>Xposed&lt;/code>模块代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.马赛克.马赛克.home.HomeActivity&amp;quot;, loadPackageParam.classLoader,
&amp;quot;checkUpdate&amp;quot;,
new XC_MethodReplacement() {
@Override
protected Object replaceHookedMethod(MethodHookParam param) throws Throwable {
return null;
}
});
&lt;/code>&lt;/pre>&lt;p>这里直接使用&lt;code>replaceHookedMethod&lt;/code>, 用自己定义的方法代替&lt;code>checkUpdate&lt;/code>执行, &lt;strong>写好后重新运行可以发现首页更新弹窗已经被屏蔽了.&lt;/strong>&lt;/p>
&lt;p>然而后来手贱不小心退出登录了, 再启动APP时发现登录的时候也有更新认证, 现在可行的方法有二, 一是找到登录界面, 用同样的方法去除更新, 但是这样一来繁琐, 二来他可能还有其他的地方有更新检查, 所以使用第二种方法&lt;/p>
&lt;p>根据Android开发文档可以得知, &lt;strong>可以在APP的&lt;code>AndroidManifest.xml&lt;/code>中可以定义当前APP的版本号, 然后可以在&lt;code>Java&lt;/code>代码中使用&lt;code>PackageInfo&lt;/code>来获得当前APP的版本信息, 而定义版本主要分为版本号&lt;code>versionCode&lt;/code>和版本名&lt;code>versionName&lt;/code>, 一般使用&lt;code>versionCode&lt;/code>大小来判断是否需要更新, 而&lt;code>versionName&lt;/code>则主要用作展示&lt;/strong>, 查看某加APP的&lt;code>AndroidManifest.xml&lt;/code>文件, 发现其版本定义如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 451; flex-basis: 1082px">
&lt;a href="/posts/hack/xplus/10.jpg" data-size="546x121">&lt;img src="/posts/hack/xplus/10.jpg"
srcset="/posts/hack/xplus/10_hu96277694f98aa3c45610a16b3673614a_9450_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/10_hu96277694f98aa3c45610a16b3673614a_9450_1024x0_resize_q75_box.jpg 1024w"
width="546"
height="121"
loading="lazy"
alt="版本">
&lt;/a>
&lt;figcaption>版本&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>那么一般的做法只要将&lt;code>versionCode&lt;/code>的值修改成足够大, 就能达到免更新的目的, 但是实际操作下来发现这APP比较鸡贼, 判断版本是否更新并不是简单通过&lt;code>versionCode&lt;/code>大小来判断, 不过当时为了偷懒也没有进一步分析版本检查代码, 我只知道最新版本的&lt;code>versionName&lt;/code>是7.0.0, 所以直接使用&lt;code>Xposed&lt;/code>将返回的&lt;code>versionName&lt;/code>修改为固定的7.0.0&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;android.app.ApplicationPackageManager&amp;quot;, loadPackageParam.classLoader,
&amp;quot;getPackageInfo&amp;quot;,
String.class,
int.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
PackageInfo packageInfo = (PackageInfo) param.getResult();
if (null != packageInfo &amp;amp;&amp;amp; getTargetPackage().equals(packageInfo.packageName)) {
packageInfo.versionCode = Integer.MAX_VALUE;
packageInfo.versionName = &amp;quot;7.0.0&amp;quot;;
}
}
});
&lt;/code>&lt;/pre>&lt;p>此处使用&lt;code>Xposed&lt;/code>直接&lt;code>Hook&lt;/code> Android系统的包管理器, 当某加需要获取版本名时, 直接返回7.0.0, 不过这样做的缺点是如果某加未来版本更新到7.0.0以上时, 需要修改代码, 然而从2020年12月破解至今, 某加都没有再发布过版本更新, 省了我不少事&lt;/p>
&lt;p>&lt;strong>至此重新打包运行, 发现登录的更新检查也被去除了&lt;/strong>&lt;/p>
&lt;p>然而新的风暴又出现了, 由于刚才的不慎退出, 现在需要重新上传实名认证资料了, 包括身份证号和照片, 由于我之前已经填过一次, 而且上传后需要重新审核, 所以不愿意再次填写, 于是开始寻找认证部分的代码&lt;/p>
&lt;h2 id="跳过实名认证">跳过实名认证&lt;/h2>
&lt;p>认证弹窗如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 136px">
&lt;a href="/posts/hack/xplus/11.jpg" data-size="530x931">&lt;img src="/posts/hack/xplus/11.jpg"
srcset="/posts/hack/xplus/11_hu96f99dea830a15ed6bd30d3c0d69bfe0_47957_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/11_hu96f99dea830a15ed6bd30d3c0d69bfe0_47957_1024x0_resize_q75_box.jpg 1024w"
width="530"
height="931"
loading="lazy"
alt="实名认证弹窗">
&lt;/a>
&lt;figcaption>实名认证弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>当我点击右下角的显示门禁卡二维码按钮的时候, 就会弹出认证弹窗, 我们知道&lt;code>Activity&lt;/code>会通过&lt;code>setContentView&lt;/code>加载一个布局文件, 此页面为APP首页, 所以在&lt;code>HomeActivity&lt;/code>中搜索&lt;code>setContentView&lt;/code>, 发现并没有结果&lt;/p>
&lt;p>&lt;figure style="flex-grow: 318; flex-basis: 765px">
&lt;a href="/posts/hack/xplus/12.jpg" data-size="679x213">&lt;img src="/posts/hack/xplus/12.jpg"
srcset="/posts/hack/xplus/12_hu82614e200c2ca9e6d3cff5f090370c74_23860_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/12_hu82614e200c2ca9e6d3cff5f090370c74_23860_1024x0_resize_q75_box.jpg 1024w"
width="679"
height="213"
loading="lazy"
alt="首页2">
&lt;/a>
&lt;figcaption>首页2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是&lt;code>HomeActivity&lt;/code>继承自&lt;code>BaseActivity_2019_8_22&lt;/code>, 于是在父类中找到了&lt;code>setContentView&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 251; flex-basis: 602px">
&lt;a href="/posts/hack/xplus/13.jpg" data-size="663x264">&lt;img src="/posts/hack/xplus/13.jpg"
srcset="/posts/hack/xplus/13_huc3f0c228985f9b08ea6c4fb72996e418_31164_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/13_huc3f0c228985f9b08ea6c4fb72996e418_31164_1024x0_resize_q75_box.jpg 1024w"
width="663"
height="264"
loading="lazy"
alt="设置布局">
&lt;/a>
&lt;figcaption>设置布局&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这里加载的布局是&lt;code>activity_only_linear_layout.xml&lt;/code>, 查看这个布局文件, 里面的代码非常简单&lt;/p>
&lt;p>&lt;figure style="flex-grow: 332; flex-basis: 798px">
&lt;a href="/posts/hack/xplus/14.jpg" data-size="892x268">&lt;img src="/posts/hack/xplus/14.jpg"
srcset="/posts/hack/xplus/14_hu18df4b0c8e4b20856bb7a5a1a40ccba6_38292_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/14_hu18df4b0c8e4b20856bb7a5a1a40ccba6_38292_1024x0_resize_q75_box.jpg 1024w"
width="892"
height="268"
loading="lazy"
alt="布局">
&lt;/a>
&lt;figcaption>布局&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>根据名称可以很容易的推断出id为&lt;code>fab_show_qr_code&lt;/code>的按钮组件就是首页显示二维码的组件, 搜索这个id查看他的点击事件&lt;/p>
&lt;p>&lt;figure style="flex-grow: 143; flex-basis: 344px">
&lt;a href="/posts/hack/xplus/15.jpg" data-size="724x504">&lt;img src="/posts/hack/xplus/15.jpg"
srcset="/posts/hack/xplus/15_hub70308bebefecd263604d35c1664b3cc_48846_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/15_hub70308bebefecd263604d35c1664b3cc_48846_1024x0_resize_q75_box.jpg 1024w"
width="724"
height="504"
loading="lazy"
alt="点击事件">
&lt;/a>
&lt;figcaption>点击事件&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>根据判断逻辑, 如果&lt;code>CacheUtils.getStatus()&lt;/code>返回为1, 就展示二维码弹窗, 不为1则执行&lt;code>checkStatus()&lt;/code>, 以防万一, 看看&lt;code>checkStatus()&lt;/code>的代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 390; flex-basis: 936px">
&lt;a href="/posts/hack/xplus/16.jpg" data-size="730x187">&lt;img src="/posts/hack/xplus/16.jpg"
srcset="/posts/hack/xplus/16_hu30e72add66bab6b7193b471be38a9d9a_17295_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/16_hu30e72add66bab6b7193b471be38a9d9a_17295_1024x0_resize_q75_box.jpg 1024w"
width="730"
height="187"
loading="lazy"
alt="检查状态">
&lt;/a>
&lt;figcaption>检查状态&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>显然&lt;code>checkIdentityStatus()&lt;/code>这名字就很直白的告诉我这个就是用来检查身份认证的了, 在回来看看&lt;code>CacheUtils.getStatus()&lt;/code>代码如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 294; flex-basis: 706px">
&lt;a href="/posts/hack/xplus/17.jpg" data-size="645x219">&lt;img src="/posts/hack/xplus/17.jpg"
srcset="/posts/hack/xplus/17_hub29dfd1774778c08e0d4594a749914d2_20243_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/17_hub29dfd1774778c08e0d4594a749914d2_20243_1024x0_resize_q75_box.jpg 1024w"
width="645"
height="219"
loading="lazy"
alt="获取状态">
&lt;/a>
&lt;figcaption>获取状态&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这里的逻辑也很简单, 就是从登录信息中获取认证状态, 那么我只要用&lt;code>Xposed&lt;/code>将&lt;code>getStatus()&lt;/code>的返回值修改为1就可以了, &lt;code>Xposed&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.excegroup.community.utils.CacheUtils&amp;quot;, loadPackageParam.classLoader, &amp;quot;getStatus&amp;quot;,
String.class,
new XC_MethodHook() {
@Override
protected void afterHookedMethod(MethodHookParam param) throws Throwable {
param.setResult(&amp;quot;1&amp;quot;);
}
});
&lt;/code>&lt;/pre>&lt;p>&lt;code>Hook&lt;/code>代码将在&lt;code>getStatus()&lt;/code>执行之后执行, 将其返回值为修改为1, 现在重新运行, &lt;strong>程序一切正常, 也没有身份认证弹窗了, 点击显示二维码按钮正常显示门禁二维码&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 64; flex-basis: 155px">
&lt;a href="/posts/hack/xplus/18.jpg" data-size="524x811">&lt;img src="/posts/hack/xplus/18.jpg"
srcset="/posts/hack/xplus/18_hu8be23d8c5d36ba9786790ce525914933_44600_480x0_resize_q75_box.jpg 480w, /posts/hack/xplus/18_hu8be23d8c5d36ba9786790ce525914933_44600_1024x0_resize_q75_box.jpg 1024w"
width="524"
height="811"
loading="lazy"
alt="ok">
&lt;/a>
&lt;figcaption>ok&lt;/figcaption>
&lt;/figure>&lt;/p></description></item><item><title>某鱼APP破解去广告</title><link>/posts/hack/xfish/</link><pubDate>Tue, 08 Jun 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xfish/</guid><description>&lt;img src="/posts/hack/xfish/cover.png" alt="Featured image of post 某鱼APP破解去广告" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>作为一个家徒四壁的打工人, 在某鱼上购买二手的闲置商品便成了我实现梦想的捷径, 但某鱼经过多次升级改版已经相当流氓, 在我搜索出想要的商品的结果页, 嵌入识别度很低的广告, 导致我经常手滑点错, 然后直接跳转启动某宝, 某宝的启动速度又慢的令人发指, 最终还得按下多次返回才能再次回到某鱼的搜索结果页, 忍无可忍的我只能对它做一些不可描述的事了&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解某鱼(版本: 6.7.40)并去除搜索结果页的广告, 同时去掉每次启动就弹窗的恼人的更新提示&lt;/p>
&lt;h2 id="某鱼的搜索结果页">某鱼的搜索结果页&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 134px">
&lt;a href="/posts/hack/xfish/adpage.jpg" data-size="540x961">&lt;img src="/posts/hack/xfish/adpage.jpg"
srcset="/posts/hack/xfish/adpage_hu1ba7e09bc24973772dcedd1129f840e8_86307_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/adpage_hu1ba7e09bc24973772dcedd1129f840e8_86307_1024x0_resize_q75_box.jpg 1024w"
width="540"
height="961"
loading="lazy"
alt="某鱼广告">
&lt;/a>
&lt;figcaption>某鱼广告&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>PS:一个屏幕总共就6个展位, 某鱼你这三个广告位良心不会痛吗&lt;/p>
&lt;/blockquote>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先尝试使用Android反编译大杀器&lt;a class="link" href="https://github.com/skylot/jadx" target="_blank" rel="noopener"
>Jadx&lt;/a>, 打开&lt;code>Jadx&lt;/code>, 直接把某鱼安装包即&lt;code>.apk&lt;/code>文件拖进去, 发现软件没有加壳, 可以看到&lt;code>Jadx&lt;/code>顺利反编译出了某鱼的源码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 139; flex-basis: 334px">
&lt;a href="/posts/hack/xfish/jadx_source.jpg" data-size="1173x842">&lt;img src="/posts/hack/xfish/jadx_source.jpg"
srcset="/posts/hack/xfish/jadx_source_hud0af3715194ff4882a261e5347d833be_127929_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/jadx_source_hud0af3715194ff4882a261e5347d833be_127929_1024x0_resize_q75_box.jpg 1024w"
width="1173"
height="842"
loading="lazy"
alt="JADX-源码">
&lt;/a>
&lt;figcaption>JADX-源码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>直接按 &lt;code>Ctrl + S&lt;/code> 将源码全部保存, 然后导入&lt;code>IDEA&lt;/code>, 开始分析代码&lt;/p>
&lt;p>&lt;strong>首先从输入搜索目标后, 点击搜索的按钮开始入手&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 249; flex-basis: 599px">
&lt;a href="/posts/hack/xfish/search.jpg" data-size="537x215">&lt;img src="/posts/hack/xfish/search.jpg"
srcset="/posts/hack/xfish/search_hubb017e4f37f205bfbcd52d21910b75ab_11320_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/search_hubb017e4f37f205bfbcd52d21910b75ab_11320_1024x0_resize_q75_box.jpg 1024w"
width="537"
height="215"
loading="lazy"
alt="搜索面板">
&lt;/a>
&lt;figcaption>搜索面板&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>在代码中查找&amp;quot;搜索&amp;quot;关键字, 发现有多处匹配, 结合搜索面板底下的历史搜索布局, 推测该面板的布局文件应该是&lt;code>search_mid.xml&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 212; flex-basis: 510px">
&lt;a href="/posts/hack/xfish/searchlayout.jpg" data-size="1078x507">&lt;img src="/posts/hack/xfish/searchlayout.jpg"
srcset="/posts/hack/xfish/searchlayout_hu165f087e67dd8c3f20528ecb83d1223f_83048_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchlayout_hu165f087e67dd8c3f20528ecb83d1223f_83048_1024x0_resize_q75_box.jpg 1024w"
width="1078"
height="507"
loading="lazy"
alt="面板代码">
&lt;/a>
&lt;figcaption>面板代码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>搜索布局文件引用的地方, 发现其在&lt;code>SearchMidActivity&lt;/code>中被使用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 342; flex-basis: 821px">
&lt;a href="/posts/hack/xfish/uselayout.jpg" data-size="606x177">&lt;img src="/posts/hack/xfish/uselayout.jpg"
srcset="/posts/hack/xfish/uselayout_huf0a2434a3d7d0179055128c7c7a27089_13700_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/uselayout_huf0a2434a3d7d0179055128c7c7a27089_13700_1024x0_resize_q75_box.jpg 1024w"
width="606"
height="177"
loading="lazy"
alt="布局使用">
&lt;/a>
&lt;figcaption>布局使用&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再查看布局文件代码, 搜索按钮的组件ID为&lt;code>search_button&lt;/code>, 在&lt;code>SearchMidActivity&lt;/code>中查找相关引用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 316; flex-basis: 758px">
&lt;a href="/posts/hack/xfish/searchbtn1.jpg" data-size="351x111">&lt;img src="/posts/hack/xfish/searchbtn1.jpg"
srcset="/posts/hack/xfish/searchbtn1_hud7caf3cc5e731a5a19c2db74ba6f7cd8_6010_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn1_hud7caf3cc5e731a5a19c2db74ba6f7cd8_6010_1024x0_resize_q75_box.jpg 1024w"
width="351"
height="111"
loading="lazy"
alt="搜索点击1">
&lt;/a>
&lt;figcaption>搜索点击1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 277; flex-basis: 667px">
&lt;a href="/posts/hack/xfish/searchbtn2.jpg" data-size="795x286">&lt;img src="/posts/hack/xfish/searchbtn2.jpg"
srcset="/posts/hack/xfish/searchbtn2_hu43e90636119c85769bcd2cb8b226da7a_24664_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn2_hu43e90636119c85769bcd2cb8b226da7a_24664_1024x0_resize_q75_box.jpg 1024w"
width="795"
height="286"
loading="lazy"
alt="搜索点击2">
&lt;/a>
&lt;figcaption>搜索点击2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出按钮点击后, 首先会调用&lt;code>searchKeyAction&lt;/code>, 再经过层层调用最后到达&lt;code>searchNormal&lt;/code>, 之后就会通过 &lt;code>gotoResultActivity&lt;/code> 跳转到结果页, 继续跟踪&lt;code>gotoResultActivity&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 700; flex-basis: 1680px">
&lt;a href="/posts/hack/xfish/searchbtn3.jpg" data-size="525x75">&lt;img src="/posts/hack/xfish/searchbtn3.jpg"
srcset="/posts/hack/xfish/searchbtn3_hu5fb2147c87591b6c85c08e2046a0c2df_6451_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn3_hu5fb2147c87591b6c85c08e2046a0c2df_6451_1024x0_resize_q75_box.jpg 1024w"
width="525"
height="75"
loading="lazy"
alt="搜索点击3">
&lt;/a>
&lt;figcaption>搜索点击3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>此处出现&lt;code>searchresult&lt;/code>字符, 搜索这个字符&lt;/p>
&lt;p>&lt;figure style="flex-grow: 469; flex-basis: 1127px">
&lt;a href="/posts/hack/xfish/searchbtn4.jpg" data-size="780x166">&lt;img src="/posts/hack/xfish/searchbtn4.jpg"
srcset="/posts/hack/xfish/searchbtn4_hu3064fae03e259149ff91124b7637e5f8_29435_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/searchbtn4_hu3064fae03e259149ff91124b7637e5f8_29435_1024x0_resize_q75_box.jpg 1024w"
width="780"
height="166"
loading="lazy"
alt="搜索点击4">
&lt;/a>
&lt;figcaption>搜索点击4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出这个字符串对应的页面应该是 &lt;code>SearchResultActivity&lt;/code>, 打开这个类之后一眼看不出什么重要的东西, 然后线索就这么中断了&lt;/p>
&lt;p>线索中断之后, 可以用&lt;code>Xposed&lt;/code>对某些可疑方法&lt;code>Hook&lt;/code>, 然后通过打印调用堆栈的方法, 继续分析, 比如此我找到的&lt;code>SearchResultInterrupter&lt;/code>中的&lt;code>checkInterrupt&lt;/code>方法&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>Xposed&lt;/code>是一款&lt;code>Android&lt;/code>底层的框架, 能够从虚拟机层拦截系统所有执行代码, 而&lt;code>Xposed&lt;/code>模块是使用&lt;code>Xposed&lt;/code>提供的&lt;code>SDK&lt;/code>所开发的&lt;code>Android&lt;/code>应用, 能够借助&lt;code>Xposed&lt;/code>实现对所有关心代码的拦截, 详情请戳&lt;a class="link" href="https://repo.xposed.info/" target="_blank" rel="noopener"
>Xposed官网&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>Throwable ex = new Throwable();
StackTraceElement[] stackElements = ex.getStackTrace();
if (stackElements != null) {
MyLog.log(&amp;quot;调用堆栈:--------------------&amp;quot;, true);
for (int i = 0; i &amp;lt; stackElements.length; i++) {
MyLog.log(stackElements[i].getClassName() + &amp;quot; -&amp;gt; &amp;quot; +
stackElements[i].getMethodName() + &amp;quot;()&amp;quot;
, true);
}
}
&lt;/code>&lt;/pre>&lt;p>不过这样比较麻烦而且也不好找. 于是换个思路, 安装&lt;code>Xposed&lt;/code>模块&lt;a class="link" href="https://github.com/Palatis/XAppDebug" target="_blank" rel="noopener"
>XAppDebug&lt;/a>, 为某鱼强制开启&lt;code>Debug&lt;/code>模式, 此时查看控制台会显示所有某鱼打印的日志信息, 现在控制台显示了包括网络请求在内的日志信息&lt;/p>
&lt;p>&lt;figure style="flex-grow: 379; flex-basis: 911px">
&lt;a href="/posts/hack/xfish/motp.jpg" data-size="1136x299">&lt;img src="/posts/hack/xfish/motp.jpg"
srcset="/posts/hack/xfish/motp_hu728bdb3602c9c0a190a3b046fde1f8dd_69023_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/motp_hu728bdb3602c9c0a190a3b046fde1f8dd_69023_1024x0_resize_q75_box.jpg 1024w"
width="1136"
height="299"
loading="lazy"
alt="MTOP">
&lt;/a>
&lt;figcaption>MTOP&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>最终找到可疑类&lt;code>MtopResponse&lt;/code>, 分析代码可以推测这个类应该是一个封装了网络响应的类, 其成员变量&lt;code>bytedata&lt;/code>是主要数据源, &lt;code>bytedata&lt;/code>将会被转换成&lt;code>dataJsonObject&lt;/code>的&lt;code>JSON&lt;/code>对象储存, 然后被使用, 因此找到&lt;code>bytedata&lt;/code>赋值的方法&lt;code>setBytedata&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 287; flex-basis: 691px">
&lt;a href="/posts/hack/xfish/rep.jpg" data-size="478x166">&lt;img src="/posts/hack/xfish/rep.jpg"
srcset="/posts/hack/xfish/rep_huaa9da268be2d331c855d2c964a90ed3f_10820_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/rep_huaa9da268be2d331c855d2c964a90ed3f_10820_1024x0_resize_q75_box.jpg 1024w"
width="478"
height="166"
loading="lazy"
alt="响应模型">
&lt;/a>
&lt;figcaption>响应模型&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>破解时间于2020年8月, 文章编辑时间为2021年6月, 我也不记得当初是不是这样找到&lt;code>MtopResponse&lt;/code>类的, 没有记录下来是我的失误也是我的损失, 现在能找到这个类是因为当时开发&lt;code>Xposed&lt;/code>模块中的代码有这一段. 如果某天我突然想起来了或者有兴致花时间重新找的话, 会回来补充的&lt;/p>
&lt;/blockquote>
&lt;p>使用&lt;code>Xposed&lt;/code>拦截此函数, 并打印入参&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;mtopsdk.mtop.domain.MtopResponse&amp;quot;, loadPackageParam.classLoader,
&amp;quot;setBytedata&amp;quot;,
byte[].class,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
String content = new String((byte[]) param.args[0]);
MyLog.log(content);
}
});
&lt;/code>&lt;/pre>&lt;p>得到入参截取如下&lt;/p>
&lt;pre>&lt;code>&amp;quot;data&amp;quot;: {
&amp;quot;item&amp;quot;: {
...
&amp;quot;main&amp;quot;: {
&amp;quot;clickParam&amp;quot;: {
&amp;quot;arg1&amp;quot;: &amp;quot;Item&amp;quot;,
&amp;quot;args&amp;quot;: {
...
&amp;quot;tagname&amp;quot;: &amp;quot;全新\/极好\/298人想要&amp;quot;,
&amp;quot;wantNum&amp;quot;: &amp;quot;298&amp;quot;,
&amp;quot;id&amp;quot;: &amp;quot;619312410203&amp;quot;,
&amp;quot;tag&amp;quot;: &amp;quot;new\/credit-6\/wantnum-298&amp;quot;,
&amp;quot;scm&amp;quot;: &amp;quot;1007.32845.224895.0&amp;quot;,
&amp;quot;publishTime&amp;quot;: &amp;quot;1590461455000&amp;quot;,
&amp;quot;i2i&amp;quot;: &amp;quot;相似&amp;quot;,
&amp;quot;search_tab_from&amp;quot;: null,
&amp;quot;item_id&amp;quot;: &amp;quot;619312410203&amp;quot;,
&amp;quot;biz_type&amp;quot;: &amp;quot;item&amp;quot;, //破解重点
&amp;quot;q&amp;quot;: &amp;quot;10700k&amp;quot;,
...
},
&amp;quot;page&amp;quot;: &amp;quot;Page_xySearchResult&amp;quot;
},
...
}
}
...
}
...
&lt;/code>&lt;/pre>&lt;p>此处截取了一条记录展示, 实际拦截到的参数中是一个数组, 包含本次结果页的所有商品, 其中就包括了搜索的商品, 广告商品, 推荐商品等, 通过对比发现, &lt;strong>搜索的商品数据在节点&lt;code>args&lt;/code> &amp;gt; &lt;code>biz_type&lt;/code> 的取值为 &lt;code>item&lt;/code>, 而广告等商品取值为&lt;code>ad&lt;/code>, &lt;code>Bagtag&lt;/code>, &lt;code>聚合卡片&lt;/code>&lt;/strong>, 那么接下来要做的事就很明确了, &lt;strong>解析这个字符串, 如果发现是广告商品则从数据中删除这条数据&lt;/strong>, 修改对&lt;code>setBytedate&lt;/code>的&lt;code>Hook&lt;/code>代码如下&lt;/p>
&lt;pre>&lt;code>...
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
if (null == param.args[0] || ((byte[]) param.args[0]).length == 0) {
return;
}
String content = new String((byte[]) param.args[0]);
JSONObject jsonContent = new JSONObject(content);
JSONObject jsonData = jsonContent.optJSONObject(&amp;quot;data&amp;quot;);
if (null == jsonData || !jsonData.has(&amp;quot;resultList&amp;quot;)) {
return;
}
JSONArray resultList = jsonData.getJSONArray(&amp;quot;resultList&amp;quot;);
List&amp;lt;String&amp;gt; filterList = Arrays.asList(&amp;quot;ad&amp;quot;, &amp;quot;Bagtag&amp;quot;, &amp;quot;聚合卡片&amp;quot;);
for (int i = 0; i &amp;lt; resultList.length(); i++) {
JSONObject listItem = resultList.getJSONObject(i);
String bizType = listItem.getJSONObject(&amp;quot;data&amp;quot;).getJSONObject(&amp;quot;item&amp;quot;)
.getJSONObject(&amp;quot;main&amp;quot;).getJSONObject(&amp;quot;clickParam&amp;quot;).getJSONObject(&amp;quot;args&amp;quot;)
.getString(&amp;quot;biz_type&amp;quot;);
if (filterList.contains(bizType)) {
if (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.KITKAT) {
resultList.remove(i);
i--;
}
}
}
param.args[0] = jsonContent.toString().getBytes();
}
...
&lt;/code>&lt;/pre>&lt;p>上述代码首先将&lt;code>byte&lt;/code>数组转换为&lt;code>json&lt;/code>对象, 然后遍历所有商品, 将找到的广告商品移除, 再将处理过后的字符串重新转换为&lt;code>byte&lt;/code>数组, 最后赋值给原始参数, 这样当某鱼实际代码&lt;code>setBytedata&lt;/code>得到的参数将会是我修改后的参数. 编译验证后可以看到广告已经不会再显示了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 56; flex-basis: 136px">
&lt;a href="/posts/hack/xfish/noadresult.jpg" data-size="529x933">&lt;img src="/posts/hack/xfish/noadresult.jpg"
srcset="/posts/hack/xfish/noadresult_hufb7fc091ad8dd52f3bb83e2bc584be96_75816_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/noadresult_hufb7fc091ad8dd52f3bb83e2bc584be96_75816_1024x0_resize_q75_box.jpg 1024w"
width="529"
height="933"
loading="lazy"
alt="哇塞">
&lt;/a>
&lt;figcaption>哇塞&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="禁用恼人的升级弹窗">禁用恼人的升级弹窗&lt;/h2>
&lt;p>&lt;strong>由于本人不爱更新, 且破解后如果更新版本, 可能导致破解失效, 所以必须禁用更新&lt;/strong>&lt;/p>
&lt;p>首先根据弹窗文字搜索代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 309px">
&lt;a href="/posts/hack/xfish/updateprop.jpg" data-size="487x378">&lt;img src="/posts/hack/xfish/updateprop.jpg"
srcset="/posts/hack/xfish/updateprop_huc83cba95d5fbda156357bc25e87590dc_41270_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updateprop_huc83cba95d5fbda156357bc25e87590dc_41270_1024x0_resize_q75_box.jpg 1024w"
width="487"
height="378"
loading="lazy"
alt="更新弹窗">
&lt;/a>
&lt;figcaption>更新弹窗&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>发现仅有一处, 位于&lt;code>BaseUpgradeHandler&lt;/code>类的&lt;code>onUpgradeNeed()&lt;/code>方法&lt;/p>
&lt;p>&lt;figure style="flex-grow: 136; flex-basis: 327px">
&lt;a href="/posts/hack/xfish/updatecode.jpg" data-size="609x446">&lt;img src="/posts/hack/xfish/updatecode.jpg"
srcset="/posts/hack/xfish/updatecode_hue08c2e2c8268d22c9b70d5b029bd39b2_29411_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecode_hue08c2e2c8268d22c9b70d5b029bd39b2_29411_1024x0_resize_q75_box.jpg 1024w"
width="609"
height="446"
loading="lazy"
alt="更新代码">
&lt;/a>
&lt;figcaption>更新代码&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>跟踪方法调用, 在&lt;code>com.马赛克.马赛克fish.upgrade.traceable.Upgrade&lt;/code>类的&lt;code>c&lt;/code>方法中被调用, 而&lt;code>c&lt;/code>则被&lt;code>b&lt;/code>调用&lt;/p>
&lt;p>&lt;figure style="flex-grow: 189; flex-basis: 454px">
&lt;a href="/posts/hack/xfish/updatecall1.jpg" data-size="705x372">&lt;img src="/posts/hack/xfish/updatecall1.jpg"
srcset="/posts/hack/xfish/updatecall1_hu44c789f25140b4297b45caa6517061ba_31907_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecall1_hu44c789f25140b4297b45caa6517061ba_31907_1024x0_resize_q75_box.jpg 1024w"
width="705"
height="372"
loading="lazy"
alt="更新1">
&lt;/a>
&lt;figcaption>更新1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 290; flex-basis: 696px">
&lt;a href="/posts/hack/xfish/updatecall2.jpg" data-size="708x244">&lt;img src="/posts/hack/xfish/updatecall2.jpg"
srcset="/posts/hack/xfish/updatecall2_hu8b4e53f6efc16eee43e3c0879d76ef38_23057_480x0_resize_q75_box.jpg 480w, /posts/hack/xfish/updatecall2_hu8b4e53f6efc16eee43e3c0879d76ef38_23057_1024x0_resize_q75_box.jpg 1024w"
width="708"
height="244"
loading="lazy"
alt="更新2">
&lt;/a>
&lt;figcaption>更新2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>重点代码摘要如下:&lt;/p>
&lt;pre>&lt;code>private void c(final UpgradeHandler handler) {
if (handler != null) {
...
handler.onUpgradeNeed(info, tracer);
...
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;code>c&lt;/code>中的代码的突破点在于, &lt;strong>如果传入的&lt;code>handler&lt;/code>不为&lt;code>null&lt;/code>, 才会执行更新检测并弹窗的方法&lt;/strong>, 那么我只需要让传入的&lt;code>handler&lt;/code>为&lt;code>null&lt;/code>就可以了. 在&lt;code>Xposed&lt;/code>模块中对&lt;code>Upgrade&lt;/code>类的&lt;code>b&lt;/code>方法&lt;code>Hook&lt;/code>, 将入参设置为&lt;code>null&lt;/code>&lt;/p>
&lt;pre>&lt;code>findAndHookMethod(&amp;quot;com.马赛克.马赛克fish.upgrade.traceable.Upgrade&amp;quot;,loadPackageParam.classLoader,
&amp;quot;b&amp;quot;,
&amp;quot;com.马赛克.马赛克fish.upgrade.traceable.UpgradeHandler&amp;quot;,
new XC_MethodHook() {
@Override
protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
//这里将入参设置为null
param.args[0] = null;
}
}
);
&lt;/code>&lt;/pre>&lt;p>重新进行测试, &lt;strong>一切正常且启动之后不再有更新弹窗了&lt;/strong>&lt;/p></description></item><item><title>某琴吧EXE播放器破解记录</title><link>/posts/hack/xtan/exe/</link><pubDate>Wed, 26 May 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xtan/exe/</guid><description>&lt;img src="/posts/hack/xtan/exe/cover.png" alt="Featured image of post 某琴吧EXE播放器破解记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>本文接另一篇文章 &lt;a class="link" href="../xtan_flash_hack/index.md" >某琴吧Flash播放器破解记录&lt;/a>&lt;/p>
&lt;p>由于某琴吧改版正式使用exe播放器之后, 删除了所有的&lt;code>.ypa2&lt;/code>资源, 导致我没有及时下载的乐谱都无法继续使用Flash播放器播放了, 忍不了, 只能破解exe播放器了&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解该站的exe播放器, 使其能够免费播放VIP乐谱, 且可以完全脱机使用&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>首先安装网站的乐谱播放器, 打开安装目录发现文件结构如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 78; flex-basis: 188px">
&lt;a href="/posts/hack/xtan/exe/3.jpg" data-size="246x313">&lt;img src="/posts/hack/xtan/exe/3.jpg"
srcset="/posts/hack/xtan/exe/3_hue232319cf432e7036953df257266796c_12330_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/3_hue232319cf432e7036953df257266796c_12330_1024x0_resize_q75_box.jpg 1024w"
width="246"
height="313"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>xxxchrome.exe&lt;/code>相当于一个浏览器, 可以访问某琴吧, 点击&amp;quot;客户端播放&amp;quot;按钮即可打开播放器, 如下图&lt;/p>
&lt;p>&lt;figure style="flex-grow: 151; flex-basis: 363px">
&lt;a href="/posts/hack/xtan/exe/2.jpg" data-size="1116x736">&lt;img src="/posts/hack/xtan/exe/2.jpg"
srcset="/posts/hack/xtan/exe/2_hu497f65295a89ad86247035b74338bec2_76064_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/2_hu497f65295a89ad86247035b74338bec2_76064_1024x0_resize_q75_box.jpg 1024w"
width="1116"
height="736"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>而&lt;code>xxplayer.exe&lt;/code>才是播放器, 播放器启动后, 可以从任务管理器看到新增的进程&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 307px">
&lt;a href="/posts/hack/xtan/exe/1.jpg" data-size="926x722">&lt;img src="/posts/hack/xtan/exe/1.jpg"
srcset="/posts/hack/xtan/exe/1_hud35c019f213a619ddd7799f1e0fa3f93_112502_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/1_hud35c019f213a619ddd7799f1e0fa3f93_112502_1024x0_resize_q75_box.jpg 1024w"
width="926"
height="722"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>剩下的安装文件和库文件还有配置文件, 就不介绍了.&lt;/p>
&lt;p>首先播放一个免费的乐谱, 在任务管理器中查看一下&lt;code>xxplayer.exe&lt;/code>的启动参数&lt;/p>
&lt;p>&lt;figure style="flex-grow: 610; flex-basis: 1464px">
&lt;a href="/posts/hack/xtan/exe/4.jpg" data-size="946x155">&lt;img src="/posts/hack/xtan/exe/4.jpg"
srcset="/posts/hack/xtan/exe/4_hub8c1251db8423eeb57a6a376306d634c_30464_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/4_hub8c1251db8423eeb57a6a376306d634c_30464_1024x0_resize_q75_box.jpg 1024w"
width="946"
height="155"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>完整的启动参数如下&lt;/p>
&lt;pre>&lt;code>&amp;quot;C:\Program Files\马赛克music\out1\马赛克player.exe&amp;quot; &amp;quot;file=http://www.马赛克.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981&amp;quot;
&lt;/code>&lt;/pre>&lt;p>可以看到启动参数主要为&lt;/p>
&lt;ul>
&lt;li>&lt;code>file&lt;/code> 官网的乐谱页地址&lt;/li>
&lt;li>&lt;code>ypid&lt;/code> 乐谱ID&lt;/li>
&lt;li>&lt;code>uid&lt;/code> 用户ID&lt;/li>
&lt;li>&lt;code>token&lt;/code> 凭证&lt;/li>
&lt;/ul>
&lt;p>如果从&lt;code>xxxchrome.exe&lt;/code>打开一个VIP乐谱, 则会显示&lt;/p>
&lt;p>&lt;figure style="flex-grow: 103; flex-basis: 249px">
&lt;a href="/posts/hack/xtan/exe/5.jpg" data-size="441x425">&lt;img src="/posts/hack/xtan/exe/5.jpg"
srcset="/posts/hack/xtan/exe/5_hua261adef9b482683046becfc9484b40d_36483_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/5_hua261adef9b482683046becfc9484b40d_36483_1024x0_resize_q75_box.jpg 1024w"
width="441"
height="425"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>那么如果我不用他的&lt;code>xxxchrome.exe&lt;/code>, 直接从命令行启动&lt;code>xxplayer.exe&lt;/code>, 传入一个VIP乐谱ID, 会发生什么呢?&lt;/p>
&lt;p>将刚才的启动参数中的&lt;code>ypid&lt;/code>参数修改为一个VIP乐谱ID, 通过命令行&lt;/p>
&lt;pre>&lt;code>xxplayer.exe &amp;quot;file=http://www.马赛克.com/open_yp.php?ypid=33418&amp;amp;uid=999999999&amp;amp;token=4c6930a47090c3f04c7e9db3bf214078&amp;quot;
&lt;/code>&lt;/pre>&lt;p>启动&lt;code>xxplayer.exe&lt;/code>之后如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 128; flex-basis: 307px">
&lt;a href="/posts/hack/xtan/exe/6.jpg" data-size="926x722">&lt;img src="/posts/hack/xtan/exe/6.jpg"
srcset="/posts/hack/xtan/exe/6_hu611ebb7a50cb9110ffdfa4a2b0b1f4b7_52562_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/6_hu611ebb7a50cb9110ffdfa4a2b0b1f4b7_52562_1024x0_resize_q75_box.jpg 1024w"
width="926"
height="722"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>非常的正常, 但是至少验证了 &lt;strong>&lt;code>xxplayer.exe&lt;/code>是可以脱离&lt;code>xxxchrome.exe&lt;/code>独立运行的&lt;/strong>, 那么既然要鉴权, 不请求服务器肯定是不行的吧? 于是打开&lt;code>Charles&lt;/code>开始抓包, 首先用命令行打开一个免费的乐谱, 捕获到网络请求如下&lt;/p>
&lt;p>&lt;figure style="flex-grow: 217; flex-basis: 520px">
&lt;a href="/posts/hack/xtan/exe/7.jpg" data-size="1109x511">&lt;img src="/posts/hack/xtan/exe/7.jpg"
srcset="/posts/hack/xtan/exe/7_hu0c0894aaf992bb2895aba54aaa8c3e13_42004_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/7_hu0c0894aaf992bb2895aba54aaa8c3e13_42004_1024x0_resize_q75_box.jpg 1024w"
width="1109"
height="511"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看出主要请求接口为&lt;code>/codeindex.php&lt;/code>, 通过参数&lt;code>m&lt;/code>做不同功能的权限认证&lt;/p>
&lt;p>&lt;strong>当&lt;code>m=index&lt;/code>, 验证成功返回权限信息&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;responseCode&amp;quot;: &amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;: &amp;quot;\u6b63\u5e38&amp;quot;,
&amp;quot;power&amp;quot;: {
&amp;quot;openPower&amp;quot;: &amp;quot;1&amp;quot;,
&amp;quot;printPower&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;printCount&amp;quot;: &amp;quot;30&amp;quot;,
&amp;quot;vstPower&amp;quot;: &amp;quot;0&amp;quot;,
&amp;quot;pdfPower&amp;quot;: &amp;quot;0&amp;quot;
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>当&lt;code>m=getYpdsUrl&lt;/code>, 验证成功返回&lt;code>.ypdx&lt;/code>格式的播放文件地址&lt;/strong>&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;: {
&amp;quot;code&amp;quot;: &amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;: &amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;: {
&amp;quot;ypdsUrl&amp;quot;: &amp;quot;http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypds&amp;quot;,
&amp;quot;ypdxUrl&amp;quot;: &amp;quot;http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>最后再请求资源地址&lt;code>http:\/\/马赛克.马赛克.com\/yuepuku\/148\/74205\/74205_cfcbahia.ypdx&lt;/code>, 得到&lt;code>.ypdx&lt;/code>格式的播放文件&lt;/strong>&lt;/p>
&lt;p>现在再来通过命令行启动一个VIP乐谱,看看请求和响应会是怎样的&lt;/p>
&lt;p>&lt;figure style="flex-grow: 253; flex-basis: 609px">
&lt;a href="/posts/hack/xtan/exe/8.jpg" data-size="1421x560">&lt;img src="/posts/hack/xtan/exe/8.jpg"
srcset="/posts/hack/xtan/exe/8_hu3f37fa29dc05402f585297533b7b83ee_37005_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/8_hu3f37fa29dc05402f585297533b7b83ee_37005_1024x0_resize_q75_box.jpg 1024w"
width="1421"
height="560"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到这次只有一个&lt;code>m=index&lt;/code>的请求, 且返回码不同于免费乐谱的&lt;code>1000&lt;/code>, 之后播放器弹出没有权限的弹窗, 那么思路就来了&lt;/p>
&lt;p>&lt;strong>如果我将篡改请求的响应,播放器应该就会认为我是有权限的,那不就可以播放了吗?&lt;/strong>&lt;/p>
&lt;p>首先使用&lt;code>Charles&lt;/code>进行断点, 针对&lt;code>m=index&lt;/code>的请求, 修改播放器请求VIP乐谱的返回值&lt;/p>
&lt;p>&lt;figure style="flex-grow: 297; flex-basis: 713px">
&lt;a href="/posts/hack/xtan/exe/9.jpg" data-size="1457x490">&lt;img src="/posts/hack/xtan/exe/9.jpg"
srcset="/posts/hack/xtan/exe/9_hu7ca9ec15f72904f15f25adfa64967b6c_45120_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/9_hu7ca9ec15f72904f15f25adfa64967b6c_45120_1024x0_resize_q75_box.jpg 1024w"
width="1457"
height="490"
loading="lazy"
alt="iamge-9">
&lt;/a>
&lt;figcaption>iamge-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>和我预料的一样, 修改&lt;code>m=index&lt;/code>的响应后, 这次发送了&lt;code>m=getYpdsUrl&lt;/code>的请求&lt;/strong>&lt;/p>
&lt;p>但是&lt;code>m=getYpdsUrl&lt;/code>仍然对用户权限进行了判断, 因此返回码不是正常的&lt;code>1000&lt;/code>, 且&lt;code>result&lt;/code>节点没有返回&lt;code>.ypdx&lt;/code>播放文件的资源地址, 看样子不是VIP用户是无法获得资源地址了&lt;/p>
&lt;h1 id="但是">但是&lt;/h1>
&lt;p>&lt;strong>在文章 &lt;a class="link" href="../xtan_flash_hack/index.md" >某琴吧Flash播放器破解记录&lt;/a> 中, 使用&lt;code>getURL&lt;/code>生成的乐谱信息url去请求乐谱服务器得到的返回值里, 是包含&lt;code>.ypa2&lt;/code>格式的资源地址的, 只不过现在&lt;code>.ypa2&lt;/code>资源已经被删了, 不过观察刚才免费的乐谱&lt;code>.ypdx&lt;/code>资源地址后, 会发现这和&lt;code>.ypa2&lt;/code>的资源地址高度相似! 于是我将返回的&lt;code>.ypa2&lt;/code>资源地址修改后缀名为&lt;code>.ypdx&lt;/code>进行请求之后, 顺利得到了&lt;code>.ypdx&lt;/code>格式的播放文件!&lt;/strong>&lt;/p>
&lt;pre>&lt;code>//ypa2请求地址
http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypa2
//ypdx请求地址
http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypdx
&lt;/code>&lt;/pre>&lt;p>得到&lt;code>.ypdx&lt;/code>文件之后, 开启一个本地HTTP服务器, 开放一个地址用于返回&lt;code>.ypdx&lt;/code>文件, 然后用&lt;code>Charles&lt;/code>对VIP乐谱请求中&lt;code>m=getYpdsUrl&lt;/code>断点, 并修改响应中&lt;code>result&lt;/code>里对应的资源地址为本地HTTP服务器地址&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;:
{
&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;:&amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;:
{
&amp;quot;ypdsUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypds&amp;quot;,&amp;quot;ypdxUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>再次测试, &lt;strong>成功打开VIP乐谱, 并开始播放, 所有功能正常!&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 172; flex-basis: 412px">
&lt;a href="/posts/hack/xtan/exe/10.jpg" data-size="917x533">&lt;img src="/posts/hack/xtan/exe/10.jpg"
srcset="/posts/hack/xtan/exe/10_hud8451ede4dc6fa64d83d0d25cd237bd1_87539_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/10_hud8451ede4dc6fa64d83d0d25cd237bd1_87539_1024x0_resize_q75_box.jpg 1024w"
width="917"
height="533"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>确定伪造响应的方案确定可行之后, 下一步就是要让播放器请求我指定的地址了, 因为刚才是通过&lt;code>Charles&lt;/code>修改响应的, 但我不可能每次都使用&lt;code>Charles&lt;/code>断点, 我需要反编译&lt;code>xxplayer.exe&lt;/code>, 并修改服务请求地址为我监听的地址, 然后由我监听的地址返回所需数据&lt;/p>
&lt;p>使用&lt;code>OllyDbg&lt;/code>(以下简称&lt;code>OD&lt;/code>)反汇编&lt;code>xxplayer.exe&lt;/code>, 在菜单栏依次点击 &amp;ldquo;插件&amp;rdquo; -&amp;gt; &amp;ldquo;中文搜索引擎&amp;rdquo; -&amp;gt; &amp;ldquo;搜索UNICODE&amp;rdquo;, 以&lt;code>Charles&lt;/code>捕获到的url中的关键字&lt;code>codeindex&lt;/code>搜索, 发现一共有三处&lt;/p>
&lt;p>&lt;figure style="flex-grow: 157; flex-basis: 377px">
&lt;a href="/posts/hack/xtan/exe/11.jpg" data-size="873x555">&lt;img src="/posts/hack/xtan/exe/11.jpg"
srcset="/posts/hack/xtan/exe/11_huffee53a5592e1e02a42fb8e5ded3cf0f_112355_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/11_huffee53a5592e1e02a42fb8e5ded3cf0f_112355_1024x0_resize_q75_box.jpg 1024w"
width="873"
height="555"
loading="lazy"
alt="iamge-11">
&lt;/a>
&lt;figcaption>iamge-11&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>Warning: 此处我没有使用虚拟机打开, 建议各位反汇编的时候用虚拟机, 因为被反汇编的程序如果有反调试的代码, 轻则闪退重则格盘. 另外&lt;code>OD&lt;/code>本身是不带&amp;quot;中文搜索引擎&amp;quot;插件的, 需要自行下载安装&lt;/p>
&lt;/blockquote>
&lt;p>双击搜索到的第一处字符串, 跳转到引用代码段, 通过字符串格式可以看出, 其中&lt;code>%s&lt;/code>是要用参数替换的, 且通过前面的&lt;code>push&lt;/code>可以看出, 它自身也是作为参数被传递的, 那么只要跟踪下方离他最近的&lt;code>call&lt;/code>之前的变量, 就能确定需要修改哪一行了, 在可疑的&lt;code>push&lt;/code>处按&lt;code>F2&lt;/code>断点, &lt;code>F8&lt;/code>单步调试后, 发现&lt;code>push [local.7]&lt;/code>正是请求的域名&lt;/p>
&lt;p>&lt;figure style="flex-grow: 247; flex-basis: 593px">
&lt;a href="/posts/hack/xtan/exe/12.jpg" data-size="1382x559">&lt;img src="/posts/hack/xtan/exe/12.jpg"
srcset="/posts/hack/xtan/exe/12_hu2c3187806ba888f67c6ef154a52910a6_103478_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/12_hu2c3187806ba888f67c6ef154a52910a6_103478_1024x0_resize_q75_box.jpg 1024w"
width="1382"
height="559"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>为了修改字符串, 有两种方式&lt;/p>
&lt;ol>
&lt;li>如果修改前后字符串长度相同, 可以直接定位到字符串地址进行修改&lt;/li>
&lt;li>如果长度不同, 可以在程序空白处, 新增一段字符串, 然后将之前对字符串的地址引用改为新增的字符串地址&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>程序空白处是指在&lt;code>OD&lt;/code>左下角的数据面板, 拉到最下面, 可以看到一堆&lt;code>00 00 00 00 00 00 ...&lt;/code>, &lt;code>00&lt;/code>在汇编中就是啥都没有, 啥都不干, 也就是空白的意思&lt;/p>
&lt;/blockquote>
&lt;p>这里暂时不知道&lt;code>[local.7]&lt;/code>哪儿来的, 所以我选择第二种方式, 查看&lt;code>OD&lt;/code>左下角数据面板, 拉到最下面, 找到程序空白处, 双击空白地址, 在弹出的编辑窗口中取消勾选&amp;quot;Keep size&amp;quot;, 在&lt;code>UNICODE&lt;/code>栏输入&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 141; flex-basis: 338px">
&lt;a href="/posts/hack/xtan/exe/13.jpg" data-size="877x621">&lt;img src="/posts/hack/xtan/exe/13.jpg"
srcset="/posts/hack/xtan/exe/13_hudbbd87ddb0f3a147db74e9958487c023_140223_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/13_hudbbd87ddb0f3a147db74e9958487c023_140223_1024x0_resize_q75_box.jpg 1024w"
width="877"
height="621"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 183; flex-basis: 440px">
&lt;a href="/posts/hack/xtan/exe/14.jpg" data-size="674x367">&lt;img src="/posts/hack/xtan/exe/14.jpg"
srcset="/posts/hack/xtan/exe/14_hu04bc64c292e419c662d490484458d11b_82404_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/14_hu04bc64c292e419c662d490484458d11b_82404_1024x0_resize_q75_box.jpg 1024w"
width="674"
height="367"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;blockquote>
&lt;p>Q1: 为什么不在&lt;code>011808E0&lt;/code>行的&lt;code>6C 65 57&lt;/code>后面的&lt;code>00&lt;/code>处添加, 而是在&lt;code>00&lt;/code>的后面?&lt;/p>
&lt;blockquote>
&lt;p>因为汇编中字符串是以&lt;code>00&lt;/code>结尾, 且每个字符后面都跟一个&lt;code>00&lt;/code>, 为了尽量避免覆盖前面的数据块, 这里空开一个&lt;code>00&lt;/code>位置, 如果前面数据块明显是字符串,需要空开三个&lt;code>00&lt;/code>, 因为结束符&lt;code>00&lt;/code>后面也会跟一个&lt;code>00&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Q2: 为什么取消勾选&amp;quot;Keep size&amp;quot;&lt;/p>
&lt;blockquote>
&lt;p>Keep size的作用是保持长度字符串长度一致, 因为如果超过原来的长度会造成不可预知的错误, 但是这里是程序空白处, 后面都是空白行, 所以不需要保持长度, 有多少写多少&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>此时点击新增的字符串头&lt;code>6C&lt;/code>可以在底部栏看到新字符串的起始地址为&lt;code>0x11808E4&lt;/code>, 回到汇编面板, 双击刚才的&lt;code>push [local.7]&lt;/code>所在行, 在弹出的面板中修改为 &lt;code>push 0x11808E4&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>由于修改后的代码较之前的代码更少, 需要勾选&amp;quot;Fill with NOP`s&amp;quot;来保持长度一致&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 468; flex-basis: 1125px">
&lt;a href="/posts/hack/xtan/exe/15.jpg" data-size="661x141">&lt;img src="/posts/hack/xtan/exe/15.jpg"
srcset="/posts/hack/xtan/exe/15_hu57c63b4afeb55ac5b9b491851fbce9ac_27836_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/15_hu57c63b4afeb55ac5b9b491851fbce9ac_27836_1024x0_resize_q75_box.jpg 1024w"
width="661"
height="141"
loading="lazy"
alt="image-15">
&lt;/a>
&lt;figcaption>image-15&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到在汇编面板右侧已经自动显示了标记, 提示当前&lt;code>push&lt;/code>的值为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 494; flex-basis: 1187px">
&lt;a href="/posts/hack/xtan/exe/16.jpg" data-size="757x153">&lt;img src="/posts/hack/xtan/exe/16.jpg"
srcset="/posts/hack/xtan/exe/16_hu9bfdeefc21eab2638c1ebf03797105d7_27361_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/16_hu9bfdeefc21eab2638c1ebf03797105d7_27361_1024x0_resize_q75_box.jpg 1024w"
width="757"
height="153"
loading="lazy"
alt="image-16">
&lt;/a>
&lt;figcaption>image-16&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>现在选中刚才在数据面板添加的字符串十六进制代码块, 右键点击&amp;quot;复制到可执行文件&amp;quot;, 再选中汇编面板所有修改的行, 右键点击&amp;quot;复制到可执行文件&amp;quot; -&amp;gt; &amp;ldquo;选中行&amp;rdquo;, 在弹出的面板中右键&amp;quot;备份&amp;quot; -&amp;gt; &amp;ldquo;保存数据到文件&amp;quot;即可保存修改后的exe文件&lt;/p>
&lt;p>&lt;figure style="flex-grow: 169; flex-basis: 406px">
&lt;a href="/posts/hack/xtan/exe/36.jpg" data-size="490x289">&lt;img src="/posts/hack/xtan/exe/36.jpg"
srcset="/posts/hack/xtan/exe/36_hu404fc96720b3b7e3a08d11e39c71c904_39522_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/36_hu404fc96720b3b7e3a08d11e39c71c904_39522_1024x0_resize_q75_box.jpg 1024w"
width="490"
height="289"
loading="lazy"
alt="image-36">
&lt;/a>
&lt;figcaption>image-36&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>执行修改后的程序, 发现程序异常退出, 用&lt;code>OD&lt;/code>打开修改后的文件, 再次找到刚才修改&lt;code>push&lt;/code>的地方, 发现右侧没有显示&lt;code>localhost:7777&lt;/code>的标记&lt;/p>
&lt;p>&lt;figure style="flex-grow: 792; flex-basis: 1900px">
&lt;a href="/posts/hack/xtan/exe/17.jpg" data-size="800x101">&lt;img src="/posts/hack/xtan/exe/17.jpg"
srcset="/posts/hack/xtan/exe/17_huf607ca71409b4fad60df0a0bf04883f0_25000_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/17_huf607ca71409b4fad60df0a0bf04883f0_25000_1024x0_resize_q75_box.jpg 1024w"
width="800"
height="101"
loading="lazy"
alt="image-17">
&lt;/a>
&lt;figcaption>image-17&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再看看跳转地址&lt;code>0x11808E4&lt;/code>, 也不是刚才修改的字符串内容&lt;/p>
&lt;p>&lt;figure style="flex-grow: 223; flex-basis: 535px">
&lt;a href="/posts/hack/xtan/exe/18.jpg" data-size="705x316">&lt;img src="/posts/hack/xtan/exe/18.jpg"
srcset="/posts/hack/xtan/exe/18_hu399d950736d8f788e6f1fac9c27f058c_68183_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/18_hu399d950736d8f788e6f1fac9c27f058c_68183_1024x0_resize_q75_box.jpg 1024w"
width="705"
height="316"
loading="lazy"
alt="image-18">
&lt;/a>
&lt;figcaption>image-18&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>虽然不知道为什么, 但是看来&lt;code>push [local.x]&lt;/code>形式的代码不能这样简单的修改. 那么换个角度想想&lt;code>[local.7]&lt;/code>的值是哪里来的, 这时突然想到播放器启动的时候, 带的参数里是有一个网址的&lt;/p>
&lt;pre>&lt;code>file=http://www.马赛克.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981
&lt;/code>&lt;/pre>&lt;p>我将这个网址修改为百度的网址&lt;/p>
&lt;pre>&lt;code>file=http://www.baidu.com/open_yp.php?ypid=73981&amp;amp;uid=999999999&amp;amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb&amp;amp;ypid=73981
&lt;/code>&lt;/pre>&lt;p>重新运行, 抓包发现它真的去请求百度的&lt;code>/codeindex.php&lt;/code>接口了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 246; flex-basis: 591px">
&lt;a href="/posts/hack/xtan/exe/19.jpg" data-size="1201x487">&lt;img src="/posts/hack/xtan/exe/19.jpg"
srcset="/posts/hack/xtan/exe/19_hu0b7b1ef1c2d34dbfa1585c7679051785_39521_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/19_hu0b7b1ef1c2d34dbfa1585c7679051785_39521_1024x0_resize_q75_box.jpg 1024w"
width="1201"
height="487"
loading="lazy"
alt="image-19">
&lt;/a>
&lt;figcaption>image-19&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>于是我再将参数换成&lt;code>localhost:7777&lt;/code>, 重新运行, 结果发现程序异常退出, 进行跟踪调试发现&lt;code>[local.7]&lt;/code>的实际值被截取了不包含端口号的部分, 为&lt;code>localhost&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 698; flex-basis: 1676px">
&lt;a href="/posts/hack/xtan/exe/20.jpg" data-size="433x62">&lt;img src="/posts/hack/xtan/exe/20.jpg"
srcset="/posts/hack/xtan/exe/20_hu440de6aaab4215e0c9aec32fa24ecc7b_7055_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/20_hu440de6aaab4215e0c9aec32fa24ecc7b_7055_1024x0_resize_q75_box.jpg 1024w"
width="433"
height="62"
loading="lazy"
alt="image-20">
&lt;/a>
&lt;figcaption>image-20&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>尝试跟踪截取部分的代码, 但是太麻烦了决定放弃. 这时候我想到直接将整个url&lt;/p>
&lt;pre>&lt;code>%s://%s/codeindex.php?d=api&amp;amp;c=check马赛克playerPower&amp;amp;m=%s&amp;amp;ypid=%d&amp;amp;uid=%d&amp;amp;token=%s
&lt;/code>&lt;/pre>&lt;p>中第二个&lt;code>%s&lt;/code>直接替换成&lt;code>localhost:7777&lt;/code>不就可以了? 但是这样就少了一个&lt;code>%s&lt;/code>, 参数对不上后面的代码一定会报错, 于是我想到在&lt;code>?&lt;/code>后面再加一个参数, 参数名随意, 参数值就用&lt;code>[local.7]&lt;/code>, 反正对于串来说, &lt;code>%s&lt;/code>的数量能够对应参数的数量即可, 而对于HTTP请求来说, 多一个参数也没什么影响. 不过修改后字符串的长度就对不上了, 所以还是在程序空白处添加了一个新的字符串如下&lt;/p>
&lt;pre>&lt;code>%s://localhost:7777/codeindex.php?a=%s&amp;amp;d=api&amp;amp;c=check马赛克playerPower&amp;amp;m=%s&amp;amp;ypid=%d&amp;amp;uid=%d&amp;amp;token=%s
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 153; flex-basis: 367px">
&lt;a href="/posts/hack/xtan/exe/21.jpg" data-size="889x580">&lt;img src="/posts/hack/xtan/exe/21.jpg"
srcset="/posts/hack/xtan/exe/21_hu1c54f487ac9664d7c79f770f2f649700_141375_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/21_hu1c54f487ac9664d7c79f770f2f649700_141375_1024x0_resize_q75_box.jpg 1024w"
width="889"
height="580"
loading="lazy"
alt="image-21">
&lt;/a>
&lt;figcaption>image-21&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>a&lt;/code>就是新增的无用参数, &lt;code>a&lt;/code>后面跟的&lt;code>%s&lt;/code>将会被&lt;code>[local.7]&lt;/code>的值替换, 这样一来无论启动参数中的域名是什么都无所谓了. 记录新字符串的地址为&lt;code>0x11808E4&lt;/code>, 找到&lt;code>push&lt;/code>原来字符串的汇编代码, 修改&lt;code>push&lt;/code>地址为新的字符串地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 375; flex-basis: 901px">
&lt;a href="/posts/hack/xtan/exe/22.jpg" data-size="781x208">&lt;img src="/posts/hack/xtan/exe/22.jpg"
srcset="/posts/hack/xtan/exe/22_hue1957260a927d0c5dbb86391d75e28e1_43919_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/22_hue1957260a927d0c5dbb86391d75e28e1_43919_1024x0_resize_q75_box.jpg 1024w"
width="781"
height="208"
loading="lazy"
alt="image-22">
&lt;/a>
&lt;figcaption>image-22&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>再次保存执行, 程序还是异常退出, 用&lt;code>OD&lt;/code>打开修改后的程序发现地址正确, 字符串正确, 但是还是会报错, 于是我怀疑不能用&lt;code>localhost&lt;/code>作为域名. 将&lt;code>localhost:7777&lt;/code>修改为&lt;code>127.0.0.1:7777&lt;/code>, 再次运行, 这次终于在后台收到了来自播放器的HTTP请求!&lt;/p>
&lt;p>&lt;figure style="flex-grow: 142; flex-basis: 341px">
&lt;a href="/posts/hack/xtan/exe/23.jpg" data-size="588x413">&lt;img src="/posts/hack/xtan/exe/23.jpg"
srcset="/posts/hack/xtan/exe/23_hue6d1dcff70949874743239655fec497d_58860_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/23_hue6d1dcff70949874743239655fec497d_58860_1024x0_resize_q75_box.jpg 1024w"
width="588"
height="413"
loading="lazy"
alt="image-23">
&lt;/a>
&lt;figcaption>image-23&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>所有参数也都正常接收, 接下来只要返回正确的响应就行了, 对于&lt;code>m=index&lt;/code>的直接返回&lt;/p>
&lt;pre>&lt;code>{&amp;quot;responseCode&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;power&amp;quot;:{&amp;quot;openPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printPower&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;,&amp;quot;vstPower&amp;quot;:&amp;quot;0&amp;quot;,&amp;quot;pdfPower&amp;quot;:&amp;quot;0&amp;quot;}}
&lt;/code>&lt;/pre>&lt;p>对于&lt;code>m=getYpdsUrl&lt;/code> 的则返回&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;data&amp;quot;:
{
&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,
&amp;quot;message&amp;quot;:&amp;quot;\u83b7\u53d6\u6210\u529f&amp;quot;,
&amp;quot;result&amp;quot;:
{
&amp;quot;ypdsUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypds&amp;quot;,&amp;quot;ypdxUrl&amp;quot;:&amp;quot;http:\/\/127.0.0.1:7777\/yuepu\/57806_hhdafigb.ypdx&amp;quot;
}
}
}
&lt;/code>&lt;/pre>&lt;p>然后, 用同样的方式修改搜索&lt;code>codeindex&lt;/code>结果中的第二处, 再次运行就能正常播放了.&lt;/p>
&lt;h2 id="继续破解">继续破解&lt;/h2>
&lt;p>&lt;strong>现在虽然播放曲谱没有问题了, 但是现在还有如下几个VIP功能用不了, 要白嫖就白嫖到极致&lt;/strong>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 143; flex-basis: 345px">
&lt;a href="/posts/hack/xtan/exe/24.jpg" data-size="233x162">&lt;img src="/posts/hack/xtan/exe/24.jpg"
srcset="/posts/hack/xtan/exe/24_hu900d4ace8f5f7a408779743848e939c7_8586_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/24_hu900d4ace8f5f7a408779743848e939c7_8586_1024x0_resize_q75_box.jpg 1024w"
width="233"
height="162"
loading="lazy"
alt="image-24">
&lt;/a>
&lt;figcaption>image-24&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>从音源开始下手, 点击&amp;quot;音源&amp;rdquo; -&amp;gt; &amp;ldquo;浏览&amp;quot;后, 播放器弹出没有权限的提示&lt;/p>
&lt;p>&lt;figure style="flex-grow: 204; flex-basis: 491px">
&lt;a href="/posts/hack/xtan/exe/25.jpg" data-size="346x169">&lt;img src="/posts/hack/xtan/exe/25.jpg"
srcset="/posts/hack/xtan/exe/25_hu59dd44e7ae9f17fbaea053064c4a0a8f_7285_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/25_hu59dd44e7ae9f17fbaea053064c4a0a8f_7285_1024x0_resize_q75_box.jpg 1024w"
width="346"
height="169"
loading="lazy"
alt="image-25">
&lt;/a>
&lt;figcaption>image-25&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>查看&lt;code>Charles&lt;/code>发现期间并没有发出网络请求, 推测应该是在之前的请求里就响应过了, 这时想到最开始&lt;code>m=index&lt;/code>的请求中, &lt;code>power&lt;/code>节点有很多为&lt;code>0&lt;/code>的字段, 仔细一看这不就是对应的权限吗? 推测权限字段对应关系应该是&lt;/p>
&lt;ul>
&lt;li>&lt;code>openPower&lt;/code> 打开的权限&lt;/li>
&lt;li>&lt;code>printPower&lt;/code> 打印的权限&lt;/li>
&lt;li>&lt;code>printCount&lt;/code> 可打印的数量&lt;/li>
&lt;li>&lt;code>vstPower&lt;/code> 使用vst音源的权限&lt;/li>
&lt;li>&lt;code>pdfPower&lt;/code> 转换pdf的权限&lt;/li>
&lt;/ul>
&lt;p>参考正常响应中&lt;code>openPower&lt;/code>为1, 其他的为0, 因此把后台响应中所有为0改为1, 再次点击音源, 发现可以正常选择了&lt;/p>
&lt;pre>&lt;code>{&amp;quot;responseCode&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;power&amp;quot;:{&amp;quot;openPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;,&amp;quot;vstPower&amp;quot;:&amp;quot;1&amp;quot;,&amp;quot;pdfPower&amp;quot;:&amp;quot;1&amp;quot;}}
&lt;/code>&lt;/pre>&lt;p>&lt;figure style="flex-grow: 279; flex-basis: 669px">
&lt;a href="/posts/hack/xtan/exe/26.jpg" data-size="960x344">&lt;img src="/posts/hack/xtan/exe/26.jpg"
srcset="/posts/hack/xtan/exe/26_hu1bf099da9e3265a9d42b774a7d669a1d_27932_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/26_hu1bf099da9e3265a9d42b774a7d669a1d_27932_1024x0_resize_q75_box.jpg 1024w"
width="960"
height="344"
loading="lazy"
alt="image-26">
&lt;/a>
&lt;figcaption>image-26&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>接下来看看点击转换PDF功能, 通过&lt;code>Charles&lt;/code>发现会发送一个权限请求&lt;/p>
&lt;p>&lt;figure style="flex-grow: 235; flex-basis: 565px">
&lt;a href="/posts/hack/xtan/exe/27.jpg" data-size="1355x575">&lt;img src="/posts/hack/xtan/exe/27.jpg"
srcset="/posts/hack/xtan/exe/27_hu4561b2c4374e5a889b57d6ec9aab22e2_42292_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/27_hu4561b2c4374e5a889b57d6ec9aab22e2_42292_1024x0_resize_q75_box.jpg 1024w"
width="1355"
height="575"
loading="lazy"
alt="image-27">
&lt;/a>
&lt;figcaption>image-27&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中接口仍然是&lt;code>/codeindex.php&lt;/code>, 但本次&lt;code>m&lt;/code>取值为&lt;code>addDynamic&lt;/code>, 在&lt;code>OD&lt;/code>中发现就是刚才上文&lt;code>codeindex&lt;/code>搜索结果中的第三处&lt;/p>
&lt;p>&lt;figure style="flex-grow: 326; flex-basis: 784px">
&lt;a href="/posts/hack/xtan/exe/28.jpg" data-size="1232x377">&lt;img src="/posts/hack/xtan/exe/28.jpg"
srcset="/posts/hack/xtan/exe/28_hu916247033dd02548bff370c15f18cd50_79605_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/28_hu916247033dd02548bff370c15f18cd50_79605_1024x0_resize_q75_box.jpg 1024w"
width="1232"
height="377"
loading="lazy"
alt="image-28">
&lt;/a>
&lt;figcaption>image-28&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>双击搜索结果字符串转到汇编代码,&lt;code>00F63EAE&lt;/code> 处的&lt;code>push&lt;/code>地址就是将要用来替换成请求域名的参数, 这个地址指向了某琴吧的域名, 所以这里采用同样的办法, 先在程序空白处添加字符串&lt;code>127.0.0.1:7777&lt;/code>, 然后修改&lt;code>push&lt;/code>原来串的地址修改为新增的字符串地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 121; flex-basis: 291px">
&lt;a href="/posts/hack/xtan/exe/29.jpg" data-size="863x711">&lt;img src="/posts/hack/xtan/exe/29.jpg"
srcset="/posts/hack/xtan/exe/29_hu38430dc1e6439a03884f24c857dc3df5_158665_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/29_hu38430dc1e6439a03884f24c857dc3df5_158665_1024x0_resize_q75_box.jpg 1024w"
width="863"
height="711"
loading="lazy"
alt="image-29">
&lt;/a>
&lt;figcaption>image-29&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>重新保存, 然后在乐谱工具中监听这个地址, 并参考&lt;code>m=index&lt;/code>的响应以下结果&lt;/p>
&lt;blockquote>
&lt;p>乐谱工具是我基于&lt;code>C#&lt;/code>开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自&lt;code>localhost:7777&lt;/code>的HTTP请求&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>{&amp;quot;data&amp;quot;:{&amp;quot;code&amp;quot;:&amp;quot;1000&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;\u6b63\u5e38&amp;quot;,&amp;quot;result&amp;quot;:{&amp;quot;printCount&amp;quot;:&amp;quot;30&amp;quot;}}}
&lt;/code>&lt;/pre>&lt;p>重新打开运行PDF保存, 发现可以转换并保存了&lt;/p>
&lt;p>&lt;figure style="flex-grow: 134; flex-basis: 323px">
&lt;a href="/posts/hack/xtan/exe/30.jpg" data-size="820x608">&lt;img src="/posts/hack/xtan/exe/30.jpg"
srcset="/posts/hack/xtan/exe/30_hu8e914918ef7e0abf8766f87cc7afd2fe_39001_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/30_hu8e914918ef7e0abf8766f87cc7afd2fe_39001_1024x0_resize_q75_box.jpg 1024w"
width="820"
height="608"
loading="lazy"
alt="image-30">
&lt;/a>
&lt;figcaption>image-30&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>打印的功能和PDF的请求地址和参数&lt;code>m&lt;/code>是一样的, 只要返回同样的响应就可以了&lt;/p>
&lt;p>&lt;strong>至此VIP功能全部破解&lt;/strong>&lt;/p>
&lt;h2 id="但是尚不完美">但是尚不完美&lt;/h2>
&lt;p>最后做脱机测试的时候发现播放器会先检查网络连接状态, 没有网络连接则无法播放&lt;/p>
&lt;p>&lt;figure style="flex-grow: 138; flex-basis: 332px">
&lt;a href="/posts/hack/xtan/exe/31.jpg" data-size="234x169">&lt;img src="/posts/hack/xtan/exe/31.jpg"
srcset="/posts/hack/xtan/exe/31_hua7620923e16ce59bf6ec472d077d4bf8_5366_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/31_hua7620923e16ce59bf6ec472d077d4bf8_5366_1024x0_resize_q75_box.jpg 1024w"
width="234"
height="169"
loading="lazy"
alt="image-31">
&lt;/a>
&lt;figcaption>image-31&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是我的目标是播放器能够脱机使用, 而且实际上播放器被我修改后已经不需要再连上互联网, 只需要请求乐谱工具的HTTP服务地址就可以, 因此根据弹窗搜索字符串, 定位到相关代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 356; flex-basis: 854px">
&lt;a href="/posts/hack/xtan/exe/32.jpg" data-size="755x212">&lt;img src="/posts/hack/xtan/exe/32.jpg"
srcset="/posts/hack/xtan/exe/32_huc5c8a523870c7cfbc55a7f4c1592a244_51730_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/32_huc5c8a523870c7cfbc55a7f4c1592a244_51730_1024x0_resize_q75_box.jpg 1024w"
width="755"
height="212"
loading="lazy"
alt="image-32">
&lt;/a>
&lt;figcaption>image-32&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>可以看到播放器在&lt;code>00F693E2&lt;/code>处调用系统接口得到网络连接状态, 在&lt;code>00F693EC&lt;/code>处, 如果有网络连接则会跳转到&lt;code>00F6940A&lt;/code>处继续, 没有网络连接则会显示并中断运行, 那我只需要让这个判断失效就可以了, 双击&lt;code>00F693EC&lt;/code>打开编辑窗口, 将&lt;code>jnz&lt;/code> (不等于0则跳转) 修改为&lt;code>jmp&lt;/code> (无条件跳转), 这样运行至此的时候将不会判断网络连接状态, 直接运行后面的代码&lt;/p>
&lt;p>&lt;figure style="flex-grow: 258; flex-basis: 621px">
&lt;a href="/posts/hack/xtan/exe/34.jpg" data-size="725x280">&lt;img src="/posts/hack/xtan/exe/34.jpg"
srcset="/posts/hack/xtan/exe/34_hu97a16d2494720619905afeac8c214e7e_58677_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/34_hu97a16d2494720619905afeac8c214e7e_58677_1024x0_resize_q75_box.jpg 1024w"
width="725"
height="280"
loading="lazy"
alt="image-34">
&lt;/a>
&lt;figcaption>image-34&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 424; flex-basis: 1018px">
&lt;a href="/posts/hack/xtan/exe/35.jpg" data-size="734x173">&lt;img src="/posts/hack/xtan/exe/35.jpg"
srcset="/posts/hack/xtan/exe/35_hua827e34f01cf28e04ef01c9d17be5ee7_41039_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/35_hua827e34f01cf28e04ef01c9d17be5ee7_41039_1024x0_resize_q75_box.jpg 1024w"
width="734"
height="173"
loading="lazy"
alt="image-35">
&lt;/a>
&lt;figcaption>image-35&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>同样的, 在使用转换PDF功能时还会检测网络状态, 然后弹窗提示&amp;quot;没有检测到网络!&amp;rdquo;, 找到代码运行处, 修改&lt;code>00F75DDE&lt;/code>处的&lt;code>jnz&lt;/code>为&lt;code>jmp&lt;/code>即可&lt;/p>
&lt;p>&lt;figure style="flex-grow: 529; flex-basis: 1271px">
&lt;a href="/posts/hack/xtan/exe/33.jpg" data-size="694x131">&lt;img src="/posts/hack/xtan/exe/33.jpg"
srcset="/posts/hack/xtan/exe/33_huf3b00aaa9378afd32a3c2a50a118f246_35895_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/exe/33_huf3b00aaa9378afd32a3c2a50a118f246_35895_1024x0_resize_q75_box.jpg 1024w"
width="694"
height="131"
loading="lazy"
alt="image-33">
&lt;/a>
&lt;figcaption>image-33&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>保存后重新运行, 现在脱机情况下播放器能够正常打开并请求乐谱工具的HTTP服务并正常播放乐谱了, 转存PDF文件等VIP功能也能够正常使用&lt;/p>
&lt;h2 id="至此exe版本宣告完美破解">至此exe版本宣告完美破解&lt;/h2></description></item><item><title>某琴吧Flash播放器破解记录</title><link>/posts/hack/xtan/flash/</link><pubDate>Tue, 25 May 2021 00:50:44 +0800</pubDate><guid>/posts/hack/xtan/flash/</guid><description>&lt;img src="/posts/hack/xtan/flash/cover.png" alt="Featured image of post 某琴吧Flash播放器破解记录" />&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.&lt;/p>
&lt;p>同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.&lt;/p>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用&lt;/p>
&lt;h2 id="网站乐谱页">网站乐谱页&lt;/h2>
&lt;p>&lt;figure style="flex-grow: 105; flex-basis: 252px">
&lt;a href="/posts/hack/xtan/flash/1.jpg" data-size="829x789">&lt;img src="/posts/hack/xtan/flash/1.jpg"
srcset="/posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_1024x0_resize_q75_box.jpg 1024w"
width="829"
height="789"
loading="lazy"
alt="image-1">
&lt;/a>
&lt;figcaption>image-1&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;h2 id="开始破解">开始破解&lt;/h2>
&lt;p>&lt;strong>首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>进入乐谱页面, 网站向服务端请求 &lt;code>player.swf&lt;/code>, 该 &lt;code>.swf&lt;/code> 文件即为乐谱播放器&lt;/li>
&lt;li>浏览器加载 &lt;code>player.swf&lt;/code> , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中&lt;/li>
&lt;li>点击播放按钮时, 播放器请求 &lt;code>Sounds.swf&lt;/code>,&lt;/li>
&lt;li>播放器请求接口 &lt;code>/flash_get_yp_info.php&lt;/code> 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址&lt;/li>
&lt;li>播放器下载并载入余下的 &lt;code>.png&lt;/code> 格式乐谱图片, 并加载 &lt;code>.ypa2&lt;/code> 格式的播放文件, 即可开始播放&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>基本过程已经明确了, 而所有的请求接口中, 只有第四步的&lt;code>/flash_get_yp_info.php&lt;/code>是需要对入参&lt;code>sccode&lt;/code>, &lt;code>r1&lt;/code>, &lt;code>r2&lt;/code>, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?&lt;/strong>&lt;/p>
&lt;p>首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 &lt;a class="link" href="https://github.com/wholesky/ffdec" target="_blank" rel="noopener"
>jpexs-decompiler&lt;/a>, 顺利反编译出&lt;code>player.swf&lt;/code>代码, 用IDEA新建为&lt;code>Flex&lt;/code>项目打开, 再百度其中的一些&lt;code>package&lt;/code>名称, 发现代码可基于 &lt;code>flex_sdk_3.6a&lt;/code> 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 120; flex-basis: 288px">
&lt;a href="/posts/hack/xtan/flash/2.jpg" data-size="965x803">&lt;img src="/posts/hack/xtan/flash/2.jpg"
srcset="/posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_1024x0_resize_q75_box.jpg 1024w"
width="965"
height="803"
loading="lazy"
alt="image-2">
&lt;/a>
&lt;figcaption>image-2&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中&lt;code>Main&lt;/code>为主类, &lt;code>init1&lt;/code> 为初始化函数, 这里可以得到入参, 参数传入形式为&lt;/p>
&lt;pre>&lt;code>player.swf?id=1
&lt;/code>&lt;/pre>&lt;p>而配置类&lt;code>Config&lt;/code>定义了服务端接口地址:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 167; flex-basis: 402px">
&lt;a href="/posts/hack/xtan/flash/3.png" data-size="825x492">&lt;img src="/posts/hack/xtan/flash/3.png"
srcset="/posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_480x0_resize_box_2.png 480w, /posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_1024x0_resize_box_2.png 1024w"
width="825"
height="492"
loading="lazy"
alt="image-3">
&lt;/a>
&lt;figcaption>image-3&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>但是很遗憾在&lt;code>player.swf&lt;/code>中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时&lt;code>Sounds.swf&lt;/code>就很可疑了, 通过阅读&lt;code>player.swf&lt;/code>的代码发现&lt;code>Sounds.swf&lt;/code>是点击播放按钮之后, 作为一个函数库被加载进来的, 这里&lt;code>load&lt;/code>的地址就是&lt;code>Config&lt;/code>里定义了&lt;code>Sounds.swf&lt;/code>资源地址&lt;/p>
&lt;p>&lt;figure style="flex-grow: 699; flex-basis: 1677px">
&lt;a href="/posts/hack/xtan/flash/4.jpg" data-size="734x105">&lt;img src="/posts/hack/xtan/flash/4.jpg"
srcset="/posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_1024x0_resize_q75_box.jpg 1024w"
width="734"
height="105"
loading="lazy"
alt="image-4">
&lt;/a>
&lt;figcaption>image-4&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>请求响应之后通过回调函数&lt;code>onSwComplete&lt;/code>将其载入并储存到&lt;code>Clib&lt;/code>类的成员变量&lt;code>clib&lt;/code>中&lt;/p>
&lt;p>&lt;figure style="flex-grow: 318; flex-basis: 764px">
&lt;a href="/posts/hack/xtan/flash/5.jpg" data-size="771x242">&lt;img src="/posts/hack/xtan/flash/5.jpg"
srcset="/posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_1024x0_resize_q75_box.jpg 1024w"
width="771"
height="242"
loading="lazy"
alt="image-5">
&lt;/a>
&lt;figcaption>image-5&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>然后就可以通过&lt;code>utils.Clib.clib.xxx&lt;/code>的方式调用函数, 再深入跟踪代码, 发现&lt;code>Clib&lt;/code>中的&lt;code>getURL&lt;/code>非常可疑&lt;/p>
&lt;p>&lt;figure style="flex-grow: 379; flex-basis: 910px">
&lt;a href="/posts/hack/xtan/flash/6.jpg" data-size="353x93">&lt;img src="/posts/hack/xtan/flash/6.jpg"
srcset="/posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_1024x0_resize_q75_box.jpg 1024w"
width="353"
height="93"
loading="lazy"
alt="image-6">
&lt;/a>
&lt;figcaption>image-6&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>找到他被调用的地方, 加一行日志跟踪一下输出&lt;/p>
&lt;p>&lt;figure style="flex-grow: 555; flex-basis: 1333px">
&lt;a href="/posts/hack/xtan/flash/7.jpg" data-size="400x72">&lt;img src="/posts/hack/xtan/flash/7.jpg"
srcset="/posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_1024x0_resize_q75_box.jpg 1024w"
width="400"
height="72"
loading="lazy"
alt="image-7">
&lt;/a>
&lt;figcaption>image-7&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>调试运行之后输出的字符串为:&lt;/p>
&lt;p>&lt;figure style="flex-grow: 469; flex-basis: 1127px">
&lt;a href="/posts/hack/xtan/flash/14.jpg" data-size="902x192">&lt;img src="/posts/hack/xtan/flash/14.jpg"
srcset="/posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_1024x0_resize_q75_box.jpg 1024w"
width="902"
height="192"
loading="lazy"
alt="image-14">
&lt;/a>
&lt;figcaption>image-14&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>&lt;strong>这个地址跟第四步的请求地址就是同一个地址!&lt;/strong> 这就是我要找的东西, 现在只需要反编译&lt;code>Sounds.swf&lt;/code>, 把&lt;code>getURL&lt;/code>的算法抄下来就可以了! 想法很美好, 但现实很骨感, &lt;code>Sounds.swf&lt;/code>反编译后发现经过了加密混淆, 反编译出来的代码是这样的&lt;/p>
&lt;p>&lt;figure style="flex-grow: 116; flex-basis: 280px">
&lt;a href="/posts/hack/xtan/flash/8.jpg" data-size="821x702">&lt;img src="/posts/hack/xtan/flash/8.jpg"
srcset="/posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_1024x0_resize_q75_box.jpg 1024w"
width="821"
height="702"
loading="lazy"
alt="image-8">
&lt;/a>
&lt;figcaption>image-8&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹&lt;/p>
&lt;p>&lt;figure style="flex-grow: 327; flex-basis: 786px">
&lt;a href="/posts/hack/xtan/flash/9.jpg" data-size="678x207">&lt;img src="/posts/hack/xtan/flash/9.jpg"
srcset="/posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_1024x0_resize_q75_box.jpg 1024w"
width="678"
height="207"
loading="lazy"
alt="image-9">
&lt;/a>
&lt;figcaption>image-9&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>这url不就是刚才输出的地址吗, 显然此处的代码是将url中的&lt;code>%s&lt;/code>, &lt;code>%d&lt;/code>替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个&lt;code>Sounds.swf&lt;/code>是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用&lt;code>getURL&lt;/code>这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询&lt;code>ActionScript&lt;/code>资料, 发现可以通过&lt;code>ExternalInterface&lt;/code>, 让&lt;code>.swf&lt;/code>将接口暴露出来提供外部Flash容器调用, 对于&lt;code>player.swf&lt;/code>来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用&lt;code>WinForm&lt;/code>的&lt;code>Shockwave Flash&lt;/code>组件.&lt;/p>
&lt;p>于是修改&lt;code>player.swf&lt;/code>的源码, 在&lt;code>Main&lt;/code>中定义一段可供外部调用的函数&lt;/p>
&lt;p>&lt;figure style="flex-grow: 210; flex-basis: 505px">
&lt;a href="/posts/hack/xtan/flash/10.jpg" data-size="825x392">&lt;img src="/posts/hack/xtan/flash/10.jpg"
srcset="/posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_1024x0_resize_q75_box.jpg 1024w"
width="825"
height="392"
loading="lazy"
alt="image-10">
&lt;/a>
&lt;figcaption>image-10&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>其中函数名为&lt;code>swfExtGetypURL&lt;/code>, 入参为&lt;code>string&lt;/code>类型的乐谱ID, 函数首先检查&lt;code>clib&lt;/code>是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用&lt;code>Clib&lt;/code>的&lt;code>getURL&lt;/code>返回乐谱信息url.&lt;/p>
&lt;p>上文提到&lt;code>clib&lt;/code>是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化&lt;code>clib&lt;/code>的函数&lt;code>onSwComplete&lt;/code>, 仿照其代码, 在&lt;code>Clib&lt;/code>中写一段初始化代码如下:&lt;/p>
&lt;pre>&lt;code>public static function myLoadSwf() : void
{
swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady);
swfLoader.load(new URLRequest(Config.flash_sound_lib_URL));
}
internal static function onSoundsReady(arg1:Event) : void
{
swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
var loc2:* = loc1.getDefinition(&amp;quot;Sounds&amp;quot;) as Class;
CLib.clib = loc2.cLibInit();
}
&lt;/code>&lt;/pre>&lt;p>并将原来的初始化代码&lt;code>loadSwf&lt;/code>修改为:&lt;/p>
&lt;pre>&lt;code>//修改前
public static function loadSwf(arg1:Function):void
{
swfLoadCompleteCallBack = arg1;
swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
ui.HUD.show(&amp;quot;加载音色库&amp;quot;, 0);
swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
swfLoadCompleteCallBack();
return;
}
//修改后
public static function loadSwf(arg1:Function):void
{
swfLoadCompleteCallBack = arg1;
if(null == CLib.clib)
{
swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
ui.HUD.show(&amp;quot;加载音色库&amp;quot;, 0);
swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
} else {
swfLoadCompleteCallBack();
}
return;
}
&lt;/code>&lt;/pre>&lt;p>最后在&lt;code>Mian&lt;/code>类的初始化函数&lt;code>init1&lt;/code>中调用&lt;code>myLoadSwf&lt;/code>&lt;/p>
&lt;p>&lt;figure style="flex-grow: 190; flex-basis: 456px">
&lt;a href="/posts/hack/xtan/flash/12.jpg" data-size="574x302">&lt;img src="/posts/hack/xtan/flash/12.jpg"
srcset="/posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_1024x0_resize_q75_box.jpg 1024w"
width="574"
height="302"
loading="lazy"
alt="image-12">
&lt;/a>
&lt;figcaption>image-12&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;p>大功告成, 现在 &lt;code>player.swf&lt;/code> 在启动的时候就会调用我添加的 &lt;code>myLoadSwf&lt;/code> 函数, 开始加载 &lt;code>Sounds.swf&lt;/code> 并初始化到 &lt;code>Clib&lt;/code> 中. 而原来的&lt;code>loadSwf&lt;/code>会先判断&lt;code>Sounds.swf&lt;/code>有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过&lt;code>Shockwave Flash&lt;/code>组件调用&lt;code>player.swf&lt;/code>暴露出来的外部接口就可以了, 调用方式如下:&lt;/p>
&lt;pre>&lt;code>axShockwaveFlash.CallFunction(
string.Format(&amp;quot;&amp;lt;invoke name=\&amp;quot;swfExtGetypURL\&amp;quot; returntype=\&amp;quot;xml\&amp;quot;&amp;gt;&amp;lt;arguments&amp;gt;&amp;lt;string&amp;gt;{0}&amp;lt;/string&amp;gt;&amp;lt;/arguments&amp;gt;&amp;lt;/invoke&amp;gt;&amp;quot;, ypid));
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>axShockwaveFlash&lt;/code> 是我在c#代码中定义的Flash容器组件成员变量, 它加载了&lt;code>player.swf&lt;/code>作为内容, 代码中调用到的扩展函数名称为&lt;code>swfExtGetypURL&lt;/code>, 也就是刚才在&lt;code>player.swf&lt;/code>的&lt;code>Main&lt;/code>中定义的&lt;code>ExternalInterface&lt;/code>类型的函数, 参数为&lt;code>string&lt;/code>类型的乐谱ID&lt;/p>
&lt;/blockquote>
&lt;p>得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:&lt;/p>
&lt;pre>&lt;code>&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;yp_create_time=&amp;lt;yp_create_time&amp;gt;1601587012&amp;lt;/yp_create_time&amp;gt; &amp;lt;br/&amp;gt;
yp_title=&amp;lt;yp_title&amp;gt;Summer（菊次郎的夏天）&amp;lt;/yp_title&amp;gt; &amp;lt;br/&amp;gt;
yp_page_count=&amp;lt;yp_page_count&amp;gt;5&amp;lt;/yp_page_count&amp;gt; &amp;lt;br/&amp;gt;
yp_page_width=&amp;lt;yp_page_width&amp;gt;1051&amp;lt;/yp_page_width&amp;gt; &amp;lt;br/&amp;gt;
yp_page_height=&amp;lt;yp_page_height&amp;gt;1487&amp;lt;/yp_page_height&amp;gt; &amp;lt;br/&amp;gt;
yp_is_dadiao=&amp;lt;yp_is_dadiao&amp;gt;1&amp;lt;/yp_is_dadiao&amp;gt; &amp;lt;br/&amp;gt;
yp_key_note=&amp;lt;yp_key_note&amp;gt;2&amp;lt;/yp_key_note&amp;gt; &amp;lt;br/&amp;gt;
yp_is_yanyin=&amp;lt;yp_is_yanyin&amp;gt;0&amp;lt;/yp_is_yanyin&amp;gt; &amp;lt;br/&amp;gt;
ypad_url=&amp;lt;ypad_url&amp;gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad&amp;lt;/ypad_url&amp;gt;ypad_url2=&amp;lt;ypad_url2&amp;gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2&amp;lt;/ypad_url2&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
&lt;/code>&lt;/pre>&lt;p>&lt;strong>接下来, 只需要解析响应并下载资源就可以了&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>解析 &lt;code>yp_page_count&lt;/code> 节点可以得到乐谱的总页数&lt;/li>
&lt;li>解析&lt;code>ypad_url&lt;/code>节点, 并在节点中url的最后拼接&lt;code>.乐谱页数.png&lt;/code>, 即可得到真实的乐谱图片地址&lt;/li>
&lt;li>解析&lt;code>ypad_url&lt;/code>节点, 截取 &lt;code>_&lt;/code> 的前半部分, 再拼接 &lt;code>_prev.jpg&lt;/code>还可以得到乐谱的封面图&lt;/li>
&lt;li>解析&lt;code>ypad_url2&lt;/code>节点即可获取真实的&lt;code>.ypa2&lt;/code>格式的播放文件&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式&lt;/p>
&lt;/blockquote>
&lt;p>以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对&lt;code>player.swf&lt;/code>和&lt;code>Sounds.swf&lt;/code>做一些修改, 首先修改&lt;code>player.swf&lt;/code>的&lt;code>Config&lt;/code>类, 把其中关键的加载&lt;code>Sounds.swf&lt;/code>和获取封面的地址修改为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;pre>&lt;code>//获取曲谱封面的地址
public static const flash_prev_yp_info_URL:String = &amp;quot;http://localhost:7777/yuepu/preview&amp;quot;;
//获取Sounds.swf的地址
public static const flash_sound_lib_URL:String = &amp;quot;http://localhost:7777/yuepu/flash/sound&amp;quot;;
&lt;/code>&lt;/pre>&lt;p>然后修改&lt;code>Sounds.swf&lt;/code>在上文查找到的生成url串, 把串的前缀修改为&lt;code>localhost:7777&lt;/code>&lt;/p>
&lt;pre>&lt;code>gstaticInitter.asciz = &amp;quot;http://localhost:7777/yuepu/info?ypid=%d&amp;amp;sccode=%s&amp;amp;r1=%d&amp;amp;r2=%d&amp;amp;input=%s&amp;quot;;
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>此处&lt;code>Sounds.swf&lt;/code>修改url后, 调用&lt;code>getURL&lt;/code>返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求&lt;/p>
&lt;/blockquote>
&lt;p>最后在乐谱工具中开启一个端口为&lt;code>7777&lt;/code>的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了&lt;/p>
&lt;blockquote>
&lt;p>乐谱工具是我基于&lt;code>C#&lt;/code>开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自&lt;code>localhost:7777&lt;/code>的HTTP请求&lt;/p>
&lt;/blockquote>
&lt;p>&lt;figure style="flex-grow: 101; flex-basis: 243px">
&lt;a href="/posts/hack/xtan/flash/13.jpg" data-size="602x593">&lt;img src="/posts/hack/xtan/flash/13.jpg"
srcset="/posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_1024x0_resize_q75_box.jpg 1024w"
width="602"
height="593"
loading="lazy"
alt="image-13">
&lt;/a>
&lt;figcaption>image-13&lt;/figcaption>
&lt;/figure>&lt;/p>
&lt;hr>
&lt;h2 id="adobe-flash彻底停用后的补偿方案">Adobe Flash彻底停用后的补偿方案&lt;/h2>
&lt;p>过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具&lt;code>WinForm&lt;/code>的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, &lt;strong>直接导致&lt;code>Shockwave Flash&lt;/code>也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.&lt;/strong>&lt;/p>
&lt;p>既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的&lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的&lt;code>.swf&lt;/code>文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令&lt;/p>
&lt;pre>&lt;code>flashplayer_sa_debug.exe player.swf?id=1
&lt;/code>&lt;/pre>&lt;p>即可启动 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a> 并打开作为参数的 &lt;code>.swf&lt;/code> 文件, 在&lt;code>C#&lt;/code>中则可以使用&lt;code>Process&lt;/code>启动, 代码如下:&lt;/p>
&lt;pre>&lt;code>Process.Start(&amp;quot;flashplayer_sa_debug.exe&amp;quot;, &amp;quot;Main.swf?id=1&amp;quot;);
&lt;/code>&lt;/pre>&lt;p>但是在实际使用中, 发现通过命令行或者程序启动的 &lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a> 打开的&lt;code>player.swf&lt;/code>无法发送&lt;code>localhost&lt;/code>的网络请求, 弹窗报错如下:&lt;/p>
&lt;pre>&lt;code>SecurityError: Error #2119: 安全沙箱冲突
&lt;/code>&lt;/pre>&lt;p>但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求&lt;code>localhost&lt;/code>是因为他在用户文件夹下&lt;code>\AppData\Roaming\Macromediax\Flash Player\#Security\FlashPlayerTrust&lt;/code>创建了信任文件&lt;code>intellij_idea.cfg&lt;/code>, 文件内容即IDEA生成&lt;code>.swf&lt;/code>的完整文件夹路径&lt;/p>
&lt;pre>&lt;code>E:\flash\bin-debug
&lt;/code>&lt;/pre>&lt;p>&lt;strong>所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求&lt;code>localhost&lt;/code>了&lt;/strong>&lt;/p>
&lt;p>现在解决了乐谱无法播放的问题, 但是由于&lt;a class="link" href="https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe" target="_blank" rel="noopener"
>flash_player_debugger&lt;/a>不支持&lt;code>ExternalInterface&lt;/code>, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用&lt;code>getURL&lt;/code>获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.&lt;/p>
&lt;p>首先删除会引起报错的&lt;code>player.swf&lt;/code>中使用&lt;code>ExternalInterface&lt;/code>定义的接口&lt;code>swfExtGetypURL&lt;/code>, 修改 &lt;code>myLoadSwf&lt;/code>中定义的回调函数 &lt;code>onSoundsReady&lt;/code>, 在此前初始化&lt;code>clib&lt;/code>的基础上加上调用&lt;code>getURL&lt;/code>返回的url, 并提取参数请求&lt;code>localhost:7777&lt;/code>, 修改后的代码如下:&lt;/p>
&lt;pre>&lt;code>internal static function onSoundsReady(arg1:Event) : void
{
swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
var loc2:* = loc1.getDefinition(&amp;quot;Sounds&amp;quot;) as Class;
CLib.clib = loc2.cLibInit();
//添加的部分
if(utils.Func.ypadId != 0) {
var url:* = CLib.getURL(utils.Func.ypadId);
var args:* = &amp;quot;?&amp;quot; + url.split(&amp;quot;?&amp;quot;)[1]
urlLoader3 = new flash.net.URLLoader();
urlLoader3.load(new flash.net.URLRequest(&amp;quot;http://localhost:7777/yuepu/fetch&amp;quot; + args));
}
}
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>&lt;code>utils.Func.ypadId&lt;/code>中存储了播放器启动时传入的乐谱ID参数&lt;/p>
&lt;/blockquote>
&lt;p>此时当&lt;code>clib&lt;/code>初始化完成之后, 会使用传入的乐谱ID直接调用&lt;code>getURL&lt;/code>, 截取返回url的参数部分, 再将参数通过HTTP请求上报到&lt;code>localhost:7777&lt;/code>. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题&lt;/p>
&lt;pre>&lt;code>//监听曲谱地址
if (httpListenerContext.Request.Url.LocalPath.Equals(&amp;quot;/yuepu/fetch&amp;quot;))
{
httpListenerContext.Request.QueryString[&amp;quot;ypid&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;sccode&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;r1&amp;quot;];
httpListenerContext.Request.QueryString[&amp;quot;r2&amp;quot;];
...
}
&lt;/code>&lt;/pre>&lt;p>不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用&lt;code>Process&lt;/code>启动的指定&lt;code>WindowStyle&lt;/code>为&lt;code>ProcessWindowStyle.Hidden&lt;/code>就可以无感使用了&lt;/p>
&lt;pre>&lt;code>Process.Start(new ProcessStartInfo()
{
FileName = &amp;quot;flashplayer_sa_debug.exe&amp;quot;,
WindowStyle = ProcessWindowStyle.Hidden,//关键代码
Arguments = &amp;quot;Main.swf?id=64&amp;quot;,
})
&lt;/code>&lt;/pre>&lt;h2 id="至此已经彻底解决flash停用的影响了-但是仍然存在另一个问题-adobe禁用flash之后-某琴吧也对播放器进行了换代-停用了旧的flash播放器-改用安装版的exe播放器-同时exe播放器不再使用flash用的ypa2格式播放器文件-且删除了所有ypa2资源-并采用新的ypdx文件-新格式的文件flash无法播放-因此破解exe版本的播放器又被放在日程上了">至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的&lt;code>.ypa2&lt;/code>格式播放器文件, 且删除了所有&lt;code>.ypa2&lt;/code>资源, 并采用新的&lt;code>.ypdx&lt;/code>文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了&amp;hellip;&lt;/h2></description></item></channel></rss>