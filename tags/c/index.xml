<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Acgnu+</title><link>/tags/c/</link><description>Recent content in C on Acgnu+</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 20 Feb 2025 00:50:44 +0800</lastBuildDate><atom:link href="/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 LuCI 编写用于 OpenWRT 的远程开机服务</title><link>/posts/embeded/wol-luci/</link><pubDate>Thu, 20 Feb 2025 00:50:44 +0800</pubDate><guid>/posts/embeded/wol-luci/</guid><description>前言 最近更换了宽带, 拿到了公网IPv6, 刚好又换了一台 小米AX3000T 路由器, 搭载了 ARM 架构的 MT7981B 处理器, 使得安装 OpenWRT 成为了可能. 之前编写的远程开机程序是轮询模式的, 在拥有公网的现在, 本着折腾的心态, 就干脆改造成服务端监听模式, 顺便为其增加 UI 方便配置. 查阅资料后了解到可以使用 LuCI, 不过网上教程基本上是 UI 和 服务分离, 这需要分别编译两个软件包 (opkg), 而我其实希望只有一个软件包, 因此有了这篇文章
需求 编写带有 LuCI 的 OpenWRT 软件包 ( Package ), 包含 UI 和服务两部分, 作为服务运行并监听请求, 最终实现效果如下:
预览
前置条件 公网 IPv6 域名 (可选) OpenWRT 或基于 OpenWRT 的分支系统, 本人安装的是 ImmortalWRT, 后文将只写 ImmortalWRT 开发准备 首先需要安装环境, 基于 OpenWRT 的软件包开发通常可以选择使用 SDK 或者完整的源码, 我这边由于是 ImmortalWRT 分支系统, 所以直接下载它的 源码</description></item><item><title>基于Padavan路由器系统的远程网络唤醒(WOL)工具开发</title><link>/posts/embeded/wol/</link><pubDate>Mon, 06 Mar 2023 00:50:44 +0800</pubDate><guid>/posts/embeded/wol/</guid><description>目录 需求 准备工作 基本思路 编写服务端 编写客户端 测试效果 遇到的问题 需求 由于有时需要远程家里的电脑所以是24小时待机的, 然而大部分时间其实都是用不上的, 后来发现家里电费居高不下跟电脑有很大的关系, 财库已空的我决定设置一套网络唤醒
首先, 需要购买专用的唤醒设备例如网卡, 开关, 支持WOL的路由器之类的就不考虑了, 家里也没有多余的设备, 于是打算给路由器刷第三方系统之后由路由器来唤醒, 我的路由器是小米的AC2100, 刷了Padavan, 刷完后自带两个内网管理插件
DDNS插件: 因为申请不到公网IP, 所以用不了 Zerotier内网穿透插件: 配置后家里的网络连不上Zerotier服务, 查了一下说是被某些运营商屏蔽了(无语), 所以也用不了 虽然可以考虑刷支持其他内网穿透工具的固件, 但不想一个一个试, 且免费的内网穿透稳定性和速率通常都不太行, 最终决定自行编写一个WOL程序放到路由器执行
准备工作 一台支持运行三方程序的路由器, OpenWRT或Padavan等. 在路由器「DHCP」管理页中为需要唤醒的电脑设置固定IP
电脑设置启用网络唤醒. 如何设置网络唤醒? 以我的设备为例:
主板「B460M AORUS ELITE (rev. 1.0) 」默认开启了网络唤醒, 无需修改任何设置.
网卡「Intel(R) Ethernet Connection (12) I219-V」设置如下:
关闭「以太网节能」, 可以解决关机时间过长后无法唤醒的问题, 其他唤醒相关设置均已默认开启, 无需改动
1219v 测试效果.</description></item><item><title>在Windows上使用基于WSL的Ubuntu搭建MIPSEL处理器的C语言交叉编译环境</title><link>/posts/embeded/mipsel/</link><pubDate>Fri, 03 Mar 2023 00:50:44 +0800</pubDate><guid>/posts/embeded/mipsel/</guid><description>目录 硬件准备 Windows上的开发环境准备 使用Ubuntu安装MIPSEL架构的交叉编译器 使用C编写Hello Word!测试 遇到的问题 一点感想 硬件准备 一台基于Linux内核, 采用MIPS处理器的设备, 例如我的小米AC2100, Padavan系统 一台支持Windows子系统(WSL)的Windows 10的电脑 Windows上的开发环境准备 安装Visual Studio 2019.9 或以上版本 添加Linux开发环境工具集 (安装时已勾选的可跳过) 在开始菜单中打开「Visual Studio Installer」 找到Visual Studio 2019, 点击右侧的「修改」按钮 找到「使用C++的Linux开发」, 并勾选保存 开启Windows子系统(WSL)并安装Ubuntu, 如何启用Win10的WSL?
安装好后, 以下可按需修改 修改root密码 设置默认以root启动 修改镜像源 为Visual Studio配置跨平台编译
具体配置方式可参考微软官方教程 如何在Visual Studio 2019中配置WSL交叉编译环境? 如何在Visual Studio 2022中配置WSL交叉编译环境?
需要注意的是, 开始菜单中直接搜索「wsl」可以打开一个命令窗口执行Linux命令, 而打开Ubuntu窗口也可以执行命令, 我是在Ubutnu中安装的编译工具, 因此在Visual Studio的「WSL-GCC-Debug」配置中, 「WSL」一栏需要选「Ubuntu2204」 WSL配置 使用Ubuntu安装MIPSEL交叉编译器 在Ubuntu中执行下列命令</description></item></channel></rss>