[{"content":"背景 最近发现一直在用的某抑云音乐越来越不行了, 没版权下架歌曲我可以理解, 但下架了也不告诉具体下架了哪些歌曲, 害得我都不知道该怎么找. 更无语的是我自己上传到某易云盘的歌曲都会因为版权问题无法添加到歌单, 而它自身的本地播放功能做的又太垃圾, 于是只能另谋出路, 在Google Play上找到一款本地播放器, 兼顾美观和功能简单实用, 不过免费版有点小广告, 然后试了几款去广告的插件, 都不能完美去除, 而我作为强迫症决定一定要处理掉\n目标 去掉各处的广告以及订购按钮\nAPP界面以及广告  image-1 \n开始破解 打开Jadx, 直接把安装包即.apk文件拖进去, 发现软件没有加壳, 顺利反编译出了播放器源码, 然后直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n 源码 \n可以看到虽然源码没有加壳, 但还是有做混淆的, 不过问题不大, 首先通过Android Device Monitor解析一下当前页面的布局\n 布局 \n发现主界面中的歌曲列表部分组件的id为content, 于是全局搜索@+id/content\n content \n发现多处搜索结果, 根据当前APP所在界面以及布局文件命名推测mian_layout应该是其布局文件, 分别看看上面的viewAnim和viewAnimWithoutBackground, 这两个id在当前Android Device Monitor解析的界面中都能找到对应节点, 验证了猜想, 如下图\n DDMS \n现在要找展示广告的组件了, 通过刚才的搜索结果可以看到, 在main_layout中并没有存在疑似专门用于展示广告的节点, 所以还是很有可能是在运行过程中动态添加的, 于是我们直接搜索main_layout, 找到使用到此布局的MainActivity\n 搜索Activity \n由于暂时没有其他线索, 先看看onCreate源码能不能发现什么\n onCreate \n可以看到实现比较简单, 再看看在父类的代码, 来到D2方法, 有多个实现, 这里看MainActivity的实现\n D2 \n都是一些混淆代码, 咱也看不懂, 凭直觉都过一下, 此时在D2中就发现可疑类GooglePlayPurchaseChecker\n D2实现 \n考虑到APP是从Google Play上下载的, 可以在Google Play上购买进行解锁, 那么这个类名就显得很可疑了, 跟踪进去看看都写了啥\n checker-1 \n首先直接内部调用 aVar.g, 继续跟踪\n checker-2 \n发现这里的LinkedHashMap中存放了名为stellio_all_inclusive和stellio_premium的键, 首先这俩键的名字就很可疑, 而他们的值存储为布尔, 此时注意到有枚举ResolvedLicense用于分辨APP解锁状态\n 枚举 \n综合起来推测这个Map应该就是用于初始化一个授权值的, 以给定键的布尔值是否为true来判断应用是否已经购买, 那么我只要在初始化的时候把这个Map的值固定写死成true, 应该就可以让APP认为已经购买过了, 编写Xposed代码如下\nfindAndHookConstructor(\u0026quot;air.stellio.player.Helpers.GooglePlayPurchaseChecker\u0026quot;, loadPackageParam.classLoader, \u0026quot;air.stellio.player.Activities.u\u0026quot;, \u0026quot;org.solovyev.android.checkout.F\u0026quot;, Map.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { MyLog.log(\u0026quot;hookin GooglePlayPurchaseChecker()\u0026quot;, doLog); Map\u0026lt;String, Boolean\u0026gt; arg3 = (Map\u0026lt;String, Boolean\u0026gt;) param.args[2]; if(null == arg3) { arg3 = new LinkedHashMap\u0026lt;\u0026gt;(); param.args[2] = arg3; } arg3.put(\u0026quot;stellio_all_inclusive\u0026quot;, true); arg3.put(\u0026quot;stellio_premium\u0026quot;, true); } }); 观察GooglePlayPurchaseChecker类中的赋值代码可以发现, 主要是通过构造函数将Map的值存储的, 因此使用Xposed的findAndHookConstructor去挂钩GooglePlayPurchaseChecker的构造函数, 在构造函数执行之前, 修改传入的第三个参数Map, 把键为stellio_premium和stellio_all_inclusive的值存为true, 这样当构造函数执行的时候, 会永远认为这是已订购的了\n安装模块并运行, 此时可以发现APP中的广告以及订购按钮都没有了\n Yeah \n","date":"2021-11-05T00:50:44+08:00","image":"/posts/hack/xstellio/cover_hu18a0dfe24013f6b0b7ee4adfea89b908_253760_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xstellio/","title":"XStellio Player破解专业版"},{"content":"背景 由于个人喜好, 比较喜欢直角屏的手机, 但市面上的手机放眼望去只有三星Note系列符合我的爱好, 遂购买三星Note 10御用, 然而这手机虽然造型是方方正正的, 但是UI却跟S系列一样到处都是圆角, 这让我很不舒服, 于是有了此文章\n目标 将系统UI的圆角修改为直角\n三星ONEUI修改前后对比图  image-1 \n基础知识 再开始之前, 首先需要了解一下基础知识\n1. 安卓系统的UI构成\n 安卓系统的界面呈现都是由内置在系统的APP构成的, 其APP一般位于 /system/app 和 /system/priv-app, 还有一个系统APP引用的公共框架APP, 位于 /system/framework/framework-res.apk, 部分系统例如Flyme在此目录还会有另外一个自己的框架APP, 命名通常以自家OS命名, 此处不作过多介绍, 界面中比较常见的APP如下 framework-res.apk 系统应用引用的界面, 例如提示信息弹窗 SystemUI.apk 系统通知栏界面, 通知弹窗界面 Settings.apk 系统设置界面, OneUI中此APP名称为 SecSettings.apk Messages.apk 短信界面, OneUI中为SamsungMessages_11.apk Gallery.apk 相册界面, OneUI中为SamsungGallery2018.apk Dialer.apk 拨号器,通话记录,联系人界面, OneUI中为SamsungDialer.apk Clock.apk 时钟,闹钟,计时器界面, OneUI中为ClockPackage.apk Finder.apk OneUI启动器(桌面)独有的搜索组件  2. 安卓实现圆角的基本方式\n 简单的实现安卓圆角可以通过\u0026lt;Shape\u0026gt;来实现, 其中\u0026lt;Corner\u0026gt;节点的属性xxxRadius为关键属性, 例如bottomRightRadius 通常是APP开发者为了减少代码重复率, 会定义一个统一风格而定义的一个统一的资源文件dimens.xml, 所有用到同样值的地方都会引用这个文件, 方便修改和风格统一  开始修改 首先修改framework-res.apk, 由于需要对源码反编译和回编译, 所以需要用到安卓反编译工具 ApkTool, 本人修改时使用的版本为v2.4.1\n首先使用命令进行反编译\napktool d framework-res.apk 中途没有错误则表示反编译成功\n image-4 \n即可在当前目录生成反编译后的源码文件夹\n image-2 \n目录简单介绍下\n assets 为APP所用到的额外资源文件包, 可以是任何东西 original 顾名思义存放原始文件 res APP所用到的资源文件, 例如图标, 国际化文本, 图形, 布局文件等 unknown 工具无法解析的文件, 回编译后会按照原样编译进去 AndroidManifest.xml APP清单文件, 记录了版本号, 包名, 权限等重要信息 apktool.yml 记录了ApkTool回编译时需要参考的信息  可以看到在此framework-res.apk中仅定义了资源文件, 并没有代码文件, 有代码的APP将在下文介绍, 在此framework-res.apk中, 只需要关注res文件夹下的资源文件就行, 我们把整个文件夹用IDEA打开, 然后根据圆角的基础知识, 直接简单粗暴先从搜索Radius开始\n image-3 \n发现多处结果, 我们缩小一下搜索范围, 可以自己写一个小的安卓应用, 定义个圆角并尝试不同圆度, 根据多次测试观察到资源文件中圆度值为26.0dip的比较符合, 因此搜索radius=\u0026quot;26.0dip, 可以发现结果少了很多\n image-5 \n接着根据资源文件命名可以大致猜出这些对应的都是哪些部分的圆角, 例如notification_template_view_bg.xml应该就是定义的通知模板背景, 根据经验这些都可以改成直角, 因此直接将所有的26.0dip修改为0.0dip\n之后, 为了更彻底的覆盖所有部分, 继续深入搜索, 只搜索26.0dip, 发现更多结果\n image-6 \n例如在dimens.xml中定义的一些值为26.0dip的数据, 需要仔细观察其name, 因为不是所有值为26.0dip的都需要修改, 例如第一行的car_seekbar_padding看名字就知道是一个填充值, 这个是不需要修改的, 但是下面的sem_menu_popup_corner_radius这种是需要修改的, 主要是经验和推测, 我们将这些需要修改的统统修改为0.0dip\n所有圆角修改完之后, 开始回编译, 在反编译出来的目录下, 执行命令\napktool b framework-res  image-7 \n像这样没有错误说明回编译成功了, 打开framework-res文件夹, 会发现里面多了两个文件夹\n image-8 \n build 回编译构建编译后的资源文件 dist 回编译后生成的APK文件  打开dist文件夹, 可以看到生成的framework-res.apk文件, 接下来需要将它替换到系统里去\n我们有四中方式替换\n 使用电脑ADB工具执行命令行替换 (简单快捷, 有一定风险) 复制到手机使用RE管理器替换 (风险较大) 制作成单刷包替换 (安全性较好, 稍微麻烦一点) 制作成ROM刷机替换 (性价比不高, 不考虑)  由于可能需要多次测试效果, 且有多个APK需要修改, 这里采用第一种方式, 需要ROOT\n步骤如下\n 打开手机里的USB调试 电脑安装手机的ADB驱动 (每个厂家的手机不一样), 装好后使用USB连接手机 使用安卓ADB工具执行命令如下  //1.将新生成的APK复制到手机存储根目录 adb push framework-res.apk /sdcard/framework-res.apk //2.执行shell adb shell //3.获取超级用户权限 su //4.复制手机存储的framework-res.apk到系统框架目录 cp /sdcard/framework-res.apk /system/framework/framework-res.apk //5.将复制进去的新APK重设rw-r-r权限 chmod 644 /system/framework/framework-res.apk //6.退出shell exit //7.重启手机 adb reboot 经过这一系列操作后, 如果没有出现意外, 手机重新开机后就可以看到修改后的效果了, 首先迎面而来的就是手机基础弹窗已经变成直角了\n image-9 \n 注意!!! 通常为了防止意外情况发生导致无法开机,需要通过Recovery备份一次系统,并将备份的系统复制到电脑以防万一,嫌麻烦的话至少也得有一份完整的刷机包,最好制作一份单刷包,如果修改后无法正常进入系统,推荐优先使用单刷包,如果单刷包无法生效,可以使用Recovery还原系统,如果没有备份系统的,则使用完整的刷机包重刷,但将丢失所有数据(双清的情况),关于单刷包的制作,我将在文章尾部补充\n 但是这还远远不够, 接下来开始处理SecSettings.apk, 仍然使用ApkTool按照上文命令进行反编译, 不过在此之前, 需要先给ApkTool安装framework-res.apk\n 由于系统APP会引用到框架APP, 因此需要给ApkTool安装框架APP, 才能继续反编译系统APP\n 通过如下命令安装framework-res.apk\napktool if framework-res.apk 安装之后就可以开始反编译SecSettings.apk了, 反编译成功之后会发现相比较framework-res.apk, 多出了几个文件夹\n image-10 \n其中smali和smali_classesX 就是应用的源代码文件, 为.smali格式的Java字节码, 类似C程序反编译出来的汇编代码, 我们先使用上文的知识将圆角值为26.0dip的圆角修改为0.0dip, 替换进系统后发现只有一部分界面的圆角变成了直角\n 文章编辑于2021年8月, 系统修改于2020年7月, 当时没有保留截图, 现在也没有重新替换的必要, 因此这部分只能描述了\n 继续检查所有可能造成圆角的值为26.0dip的.xml文件, 仍然无法找到可能存在问题的部分, 此时将检查范围扩大到源代码文件, 为了方便阅读, 首先使用Jadx反编译SecSettings.apk, 并将反编译后的.java源码导入IDEA进行观察, 搜索26发现一个可疑的方法initRoundedCorner\n image-11 \n此处推测应该是初始化一个圆度为26.0dip的圆角, 而且这个类是很多类的父类, 应该是从代码层指定了圆角的圆度, 但是此时的.java源码无法直接修改, 我们回到ApkTool反编译出来而得到的.smali源码, 根据类名方法名找到对应在.smali代码中的initRoundedCorner如下\n image-12 \nsmali代码中的第一行也是定义了一个值为26的变量, 直接将0x26改成0x0, 然后回编译替换进系统观察效果, 此时可以看到界面基本上已经变成直角了\n image-13 \n但是进入某些功能的深层选项时会发现仍然有一小部分是圆角的, 不过仔细观察这部分的圆角角度值大概在15.0dip到16.0dip左右, 因此继续搜索圆角值为这些的部分, 根据名称将可能的地方修改为0.0dip即可, 至此SecSettings.apk全部改完\n接下来按照同样的步骤修改上文列出的剩余的系统APP即可\n关于单刷包的制作 关于单刷包是什么, 有什么作用, 优缺点等网上已经有大量介绍, 此处不多说明, 仅介绍Note10下单刷包的制作\n制作OneUI单刷包\n首先我们需要一个完整的.zip刷机包, 以我的为例, 假定我们需要保留的文件为SecSettings.apk, 需要删掉除SecSettings.apk及其父文件夹以外的东西\n 尽量不要解压修改, 有时候解压了修改再压缩回去会出现奇奇怪怪的问题, 导致签名无法识别, 无法刷入\n  image-14 \n例如此处图示的部分, 红框以外的都是可以删除的, 删完后如下\n image-15 \n 从原始刷机包删除目标以外的东西做成的单刷包通常用于备份恢复, 如果是为了替换成其他文件, 例如需要做成单刷修改后的SecSettings.apk, 则删除多余文件后, 将修改后的SecSettings.apk替换到单刷包里的对应目录即可\n 接下来需要修改刷机脚本, 原始的刷机脚本通常会做很多事, 但是单刷包不需要, 我们打开位于META-INF/com/google/android下的updater-script文件, 可以看到如下代码\n image-16 \n脚本语言为updater-script, 具体语法以及含义可以自行查阅, 此处不多作介绍, 我们将内容修改如下\nui_print(\u0026quot;Mounting system\u0026quot;); ui_print(\u0026quot;\u0026quot;); mount(\u0026quot;ext4\u0026quot;, \u0026quot;EMMC\u0026quot;, \u0026quot;/dev/block/platform/soc/1d84000.ufshc/by-name/system\u0026quot;, \u0026quot;/system\u0026quot;); ui_print(\u0026quot;Copying modules\u0026quot;); ui_print(\u0026quot;\u0026quot;); package_extract_dir(\u0026quot;system\u0026quot;, \u0026quot;/system\u0026quot;); ui_print(\u0026quot;Unmounting system\u0026quot;); ui_print(\u0026quot;\u0026quot;); unmount(\u0026quot;/system\u0026quot;); show_progress(0.100000, 0); 其中关键代码为 mount挂载/system为可写分区, package_extract_dir将压缩包中system文件夹全部复制到系统的/system目录, unmount取消挂载, 其他的例如ui_print和show_progress仅为提示作用, 修改完成后, 一个单刷包就制作完毕了, 可以像普通刷机一样直接刷进系统\n结语 由于安卓的开源特性使得安卓的可玩性和定制性非常高, 我所入手的每一部安卓手机都会进行ROOT并做一定程度的修改, 最开始的时候参考前辈的教程修改了系统APK的各种背景, 特效, 音效, 性能调优, 开机动画之类的, 随着手机UI越来越美观功能以及本人时间精力越来越有限, 现在对这种定制需要也已经越来越少了, 加之谷歌对安卓开源的策略调整以厂商的限制, 进行定制也越来越麻烦了, 但我仍会继续热爱安卓, 希望安卓开放的特性能够保持下去\n","date":"2021-08-23T00:50:44+08:00","image":"/posts/hack/xrom/oneui/cover_hu84818c9c9d4fdca57166891297ad3a69_124905_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xrom/oneui/","title":"三星ONEUI修改记录"},{"content":"背景 由于某些需要, 进入某大楼的时候必须用他们物业指定的APP刷门禁, 我安装的时候是6.5.0版本, 这会儿启动速度也还可以, 也没太多花里胡哨的功能. 然而没过多久就迎来了一波强制版本更新, 更新后的版本启动速度慢到令人发指, 且增加了商城, 我就怒了, 区区门禁软件竟然这样肆意妄为, 开工!\n目标 破解某加(版本: 6.5.0)去除更新检查, 去掉实名认证\n 某加在7.0.0版本更名为某品, 破解版本为6.5.0, 在此保持称呼其为某加\n 某加APP(版本6.5.0)界面\n 首页 \n开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某加安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某加的源码\n 7.0版本开始APP加了壳, 没记错的话是某数字安全软件的壳, 脱壳过于麻烦于是使用6.5.0版本破解\n  JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n禁用强制升级 首先根据弹窗文字\u0026quot;发现新版本\u0026quot;搜索代码\n 更新弹窗 \n发现全文匹配的仅有一处, 位于布局文件dialog_check_update.xml\n 结果1 \n查找使用该布局文件的地方, 仅有一个类UpdateNoticeDialog\n 结果2 \n查看UpdateNoticeDialog的代码, 可以看出这是一个自定义的对话框, 和APP显示的更新弹出框一致\n 结果3 \n接着查找使用到了UpdateNoticeDialog类的地方, 发现多处引用\n 结果4 \n而APP弹出更新提示的时候, 我正位于APP的首页, 可以推断出HomeActivity应该就是我要寻找的弹框处, 查看HomeActivity的代码如下\n 首页 \n可以看到这里将UpdateNoticeDialog定义为成员变量, 然后在checkUpdate中对UpdateNoticeDialog赋值, 且其他操作都位于checkUpdate中, 现在看看checkUpdate完整代码如下\n 检查更新 \n这个方法并没有做除了更新检查以外的事, 那么我只需要在Xposed中替换这个方法就可以了, 这样当APP调用checkUpdate时, 将执行我定义的方法, Xposed模块代码如下\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克.home.HomeActivity\u0026quot;, loadPackageParam.classLoader, \u0026quot;checkUpdate\u0026quot;, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable { return null; } }); 这里直接使用replaceHookedMethod, 用自己定义的方法代替checkUpdate执行, 写好后重新运行可以发现首页更新弹窗已经被屏蔽了.\n然而后来手贱不小心退出登录了, 再启动APP时发现登录的时候也有更新认证, 现在可行的方法有二, 一是找到登录界面, 用同样的方法去除更新, 但是这样一来繁琐, 二来他可能还有其他的地方有更新检查, 所以使用第二种方法\n根据Android开发文档可以得知, 可以在APP的AndroidManifest.xml中可以定义当前APP的版本号, 然后可以在Java代码中使用PackageInfo来获得当前APP的版本信息, 而定义版本主要分为版本号versionCode和版本名versionName, 一般使用versionCode大小来判断是否需要更新, 而versionName则主要用作展示, 查看某加APP的AndroidManifest.xml文件, 发现其版本定义如下\n 版本 \n那么一般的做法只要将versionCode的值修改成足够大, 就能达到免更新的目的, 但是实际操作下来发现这APP比较鸡贼, 判断版本是否更新并不是简单通过versionCode大小来判断, 不过当时为了偷懒也没有进一步分析版本检查代码, 我只知道最新版本的versionName是7.0.0, 所以直接使用Xposed将返回的versionName修改为固定的7.0.0\nfindAndHookMethod(\u0026quot;android.app.ApplicationPackageManager\u0026quot;, loadPackageParam.classLoader, \u0026quot;getPackageInfo\u0026quot;, String.class, int.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { PackageInfo packageInfo = (PackageInfo) param.getResult(); if (null != packageInfo \u0026amp;\u0026amp; getTargetPackage().equals(packageInfo.packageName)) { packageInfo.versionCode = Integer.MAX_VALUE; packageInfo.versionName = \u0026quot;7.0.0\u0026quot;; } } }); 此处使用Xposed直接Hook Android系统的包管理器, 当某加需要获取版本名时, 直接返回7.0.0, 不过这样做的缺点是如果某加未来版本更新到7.0.0以上时, 需要修改代码, 然而从2020年12月破解至今, 某加都没有再发布过版本更新, 省了我不少事\n至此重新打包运行, 发现登录的更新检查也被去除了\n然而新的风暴又出现了, 由于刚才的不慎退出, 现在需要重新上传实名认证资料了, 包括身份证号和照片, 由于我之前已经填过一次, 而且上传后需要重新审核, 所以不愿意再次填写, 于是开始寻找认证部分的代码\n跳过实名认证 认证弹窗如下\n 实名认证弹窗 \n当我点击右下角的显示门禁卡二维码按钮的时候, 就会弹出认证弹窗, 我们知道Activity会通过setContentView加载一个布局文件, 此页面为APP首页, 所以在HomeActivity中搜索setContentView, 发现并没有结果\n 首页2 \n但是HomeActivity继承自BaseActivity_2019_8_22, 于是在父类中找到了setContentView\n 设置布局 \n可以看到这里加载的布局是activity_only_linear_layout.xml, 查看这个布局文件, 里面的代码非常简单\n 布局 \n根据名称可以很容易的推断出id为fab_show_qr_code的按钮组件就是首页显示二维码的组件, 搜索这个id查看他的点击事件\n 点击事件 \n根据判断逻辑, 如果CacheUtils.getStatus()返回为1, 就展示二维码弹窗, 不为1则执行checkStatus(), 以防万一, 看看checkStatus()的代码如下\n 检查状态 \n显然checkIdentityStatus()这名字就很直白的告诉我这个就是用来检查身份认证的了, 在回来看看CacheUtils.getStatus()代码如下\n 获取状态 \n这里的逻辑也很简单, 就是从登录信息中获取认证状态, 那么我只要用Xposed将getStatus()的返回值修改为1就可以了, Xposed代码如下\nfindAndHookMethod(\u0026quot;com.excegroup.community.utils.CacheUtils\u0026quot;, loadPackageParam.classLoader, \u0026quot;getStatus\u0026quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { param.setResult(\u0026quot;1\u0026quot;); } }); Hook代码将在getStatus()执行之后执行, 将其返回值为修改为1, 现在重新运行, 程序一切正常, 也没有身份认证弹窗了, 点击显示二维码按钮正常显示门禁二维码\n ok \n","date":"2021-06-10T00:50:44+08:00","image":"/posts/hack/xplus/cover_hu3190e2a44b906316a77f497bcfe6cb92_2387451_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xplus/","title":"某加APP破解去除认证和更新"},{"content":"背景 作为一个家徒四壁的打工人, 在某鱼上购买二手的闲置商品便成了我实现梦想的捷径, 但某鱼经过多次升级改版已经相当流氓, 在我搜索出想要的商品的结果页, 嵌入识别度很低的广告, 导致我经常手滑点错, 然后直接跳转启动某宝, 某宝的启动速度又慢的令人发指, 最终还得按下多次返回才能再次回到某鱼的搜索结果页, 忍无可忍的我只能对它做一些不可描述的事了\n目标 破解某鱼(版本: 6.7.40)并去除搜索结果页的广告, 同时去掉每次启动就弹窗的恼人的更新提示\n某鱼的搜索结果页  某鱼广告 \n PS:一个屏幕总共就6个展位, 某鱼你这三个广告位良心不会痛吗\n 开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某鱼安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某鱼的源码\n JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n首先从输入搜索目标后, 点击搜索的按钮开始入手\n 搜索面板 \n在代码中查找\u0026quot;搜索\u0026quot;关键字, 发现有多处匹配, 结合搜索面板底下的历史搜索布局, 推测该面板的布局文件应该是search_mid.xml\n 面板代码 \n搜索布局文件引用的地方, 发现其在SearchMidActivity中被使用\n 布局使用 \n再查看布局文件代码, 搜索按钮的组件ID为search_button, 在SearchMidActivity中查找相关引用\n 搜索点击1 \n 搜索点击2 \n可以看出按钮点击后, 首先会调用searchKeyAction, 再经过层层调用最后到达searchNormal, 之后就会通过 gotoResultActivity 跳转到结果页, 继续跟踪gotoResultActivity方法\n 搜索点击3 \n此处出现searchresult字符, 搜索这个字符\n 搜索点击4 \n可以看出这个字符串对应的页面应该是 SearchResultActivity, 打开这个类之后一眼看不出什么重要的东西, 然后线索就这么中断了\n线索中断之后, 可以用Xposed对某些可疑方法Hook, 然后通过打印调用堆栈的方法, 继续分析, 比如此我找到的SearchResultInterrupter中的checkInterrupt方法\n Xposed是一款Android底层的框架, 能够从虚拟机层拦截系统所有执行代码, 而Xposed模块是使用Xposed提供的SDK所开发的Android应用, 能够借助Xposed实现对所有关心代码的拦截, 详情请戳Xposed官网\n Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); if (stackElements != null) { MyLog.log(\u0026quot;调用堆栈:--------------------\u0026quot;, true); for (int i = 0; i \u0026lt; stackElements.length; i++) { MyLog.log(stackElements[i].getClassName() + \u0026quot; -\u0026gt; \u0026quot; + stackElements[i].getMethodName() + \u0026quot;()\u0026quot; , true); } } 不过这样比较麻烦而且也不好找. 于是换个思路, 安装Xposed模块XAppDebug, 为某鱼强制开启Debug模式, 此时查看控制台会显示所有某鱼打印的日志信息, 现在控制台显示了包括网络请求在内的日志信息\n MTOP \n最终找到可疑类MtopResponse, 分析代码可以推测这个类应该是一个封装了网络响应的类, 其成员变量bytedata是主要数据源, bytedata将会被转换成dataJsonObject的JSON对象储存, 然后被使用, 因此找到bytedata赋值的方法setBytedata\n 响应模型 \n 破解时间于2020年8月, 文章编辑时间为2021年6月, 我也不记得当初是不是这样找到MtopResponse类的, 没有记录下来是我的失误也是我的损失, 现在能找到这个类是因为当时开发Xposed模块中的代码有这一段. 如果某天我突然想起来了或者有兴致花时间重新找的话, 会回来补充的\n 使用Xposed拦截此函数, 并打印入参\nfindAndHookMethod(\u0026quot;mtopsdk.mtop.domain.MtopResponse\u0026quot;, loadPackageParam.classLoader, \u0026quot;setBytedata\u0026quot;, byte[].class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { String content = new String((byte[]) param.args[0]); MyLog.log(content); } }); 得到入参截取如下\n\u0026quot;data\u0026quot;: { \u0026quot;item\u0026quot;: { ... \u0026quot;main\u0026quot;: { \u0026quot;clickParam\u0026quot;: { \u0026quot;arg1\u0026quot;: \u0026quot;Item\u0026quot;, \u0026quot;args\u0026quot;: { ... \u0026quot;tagname\u0026quot;: \u0026quot;全新\\/极好\\/298人想要\u0026quot;, \u0026quot;wantNum\u0026quot;: \u0026quot;298\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;tag\u0026quot;: \u0026quot;new\\/credit-6\\/wantnum-298\u0026quot;, \u0026quot;scm\u0026quot;: \u0026quot;1007.32845.224895.0\u0026quot;, \u0026quot;publishTime\u0026quot;: \u0026quot;1590461455000\u0026quot;, \u0026quot;i2i\u0026quot;: \u0026quot;相似\u0026quot;, \u0026quot;search_tab_from\u0026quot;: null, \u0026quot;item_id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;biz_type\u0026quot;: \u0026quot;item\u0026quot;, //破解重点 \u0026quot;q\u0026quot;: \u0026quot;10700k\u0026quot;, ... }, \u0026quot;page\u0026quot;: \u0026quot;Page_xySearchResult\u0026quot; }, ... } } ... } ... 此处截取了一条记录展示, 实际拦截到的参数中是一个数组, 包含本次结果页的所有商品, 其中就包括了搜索的商品, 广告商品, 推荐商品等, 通过对比发现, 搜索的商品数据在节点args \u0026gt; biz_type 的取值为 item, 而广告等商品取值为ad, Bagtag, 聚合卡片, 那么接下来要做的事就很明确了, 解析这个字符串, 如果发现是广告商品则从数据中删除这条数据, 修改对setBytedate的Hook代码如下\n... protected void beforeHookedMethod(MethodHookParam param) throws Throwable { if (null == param.args[0] || ((byte[]) param.args[0]).length == 0) { return; } String content = new String((byte[]) param.args[0]); JSONObject jsonContent = new JSONObject(content); JSONObject jsonData = jsonContent.optJSONObject(\u0026quot;data\u0026quot;); if (null == jsonData || !jsonData.has(\u0026quot;resultList\u0026quot;)) { return; } JSONArray resultList = jsonData.getJSONArray(\u0026quot;resultList\u0026quot;); List\u0026lt;String\u0026gt; filterList = Arrays.asList(\u0026quot;ad\u0026quot;, \u0026quot;Bagtag\u0026quot;, \u0026quot;聚合卡片\u0026quot;); for (int i = 0; i \u0026lt; resultList.length(); i++) { JSONObject listItem = resultList.getJSONObject(i); String bizType = listItem.getJSONObject(\u0026quot;data\u0026quot;).getJSONObject(\u0026quot;item\u0026quot;) .getJSONObject(\u0026quot;main\u0026quot;).getJSONObject(\u0026quot;clickParam\u0026quot;).getJSONObject(\u0026quot;args\u0026quot;) .getString(\u0026quot;biz_type\u0026quot;); if (filterList.contains(bizType)) { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT) { resultList.remove(i); i--; } } } param.args[0] = jsonContent.toString().getBytes(); } ... 上述代码首先将byte数组转换为json对象, 然后遍历所有商品, 将找到的广告商品移除, 再将处理过后的字符串重新转换为byte数组, 最后赋值给原始参数, 这样当某鱼实际代码setBytedata得到的参数将会是我修改后的参数. 编译验证后可以看到广告已经不会再显示了\n 哇塞 \n禁用恼人的升级弹窗 由于本人不爱更新, 且破解后如果更新版本, 可能导致破解失效, 所以必须禁用更新\n首先根据弹窗文字搜索代码\n 更新弹窗 \n发现仅有一处, 位于BaseUpgradeHandler类的onUpgradeNeed()方法\n 更新代码 \n跟踪方法调用, 在com.马赛克.马赛克fish.upgrade.traceable.Upgrade类的c方法中被调用, 而c则被b调用\n 更新1 \n 更新2 \n重点代码摘要如下:\nprivate void c(final UpgradeHandler handler) { if (handler != null) { ... handler.onUpgradeNeed(info, tracer); ... } } c中的代码的突破点在于, 如果传入的handler不为null, 才会执行更新检测并弹窗的方法, 那么我只需要让传入的handler为null就可以了. 在Xposed模块中对Upgrade类的b方法Hook, 将入参设置为null\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克fish.upgrade.traceable.Upgrade\u0026quot;,loadPackageParam.classLoader, \u0026quot;b\u0026quot;, \u0026quot;com.马赛克.马赛克fish.upgrade.traceable.UpgradeHandler\u0026quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { //这里将入参设置为null param.args[0] = null; } } ); 重新进行测试, 一切正常且启动之后不再有更新弹窗了\n","date":"2021-06-08T00:50:44+08:00","image":"/posts/hack/xfish/cover_hu6805bb858ef8d6e39da1ca045c198567_262554_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xfish/","title":"某鱼APP破解去广告"},{"content":"背景 本文接另一篇文章 某琴吧Flash播放器破解记录\n由于某琴吧改版正式使用exe播放器之后, 删除了所有的.ypa2资源, 导致我没有及时下载的乐谱都无法继续使用Flash播放器播放了, 忍不了, 只能破解exe播放器了\n目标 破解该站的exe播放器, 使其能够免费播放VIP乐谱, 且可以完全脱机使用\n开始破解 首先安装网站的乐谱播放器, 打开安装目录发现文件结构如下\n image-3 \n其中xxxchrome.exe相当于一个浏览器, 可以访问某琴吧, 点击\u0026quot;客户端播放\u0026quot;按钮即可打开播放器, 如下图\n image-2 \n而xxplayer.exe才是播放器, 播放器启动后, 可以从任务管理器看到新增的进程\n image-1 \n剩下的安装文件和库文件还有配置文件, 就不介绍了.\n首先播放一个免费的乐谱, 在任务管理器中查看一下xxplayer.exe的启动参数\n image-4 \n完整的启动参数如下\n\u0026quot;C:\\Program Files\\马赛克music\\out1\\马赛克player.exe\u0026quot; \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981\u0026quot; 可以看到启动参数主要为\n file 官网的乐谱页地址 ypid 乐谱ID uid 用户ID token 凭证  如果从xxxchrome.exe打开一个VIP乐谱, 则会显示\n image-5 \n那么如果我不用他的xxxchrome.exe, 直接从命令行启动xxplayer.exe, 传入一个VIP乐谱ID, 会发生什么呢?\n将刚才的启动参数中的ypid参数修改为一个VIP乐谱ID, 通过命令行\nxxplayer.exe \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=33418\u0026amp;uid=999999999\u0026amp;token=4c6930a47090c3f04c7e9db3bf214078\u0026quot; 启动xxplayer.exe之后如下\n image-6 \n非常的正常, 但是至少验证了 xxplayer.exe是可以脱离xxxchrome.exe独立运行的, 那么既然要鉴权, 不请求服务器肯定是不行的吧? 于是打开Charles开始抓包, 首先用命令行打开一个免费的乐谱, 捕获到网络请求如下\n image-7 \n可以看出主要请求接口为/codeindex.php, 通过参数m做不同功能的权限认证\n当m=index, 验证成功返回权限信息\n{ \u0026quot;responseCode\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u6b63\\u5e38\u0026quot;, \u0026quot;power\u0026quot;: { \u0026quot;openPower\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;printPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;printCount\u0026quot;: \u0026quot;30\u0026quot;, \u0026quot;vstPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;pdfPower\u0026quot;: \u0026quot;0\u0026quot; } } 当m=getYpdsUrl, 验证成功返回.ypdx格式的播放文件地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypds\u0026quot;, \u0026quot;ypdxUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx\u0026quot; } } } 最后再请求资源地址http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx, 得到.ypdx格式的播放文件\n现在再来通过命令行启动一个VIP乐谱,看看请求和响应会是怎样的\n image-8 \n可以看到这次只有一个m=index的请求, 且返回码不同于免费乐谱的1000, 之后播放器弹出没有权限的弹窗, 那么思路就来了\n如果我将篡改请求的响应,播放器应该就会认为我是有权限的,那不就可以播放了吗?\n首先使用Charles进行断点, 针对m=index的请求, 修改播放器请求VIP乐谱的返回值\n iamge-9 \n和我预料的一样, 修改m=index的响应后, 这次发送了m=getYpdsUrl的请求\n但是m=getYpdsUrl仍然对用户权限进行了判断, 因此返回码不是正常的1000, 且result节点没有返回.ypdx播放文件的资源地址, 看样子不是VIP用户是无法获得资源地址了\n但是 在文章 某琴吧Flash播放器破解记录 中, 使用getURL生成的乐谱信息url去请求乐谱服务器得到的返回值里, 是包含.ypa2格式的资源地址的, 只不过现在.ypa2资源已经被删了, 不过观察刚才免费的乐谱.ypdx资源地址后, 会发现这和.ypa2的资源地址高度相似! 于是我将返回的.ypa2资源地址修改后缀名为.ypdx进行请求之后, 顺利得到了.ypdx格式的播放文件!\n//ypa2请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypa2 //ypdx请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypdx 得到.ypdx文件之后, 开启一个本地HTTP服务器, 开放一个地址用于返回.ypdx文件, 然后用Charles对VIP乐谱请求中m=getYpdsUrl断点, 并修改响应中result里对应的资源地址为本地HTTP服务器地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 再次测试, 成功打开VIP乐谱, 并开始播放, 所有功能正常!\n image-10 \n确定伪造响应的方案确定可行之后, 下一步就是要让播放器请求我指定的地址了, 因为刚才是通过Charles修改响应的, 但我不可能每次都使用Charles断点, 我需要反编译xxplayer.exe, 并修改服务请求地址为我监听的地址, 然后由我监听的地址返回所需数据\n使用OllyDbg(以下简称OD)反汇编xxplayer.exe, 在菜单栏依次点击 \u0026ldquo;插件\u0026rdquo; -\u0026gt; \u0026ldquo;中文搜索引擎\u0026rdquo; -\u0026gt; \u0026ldquo;搜索UNICODE\u0026rdquo;, 以Charles捕获到的url中的关键字codeindex搜索, 发现一共有三处\n iamge-11 \n Warning: 此处我没有使用虚拟机打开, 建议各位反汇编的时候用虚拟机, 因为被反汇编的程序如果有反调试的代码, 轻则闪退重则格盘. 另外OD本身是不带\u0026quot;中文搜索引擎\u0026quot;插件的, 需要自行下载安装\n 双击搜索到的第一处字符串, 跳转到引用代码段, 通过字符串格式可以看出, 其中%s是要用参数替换的, 且通过前面的push可以看出, 它自身也是作为参数被传递的, 那么只要跟踪下方离他最近的call之前的变量, 就能确定需要修改哪一行了, 在可疑的push处按F2断点, F8单步调试后, 发现push [local.7]正是请求的域名\n image-12 \n为了修改字符串, 有两种方式\n 如果修改前后字符串长度相同, 可以直接定位到字符串地址进行修改 如果长度不同, 可以在程序空白处, 新增一段字符串, 然后将之前对字符串的地址引用改为新增的字符串地址   程序空白处是指在OD左下角的数据面板, 拉到最下面, 可以看到一堆00 00 00 00 00 00 ..., 00在汇编中就是啥都没有, 啥都不干, 也就是空白的意思\n 这里暂时不知道[local.7]哪儿来的, 所以我选择第二种方式, 查看OD左下角数据面板, 拉到最下面, 找到程序空白处, 双击空白地址, 在弹出的编辑窗口中取消勾选\u0026quot;Keep size\u0026quot;, 在UNICODE栏输入localhost:7777\n image-13 \n image-14 \n Q1: 为什么不在011808E0行的6C 65 57后面的00处添加, 而是在00的后面?\n 因为汇编中字符串是以00结尾, 且每个字符后面都跟一个00, 为了尽量避免覆盖前面的数据块, 这里空开一个00位置, 如果前面数据块明显是字符串,需要空开三个00, 因为结束符00后面也会跟一个00\n   Q2: 为什么取消勾选\u0026quot;Keep size\u0026quot;\n Keep size的作用是保持长度字符串长度一致, 因为如果超过原来的长度会造成不可预知的错误, 但是这里是程序空白处, 后面都是空白行, 所以不需要保持长度, 有多少写多少\n  此时点击新增的字符串头6C可以在底部栏看到新字符串的起始地址为0x11808E4, 回到汇编面板, 双击刚才的push [local.7]所在行, 在弹出的面板中修改为 push 0x11808E4\n 由于修改后的代码较之前的代码更少, 需要勾选\u0026quot;Fill with NOP`s\u0026quot;来保持长度一致\n  image-15 \n可以看到在汇编面板右侧已经自动显示了标记, 提示当前push的值为localhost:7777\n image-16 \n现在选中刚才在数据面板添加的字符串十六进制代码块, 右键点击\u0026quot;复制到可执行文件\u0026quot;, 再选中汇编面板所有修改的行, 右键点击\u0026quot;复制到可执行文件\u0026quot; -\u0026gt; \u0026ldquo;选中行\u0026rdquo;, 在弹出的面板中右键\u0026quot;备份\u0026quot; -\u0026gt; \u0026ldquo;保存数据到文件\u0026quot;即可保存修改后的exe文件\n image-36 \n执行修改后的程序, 发现程序异常退出, 用OD打开修改后的文件, 再次找到刚才修改push的地方, 发现右侧没有显示localhost:7777的标记\n image-17 \n再看看跳转地址0x11808E4, 也不是刚才修改的字符串内容\n image-18 \n虽然不知道为什么, 但是看来push [local.x]形式的代码不能这样简单的修改. 那么换个角度想想[local.7]的值是哪里来的, 这时突然想到播放器启动的时候, 带的参数里是有一个网址的\nfile=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 我将这个网址修改为百度的网址\nfile=http://www.baidu.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 重新运行, 抓包发现它真的去请求百度的/codeindex.php接口了\n image-19 \n于是我再将参数换成localhost:7777, 重新运行, 结果发现程序异常退出, 进行跟踪调试发现[local.7]的实际值被截取了不包含端口号的部分, 为localhost\n image-20 \n尝试跟踪截取部分的代码, 但是太麻烦了决定放弃. 这时候我想到直接将整个url\n%s://%s/codeindex.php?d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s 中第二个%s直接替换成localhost:7777不就可以了? 但是这样就少了一个%s, 参数对不上后面的代码一定会报错, 于是我想到在?后面再加一个参数, 参数名随意, 参数值就用[local.7], 反正对于串来说, %s的数量能够对应参数的数量即可, 而对于HTTP请求来说, 多一个参数也没什么影响. 不过修改后字符串的长度就对不上了, 所以还是在程序空白处添加了一个新的字符串如下\n%s://localhost:7777/codeindex.php?a=%s\u0026amp;d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s  image-21 \n其中a就是新增的无用参数, a后面跟的%s将会被[local.7]的值替换, 这样一来无论启动参数中的域名是什么都无所谓了. 记录新字符串的地址为0x11808E4, 找到push原来字符串的汇编代码, 修改push地址为新的字符串地址\n image-22 \n再次保存执行, 程序还是异常退出, 用OD打开修改后的程序发现地址正确, 字符串正确, 但是还是会报错, 于是我怀疑不能用localhost作为域名. 将localhost:7777修改为127.0.0.1:7777, 再次运行, 这次终于在后台收到了来自播放器的HTTP请求!\n image-23 \n所有参数也都正常接收, 接下来只要返回正确的响应就行了, 对于m=index的直接返回\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;0\u0026quot;}} 对于m=getYpdsUrl 的则返回\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 然后, 用同样的方式修改搜索codeindex结果中的第二处, 再次运行就能正常播放了.\n继续破解 现在虽然播放曲谱没有问题了, 但是现在还有如下几个VIP功能用不了, 要白嫖就白嫖到极致\n image-24 \n从音源开始下手, 点击\u0026quot;音源\u0026rdquo; -\u0026gt; \u0026ldquo;浏览\u0026quot;后, 播放器弹出没有权限的提示\n image-25 \n查看Charles发现期间并没有发出网络请求, 推测应该是在之前的请求里就响应过了, 这时想到最开始m=index的请求中, power节点有很多为0的字段, 仔细一看这不就是对应的权限吗? 推测权限字段对应关系应该是\n openPower 打开的权限 printPower 打印的权限 printCount 可打印的数量 vstPower 使用vst音源的权限 pdfPower 转换pdf的权限  参考正常响应中openPower为1, 其他的为0, 因此把后台响应中所有为0改为1, 再次点击音源, 发现可以正常选择了\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;1\u0026quot;}}  image-26 \n接下来看看点击转换PDF功能, 通过Charles发现会发送一个权限请求\n image-27 \n其中接口仍然是/codeindex.php, 但本次m取值为addDynamic, 在OD中发现就是刚才上文codeindex搜索结果中的第三处\n image-28 \n双击搜索结果字符串转到汇编代码,00F63EAE 处的push地址就是将要用来替换成请求域名的参数, 这个地址指向了某琴吧的域名, 所以这里采用同样的办法, 先在程序空白处添加字符串127.0.0.1:7777, 然后修改push原来串的地址修改为新增的字符串地址\n image-29 \n重新保存, 然后在乐谱工具中监听这个地址, 并参考m=index的响应以下结果\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n {\u0026quot;data\u0026quot;:{\u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;}}} 重新打开运行PDF保存, 发现可以转换并保存了\n image-30 \n打印的功能和PDF的请求地址和参数m是一样的, 只要返回同样的响应就可以了\n至此VIP功能全部破解\n但是尚不完美 最后做脱机测试的时候发现播放器会先检查网络连接状态, 没有网络连接则无法播放\n image-31 \n但是我的目标是播放器能够脱机使用, 而且实际上播放器被我修改后已经不需要再连上互联网, 只需要请求乐谱工具的HTTP服务地址就可以, 因此根据弹窗搜索字符串, 定位到相关代码\n image-32 \n可以看到播放器在00F693E2处调用系统接口得到网络连接状态, 在00F693EC处, 如果有网络连接则会跳转到00F6940A处继续, 没有网络连接则会显示并中断运行, 那我只需要让这个判断失效就可以了, 双击00F693EC打开编辑窗口, 将jnz (不等于0则跳转) 修改为jmp (无条件跳转), 这样运行至此的时候将不会判断网络连接状态, 直接运行后面的代码\n image-34 \n image-35 \n同样的, 在使用转换PDF功能时还会检测网络状态, 然后弹窗提示\u0026quot;没有检测到网络!\u0026rdquo;, 找到代码运行处, 修改00F75DDE处的jnz为jmp即可\n image-33 \n保存后重新运行, 现在脱机情况下播放器能够正常打开并请求乐谱工具的HTTP服务并正常播放乐谱了, 转存PDF文件等VIP功能也能够正常使用\n至此exe版本宣告完美破解 ","date":"2021-05-26T00:50:44+08:00","image":"/posts/hack/xtan/exe/cover_hu9fa22720e1e2994b8f7276f9d33830a9_2622630_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/exe/","title":"某琴吧EXE播放器破解记录"},{"content":"背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.\n同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.\n目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用\n网站乐谱页  image-1 \n开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下\n 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图\n 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?\n首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3.6a 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 flash_player_debugger, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:\n image-2 \n其中Main为主类, init1 为初始化函数, 这里可以得到入参, 参数传入形式为\nplayer.swf?id=1 而配置类Config定义了服务端接口地址:\n image-3 \n但是很遗憾在player.swf中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时Sounds.swf就很可疑了, 通过阅读player.swf的代码发现Sounds.swf是点击播放按钮之后, 作为一个函数库被加载进来的, 这里load的地址就是Config里定义了Sounds.swf资源地址\n image-4 \n请求响应之后通过回调函数onSwComplete将其载入并储存到Clib类的成员变量clib中\n image-5 \n然后就可以通过utils.Clib.clib.xxx的方式调用函数, 再深入跟踪代码, 发现Clib中的getURL非常可疑\n image-6 \n找到他被调用的地方, 加一行日志跟踪一下输出\n image-7 \n调试运行之后输出的字符串为:\n image-14 \n这个地址跟第四步的请求地址就是同一个地址! 这就是我要找的东西, 现在只需要反编译Sounds.swf, 把getURL的算法抄下来就可以了! 想法很美好, 但现实很骨感, Sounds.swf反编译后发现经过了加密混淆, 反编译出来的代码是这样的\n image-8 \n这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹\n image-9 \n这url不就是刚才输出的地址吗, 显然此处的代码是将url中的%s, %d替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个Sounds.swf是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用getURL这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询ActionScript资料, 发现可以通过ExternalInterface, 让.swf将接口暴露出来提供外部Flash容器调用, 对于player.swf来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用WinForm的Shockwave Flash组件.\n于是修改player.swf的源码, 在Main中定义一段可供外部调用的函数\n image-10 \n其中函数名为swfExtGetypURL, 入参为string类型的乐谱ID, 函数首先检查clib是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用Clib的getURL返回乐谱信息url.\n上文提到clib是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化clib的函数onSwComplete, 仿照其代码, 在Clib中写一段初始化代码如下:\npublic static function myLoadSwf() : void { swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady); swfLoader.load(new URLRequest(Config.flash_sound_lib_URL)); } internal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); } 并将原来的初始化代码loadSwf修改为:\n//修改前 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); swfLoadCompleteCallBack(); return; } //修改后 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; if(null == CLib.clib) { swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); } else { swfLoadCompleteCallBack(); } return; } 最后在Mian类的初始化函数init1中调用myLoadSwf\n image-12 \n大功告成, 现在 player.swf 在启动的时候就会调用我添加的 myLoadSwf 函数, 开始加载 Sounds.swf 并初始化到 Clib 中. 而原来的loadSwf会先判断Sounds.swf有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过Shockwave Flash组件调用player.swf暴露出来的外部接口就可以了, 调用方式如下:\naxShockwaveFlash.CallFunction( string.Format(\u0026quot;\u0026lt;invoke name=\\\u0026quot;swfExtGetypURL\\\u0026quot; returntype=\\\u0026quot;xml\\\u0026quot;\u0026gt;\u0026lt;arguments\u0026gt;\u0026lt;string\u0026gt;{0}\u0026lt;/string\u0026gt;\u0026lt;/arguments\u0026gt;\u0026lt;/invoke\u0026gt;\u0026quot;, ypid));  axShockwaveFlash 是我在c#代码中定义的Flash容器组件成员变量, 它加载了player.swf作为内容, 代码中调用到的扩展函数名称为swfExtGetypURL, 也就是刚才在player.swf的Main中定义的ExternalInterface类型的函数, 参数为string类型的乐谱ID\n 得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;yp_create_time=\u0026lt;yp_create_time\u0026gt;1601587012\u0026lt;/yp_create_time\u0026gt; \u0026lt;br/\u0026gt; yp_title=\u0026lt;yp_title\u0026gt;Summer（菊次郎的夏天）\u0026lt;/yp_title\u0026gt; \u0026lt;br/\u0026gt; yp_page_count=\u0026lt;yp_page_count\u0026gt;5\u0026lt;/yp_page_count\u0026gt; \u0026lt;br/\u0026gt; yp_page_width=\u0026lt;yp_page_width\u0026gt;1051\u0026lt;/yp_page_width\u0026gt; \u0026lt;br/\u0026gt; yp_page_height=\u0026lt;yp_page_height\u0026gt;1487\u0026lt;/yp_page_height\u0026gt; \u0026lt;br/\u0026gt; yp_is_dadiao=\u0026lt;yp_is_dadiao\u0026gt;1\u0026lt;/yp_is_dadiao\u0026gt; \u0026lt;br/\u0026gt; yp_key_note=\u0026lt;yp_key_note\u0026gt;2\u0026lt;/yp_key_note\u0026gt; \u0026lt;br/\u0026gt; yp_is_yanyin=\u0026lt;yp_is_yanyin\u0026gt;0\u0026lt;/yp_is_yanyin\u0026gt; \u0026lt;br/\u0026gt; ypad_url=\u0026lt;ypad_url\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad\u0026lt;/ypad_url\u0026gt;ypad_url2=\u0026lt;ypad_url2\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2\u0026lt;/ypad_url2\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; 接下来, 只需要解析响应并下载资源就可以了\n 解析 yp_page_count 节点可以得到乐谱的总页数 解析ypad_url节点, 并在节点中url的最后拼接.乐谱页数.png, 即可得到真实的乐谱图片地址 解析ypad_url节点, 截取 _ 的前半部分, 再拼接 _prev.jpg还可以得到乐谱的封面图 解析ypad_url2节点即可获取真实的.ypa2格式的播放文件   由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式\n 以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对player.swf和Sounds.swf做一些修改, 首先修改player.swf的Config类, 把其中关键的加载Sounds.swf和获取封面的地址修改为localhost:7777\n//获取曲谱封面的地址 public static const flash_prev_yp_info_URL:String = \u0026quot;http://localhost:7777/yuepu/preview\u0026quot;; //获取Sounds.swf的地址 public static const flash_sound_lib_URL:String = \u0026quot;http://localhost:7777/yuepu/flash/sound\u0026quot;; 然后修改Sounds.swf在上文查找到的生成url串, 把串的前缀修改为localhost:7777\ngstaticInitter.asciz = \u0026quot;http://localhost:7777/yuepu/info?ypid=%d\u0026amp;sccode=%s\u0026amp;r1=%d\u0026amp;r2=%d\u0026amp;input=%s\u0026quot;;  此处Sounds.swf修改url后, 调用getURL返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求\n 最后在乐谱工具中开启一个端口为7777的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n  image-13 \n Adobe Flash彻底停用后的补偿方案 过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具WinForm的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, 直接导致Shockwave Flash也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.\n既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的flash_player_debugger, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的.swf文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令\nflashplayer_sa_debug.exe player.swf?id=1 即可启动 flash_player_debugger 并打开作为参数的 .swf 文件, 在C#中则可以使用Process启动, 代码如下:\nProcess.Start(\u0026quot;flashplayer_sa_debug.exe\u0026quot;, \u0026quot;Main.swf?id=1\u0026quot;); 但是在实际使用中, 发现通过命令行或者程序启动的 flash_player_debugger 打开的player.swf无法发送localhost的网络请求, 弹窗报错如下:\nSecurityError: Error #2119: 安全沙箱冲突 但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求localhost是因为他在用户文件夹下\\AppData\\Roaming\\Macromediax\\Flash Player\\#Security\\FlashPlayerTrust创建了信任文件intellij_idea.cfg, 文件内容即IDEA生成.swf的完整文件夹路径\nE:\\flash\\bin-debug 所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求localhost了\n现在解决了乐谱无法播放的问题, 但是由于flash_player_debugger不支持ExternalInterface, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用getURL获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.\n首先删除会引起报错的player.swf中使用ExternalInterface定义的接口swfExtGetypURL, 修改 myLoadSwf中定义的回调函数 onSoundsReady, 在此前初始化clib的基础上加上调用getURL返回的url, 并提取参数请求localhost:7777, 修改后的代码如下:\ninternal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); //添加的部分 if(utils.Func.ypadId != 0) { var url:* = CLib.getURL(utils.Func.ypadId); var args:* = \u0026quot;?\u0026quot; + url.split(\u0026quot;?\u0026quot;)[1] urlLoader3 = new flash.net.URLLoader(); urlLoader3.load(new flash.net.URLRequest(\u0026quot;http://localhost:7777/yuepu/fetch\u0026quot; + args)); } }  utils.Func.ypadId中存储了播放器启动时传入的乐谱ID参数\n 此时当clib初始化完成之后, 会使用传入的乐谱ID直接调用getURL, 截取返回url的参数部分, 再将参数通过HTTP请求上报到localhost:7777. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题\n//监听曲谱地址 if (httpListenerContext.Request.Url.LocalPath.Equals(\u0026quot;/yuepu/fetch\u0026quot;)) { httpListenerContext.Request.QueryString[\u0026quot;ypid\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;sccode\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r1\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r2\u0026quot;]; ... } 不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用Process启动的指定WindowStyle为ProcessWindowStyle.Hidden就可以无感使用了\nProcess.Start(new ProcessStartInfo() { FileName = \u0026quot;flashplayer_sa_debug.exe\u0026quot;, WindowStyle = ProcessWindowStyle.Hidden,//关键代码 Arguments = \u0026quot;Main.swf?id=64\u0026quot;, }) 至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的.ypa2格式播放器文件, 且删除了所有.ypa2资源, 并采用新的.ypdx文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了\u0026hellip; ","date":"2021-05-25T00:50:44+08:00","image":"/posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/flash/","title":"某琴吧Flash播放器破解记录"}]