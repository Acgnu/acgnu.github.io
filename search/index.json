[{"content":"背景 由于某些需要, 进入某大楼的时候必须用他们物业指定的APP刷门禁, 我安装的时候是6.5.0版本, 这会儿启动速度也还可以, 也没太多花里胡哨的功能. 然而没过多久就迎来了一波强制版本更新, 更新后的版本启动速度慢到令人发指, 且增加了商城, 我就怒了, 区区门禁软件竟然这样肆意妄为, 开工!\n目标 破解某加(版本: 6.5.0)去除更新检查, 去掉实名认证\n 某加在7.0.0版本更名为某品, 破解版本为6.5.0, 在此保持称呼其为某加\n 某加APP(版本6.5.0)界面\n 首页 \n开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某加安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某加的源码\n 7.0版本开始APP加了壳, 没记错的话是某数字安全软件的壳, 脱壳过于麻烦于是使用6.5.0版本破解\n  JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n禁用强制升级 首先根据弹窗文字\u0026quot;发现新版本\u0026quot;搜索代码\n 更新弹窗 \n发现全文匹配的仅有一处, 位于布局文件dialog_check_update.xml\n 结果1 \n查找使用该布局文件的地方, 仅有一个类UpdateNoticeDialog\n 结果2 \n查看UpdateNoticeDialog的代码, 可以看出这是一个自定义的对话框, 和APP显示的更新弹出框一致\n 结果3 \n接着查找使用到了UpdateNoticeDialog类的地方, 发现多处引用\n 结果4 \n而APP弹出更新提示的时候, 我正位于APP的首页, 可以推断出HomeActivity应该就是我要寻找的弹框处, 查看HomeActivity的代码如下\n 首页 \n可以看到这里将UpdateNoticeDialog定义为成员变量, 然后在checkUpdate中对UpdateNoticeDialog赋值, 且其他操作都位于checkUpdate中, 现在看看checkUpdate完整代码如下\n 检查更新 \n这个方法并没有做除了更新检查以外的事, 那么我只需要在Xposed中替换这个方法就可以了, 这样当APP调用checkUpdate时, 将执行我定义的方法, Xposed模块代码如下\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克.home.HomeActivity\u0026quot;, loadPackageParam.classLoader, \u0026quot;checkUpdate\u0026quot;, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable { return null; } }); 这里直接使用replaceHookedMethod, 用自己定义的方法代替checkUpdate执行, 写好后重新运行可以发现首页更新弹窗已经被屏蔽了.\n然而后来手贱不小心退出登录了, 再启动APP时发现登录的时候也有更新认证, 现在可行的方法有二, 一是找到登录界面, 用同样的方法去除更新, 但是这样一来繁琐, 二来他可能还有其他的地方有更新检查, 所以使用第二种方法\n根据Android开发文档可以得知, 可以在APP的AndroidManifest.xml中可以定义当前APP的版本号, 然后可以在Java代码中使用PackageInfo来获得当前APP的版本信息, 而定义版本主要分为版本号versionCode和版本名versionName, 一般使用versionCode大小来判断是否需要更新, 而versionName则主要用作展示, 查看某加APP的AndroidManifest.xml文件, 发现其版本定义如下\n 版本 \n那么一般的做法只要将versionCode的值修改成足够大, 就能达到免更新的目的, 但是实际操作下来发现这APP比较鸡贼, 判断版本是否更新并不是简单通过versionCode大小来判断, 不过当时为了偷懒也没有进一步分析版本检查代码, 我只知道最新版本的versionName是7.0.0, 所以直接使用Xposed将返回的versionName修改为固定的7.0.0\nfindAndHookMethod(\u0026quot;android.app.ApplicationPackageManager\u0026quot;, loadPackageParam.classLoader, \u0026quot;getPackageInfo\u0026quot;, String.class, int.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { PackageInfo packageInfo = (PackageInfo) param.getResult(); if (null != packageInfo \u0026amp;\u0026amp; getTargetPackage().equals(packageInfo.packageName)) { packageInfo.versionCode = Integer.MAX_VALUE; packageInfo.versionName = \u0026quot;7.0.0\u0026quot;; } } }); 此处使用Xposed直接Hook Android系统的包管理器, 当某加需要获取版本名时, 直接返回7.0.0, 不过这样做的缺点是如果某加未来版本更新到7.0.0以上时, 需要修改代码, 然而从2020年12月破解至今, 某加都没有再发布过版本更新, 省了我不少事\n至此重新打包运行, 发现登录的更新检查也被去除了\n然而新的风暴又出现了, 由于刚才的不慎退出, 现在需要重新上传实名认证资料了, 包括身份证号和照片, 由于我之前已经填过一次, 而且上传后需要重新审核, 所以不愿意再次填写, 于是开始寻找认证部分的代码\n跳过实名认证 认证弹窗如下\n 实名认证弹窗 \n当我点击右下角的显示门禁卡二维码按钮的时候, 就会弹出认证弹窗, 我们知道Activity会通过setContentView加载一个布局文件, 此页面为APP首页, 所以在HomeActivity中搜索setContentView, 发现并没有结果\n 首页2 \n但是HomeActivity继承自BaseActivity_2019_8_22, 于是在父类中找到了setContentView\n 设置布局 \n可以看到这里加载的布局是activity_only_linear_layout.xml, 查看这个布局文件, 里面的代码非常简单\n 布局 \n根据名称可以很容易的推断出id为fab_show_qr_code的按钮组件就是首页显示二维码的组件, 搜索这个id查看他的点击事件\n 点击事件 \n根据判断逻辑, 如果CacheUtils.getStatus()返回为1, 就展示二维码弹窗, 不为1则执行checkStatus(), 以防万一, 看看checkStatus()的代码如下\n 检查状态 \n显然checkIdentityStatus()这名字就很直白的告诉我这个就是用来检查身份认证的了, 在回来看看CacheUtils.getStatus()代码如下\n 获取状态 \n这里的逻辑也很简单, 就是从登录信息中获取认证状态, 那么我只要用Xposed将getStatus()的返回值修改为1就可以了, Xposed代码如下\nfindAndHookMethod(\u0026quot;com.excegroup.community.utils.CacheUtils\u0026quot;, loadPackageParam.classLoader, \u0026quot;getStatus\u0026quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { param.setResult(\u0026quot;1\u0026quot;); } }); Hook代码将在getStatus()执行之后执行, 将其返回值为修改为1, 现在重新运行, 程序一切正常, 也没有身份认证弹窗了, 点击显示二维码按钮正常显示门禁二维码\n ok \n","date":"2021-06-10T00:50:44+08:00","image":"/posts/hack/xplus/cover_hu3190e2a44b906316a77f497bcfe6cb92_2387451_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xplus/","title":"某加APP破解去除认证和更新"},{"content":"背景 作为一个家徒四壁的打工人, 在某鱼上购买二手的闲置商品便成了我实现梦想的捷径, 但某鱼经过多次升级改版已经相当流氓, 在我搜索出想要的商品的结果页, 嵌入识别度很低的广告, 导致我经常手滑点错, 然后直接跳转启动某宝, 某宝的启动速度又慢的令人发指, 最终还得按下多次返回才能再次回到某鱼的搜索结果页, 忍无可忍的我只能对它做一些不可描述的事了\n目标 破解某鱼(版本: 6.7.40)并去除搜索结果页的广告, 同时去掉每次启动就弹窗的恼人的更新提示\n某鱼的搜索结果页  某鱼广告 \n PS:一个屏幕总共就6个展位, 某鱼你这三个广告位良心不会痛吗\n 开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某鱼安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某鱼的源码\n JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n首先从输入搜索目标后, 点击搜索的按钮开始入手\n 搜索面板 \n在代码中查找\u0026quot;搜索\u0026quot;关键字, 发现有多处匹配, 结合搜索面板底下的历史搜索布局, 推测该面板的布局文件应该是search_mid.xml\n 面板代码 \n搜索布局文件引用的地方, 发现其在SearchMidActivity中被使用\n 布局使用 \n再查看布局文件代码, 搜索按钮的组件ID为search_button, 在SearchMidActivity中查找相关引用\n 搜索点击1 \n 搜索点击2 \n可以看出按钮点击后, 首先会调用searchKeyAction, 再经过层层调用最后到达searchNormal, 之后就会通过 gotoResultActivity 跳转到结果页, 继续跟踪gotoResultActivity方法\n 搜索点击3 \n此处出现searchresult字符, 搜索这个字符\n 搜索点击4 \n可以看出这个字符串对应的页面应该是 SearchResultActivity, 打开这个类之后一眼看不出什么重要的东西, 然后线索就这么中断了\n线索中断之后, 可以用Xposed对某些可疑方法Hook, 然后通过打印调用堆栈的方法, 继续分析, 比如此我找到的SearchResultInterrupter中的checkInterrupt方法\n Xposed是一款Android底层的框架, 能够从虚拟机层拦截系统所有执行代码, 而Xposed模块是使用Xposed提供的SDK所开发的Android应用, 能够借助Xposed实现对所有关心代码的拦截, 详情请戳Xposed官网\n Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); if (stackElements != null) { MyLog.log(\u0026quot;调用堆栈:--------------------\u0026quot;, true); for (int i = 0; i \u0026lt; stackElements.length; i++) { MyLog.log(stackElements[i].getClassName() + \u0026quot; -\u0026gt; \u0026quot; + stackElements[i].getMethodName() + \u0026quot;()\u0026quot; , true); } } 不过这样比较麻烦而且也不好找. 于是换个思路, 安装Xposed模块XAppDebug, 为某鱼强制开启Debug模式, 此时查看控制台会显示所有某鱼打印的日志信息, 现在控制台显示了包括网络请求在内的日志信息\n MTOP \n最终找到可疑类MtopResponse, 分析代码可以推测这个类应该是一个封装了网络响应的类, 其成员变量bytedata是主要数据源, bytedata将会被转换成dataJsonObject的JSON对象储存, 然后被使用, 因此找到bytedata赋值的方法setBytedata\n 响应模型 \n 破解时间于2020年8月, 文章编辑时间为2021年6月, 我也不记得当初是不是这样找到MtopResponse类的, 没有记录下来是我的失误也是我的损失, 现在能找到这个类是因为当时开发Xposed模块中的代码有这一段. 如果某天我突然想起来了或者有兴致花时间重新找的话, 会回来补充的\n 使用Xposed拦截此函数, 并打印入参\nfindAndHookMethod(\u0026quot;mtopsdk.mtop.domain.MtopResponse\u0026quot;, loadPackageParam.classLoader, \u0026quot;setBytedata\u0026quot;, byte[].class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { String content = new String((byte[]) param.args[0]); MyLog.log(content); } }); 得到入参截取如下\n\u0026quot;data\u0026quot;: { \u0026quot;item\u0026quot;: { ... \u0026quot;main\u0026quot;: { \u0026quot;clickParam\u0026quot;: { \u0026quot;arg1\u0026quot;: \u0026quot;Item\u0026quot;, \u0026quot;args\u0026quot;: { ... \u0026quot;tagname\u0026quot;: \u0026quot;全新\\/极好\\/298人想要\u0026quot;, \u0026quot;wantNum\u0026quot;: \u0026quot;298\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;tag\u0026quot;: \u0026quot;new\\/credit-6\\/wantnum-298\u0026quot;, \u0026quot;scm\u0026quot;: \u0026quot;1007.32845.224895.0\u0026quot;, \u0026quot;publishTime\u0026quot;: \u0026quot;1590461455000\u0026quot;, \u0026quot;i2i\u0026quot;: \u0026quot;相似\u0026quot;, \u0026quot;search_tab_from\u0026quot;: null, \u0026quot;item_id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;biz_type\u0026quot;: \u0026quot;item\u0026quot;, //破解重点 \u0026quot;q\u0026quot;: \u0026quot;10700k\u0026quot;, ... }, \u0026quot;page\u0026quot;: \u0026quot;Page_xySearchResult\u0026quot; }, ... } } ... } ... 此处截取了一条记录展示, 实际拦截到的参数中是一个数组, 包含本次结果页的所有商品, 其中就包括了搜索的商品, 广告商品, 推荐商品等, 通过对比发现, 搜索的商品数据在节点args \u0026gt; biz_type 的取值为 item, 而广告等商品取值为ad, Bagtag, 聚合卡片, 那么接下来要做的事就很明确了, 解析这个字符串, 如果发现是广告商品则从数据中删除这条数据, 修改对setBytedate的Hook代码如下\n... protected void beforeHookedMethod(MethodHookParam param) throws Throwable { if (null == param.args[0] || ((byte[]) param.args[0]).length == 0) { return; } String content = new String((byte[]) param.args[0]); JSONObject jsonContent = new JSONObject(content); JSONObject jsonData = jsonContent.optJSONObject(\u0026quot;data\u0026quot;); if (null == jsonData || !jsonData.has(\u0026quot;resultList\u0026quot;)) { return; } JSONArray resultList = jsonData.getJSONArray(\u0026quot;resultList\u0026quot;); List\u0026lt;String\u0026gt; filterList = Arrays.asList(\u0026quot;ad\u0026quot;, \u0026quot;Bagtag\u0026quot;, \u0026quot;聚合卡片\u0026quot;); for (int i = 0; i \u0026lt; resultList.length(); i++) { JSONObject listItem = resultList.getJSONObject(i); String bizType = listItem.getJSONObject(\u0026quot;data\u0026quot;).getJSONObject(\u0026quot;item\u0026quot;) .getJSONObject(\u0026quot;main\u0026quot;).getJSONObject(\u0026quot;clickParam\u0026quot;).getJSONObject(\u0026quot;args\u0026quot;) .getString(\u0026quot;biz_type\u0026quot;); if (filterList.contains(bizType)) { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT) { resultList.remove(i); i--; } } } param.args[0] = jsonContent.toString().getBytes(); } ... 上述代码首先将byte数组转换为json对象, 然后遍历所有商品, 将找到的广告商品移除, 再将处理过后的字符串重新转换为byte数组, 最后赋值给原始参数, 这样当某鱼实际代码setBytedata得到的参数将会是我修改后的参数. 编译验证后可以看到广告已经不会再显示了\n 哇塞 \n禁用恼人的升级弹窗 由于本人不爱更新, 且破解后如果更新版本, 可能导致破解失效, 所以必须禁用更新\n首先根据弹窗文字搜索代码\n 更新弹窗 \n发现仅有一处, 位于BaseUpgradeHandler类的onUpgradeNeed()方法\n 更新代码 \n跟踪方法调用, 在com.马赛克.马赛克fish.upgrade.traceable.Upgrade类的c方法中被调用, 而c则被b调用\n 更新1 \n 更新2 \n重点代码摘要如下:\nprivate void c(final UpgradeHandler handler) { if (handler != null) { ... handler.onUpgradeNeed(info, tracer); ... } } c中的代码的突破点在于, 如果传入的handler不为null, 才会执行更新检测并弹窗的方法, 那么我只需要让传入的handler为null就可以了. 在Xposed模块中对Upgrade类的b方法Hook, 将入参设置为null\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克fish.upgrade.traceable.Upgrade\u0026quot;,loadPackageParam.classLoader, \u0026quot;b\u0026quot;, \u0026quot;com.马赛克.马赛克fish.upgrade.traceable.UpgradeHandler\u0026quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { //这里将入参设置为null param.args[0] = null; } } ); 重新进行测试, 一切正常且启动之后不再有更新弹窗了\n","date":"2021-06-08T00:50:44+08:00","image":"/posts/hack/xfish/cover_hu6805bb858ef8d6e39da1ca045c198567_262554_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xfish/","title":"某鱼APP破解去广告"},{"content":"背景 本文接另一篇文章 某琴吧Flash播放器破解记录\n由于某琴吧改版正式使用exe播放器之后, 删除了所有的.ypa2资源, 导致我没有及时下载的乐谱都无法继续使用Flash播放器播放了, 忍不了, 只能破解exe播放器了\n目标 破解该站的exe播放器, 使其能够免费播放VIP乐谱, 且可以完全脱机使用\n开始破解 首先安装网站的乐谱播放器, 打开安装目录发现文件结构如下\n image-3 \n其中xxxchrome.exe相当于一个浏览器, 可以访问某琴吧, 点击\u0026quot;客户端播放\u0026quot;按钮即可打开播放器, 如下图\n image-2 \n而xxplayer.exe才是播放器, 播放器启动后, 可以从任务管理器看到新增的进程\n image-1 \n剩下的安装文件和库文件还有配置文件, 就不介绍了.\n首先播放一个免费的乐谱, 在任务管理器中查看一下xxplayer.exe的启动参数\n image-4 \n完整的启动参数如下\n\u0026quot;C:\\Program Files\\马赛克music\\out1\\马赛克player.exe\u0026quot; \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981\u0026quot; 可以看到启动参数主要为\n file 官网的乐谱页地址 ypid 乐谱ID uid 用户ID token 凭证  如果从xxxchrome.exe打开一个VIP乐谱, 则会显示\n image-5 \n那么如果我不用他的xxxchrome.exe, 直接从命令行启动xxplayer.exe, 传入一个VIP乐谱ID, 会发生什么呢?\n将刚才的启动参数中的ypid参数修改为一个VIP乐谱ID, 通过命令行\nxxplayer.exe \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=33418\u0026amp;uid=999999999\u0026amp;token=4c6930a47090c3f04c7e9db3bf214078\u0026quot; 启动xxplayer.exe之后如下\n image-6 \n非常的正常, 但是至少验证了 xxplayer.exe是可以脱离xxxchrome.exe独立运行的, 那么既然要鉴权, 不请求服务器肯定是不行的吧? 于是打开Charles开始抓包, 首先用命令行打开一个免费的乐谱, 捕获到网络请求如下\n image-7 \n可以看出主要请求接口为/codeindex.php, 通过参数m做不同功能的权限认证\n当m=index, 验证成功返回权限信息\n{ \u0026quot;responseCode\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u6b63\\u5e38\u0026quot;, \u0026quot;power\u0026quot;: { \u0026quot;openPower\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;printPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;printCount\u0026quot;: \u0026quot;30\u0026quot;, \u0026quot;vstPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;pdfPower\u0026quot;: \u0026quot;0\u0026quot; } } 当m=getYpdsUrl, 验证成功返回.ypdx格式的播放文件地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypds\u0026quot;, \u0026quot;ypdxUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx\u0026quot; } } } 最后再请求资源地址http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx, 得到.ypdx格式的播放文件\n现在再来通过命令行启动一个VIP乐谱,看看请求和响应会是怎样的\n image-8 \n可以看到这次只有一个m=index的请求, 且返回码不同于免费乐谱的1000, 之后播放器弹出没有权限的弹窗, 那么思路就来了\n如果我将篡改请求的响应,播放器应该就会认为我是有权限的,那不就可以播放了吗?\n首先使用Charles进行断点, 针对m=index的请求, 修改播放器请求VIP乐谱的返回值\n iamge-9 \n和我预料的一样, 修改m=index的响应后, 这次发送了m=getYpdsUrl的请求\n但是m=getYpdsUrl仍然对用户权限进行了判断, 因此返回码不是正常的1000, 且result节点没有返回.ypdx播放文件的资源地址, 看样子不是VIP用户是无法获得资源地址了\n但是 在文章 某琴吧Flash播放器破解记录 中, 使用getURL生成的乐谱信息url去请求乐谱服务器得到的返回值里, 是包含.ypa2格式的资源地址的, 只不过现在.ypa2资源已经被删了, 不过观察刚才免费的乐谱.ypdx资源地址后, 会发现这和.ypa2的资源地址高度相似! 于是我将返回的.ypa2资源地址修改后缀名为.ypdx进行请求之后, 顺利得到了.ypdx格式的播放文件!\n//ypa2请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypa2 //ypdx请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypdx 得到.ypdx文件之后, 开启一个本地HTTP服务器, 开放一个地址用于返回.ypdx文件, 然后用Charles对VIP乐谱请求中m=getYpdsUrl断点, 并修改响应中result里对应的资源地址为本地HTTP服务器地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 再次测试, 成功打开VIP乐谱, 并开始播放, 所有功能正常!\n image-10 \n确定伪造响应的方案确定可行之后, 下一步就是要让播放器请求我指定的地址了, 因为刚才是通过Charles修改响应的, 但我不可能每次都使用Charles断点, 我需要反编译xxplayer.exe, 并修改服务请求地址为我监听的地址, 然后由我监听的地址返回所需数据\n使用OllyDbg(以下简称OD)反汇编xxplayer.exe, 在菜单栏依次点击 \u0026ldquo;插件\u0026rdquo; -\u0026gt; \u0026ldquo;中文搜索引擎\u0026rdquo; -\u0026gt; \u0026ldquo;搜索UNICODE\u0026rdquo;, 以Charles捕获到的url中的关键字codeindex搜索, 发现一共有三处\n iamge-11 \n Warning: 此处我没有使用虚拟机打开, 建议各位反汇编的时候用虚拟机, 因为被反汇编的程序如果有反调试的代码, 轻则闪退重则格盘. 另外OD本身是不带\u0026quot;中文搜索引擎\u0026quot;插件的, 需要自行下载安装\n 双击搜索到的第一处字符串, 跳转到引用代码段, 通过字符串格式可以看出, 其中%s是要用参数替换的, 且通过前面的push可以看出, 它自身也是作为参数被传递的, 那么只要跟踪下方离他最近的call之前的变量, 就能确定需要修改哪一行了, 在可疑的push处按F2断点, F8单步调试后, 发现push [local.7]正是请求的域名\n image-12 \n为了修改字符串, 有两种方式\n 如果修改前后字符串长度相同, 可以直接定位到字符串地址进行修改 如果长度不同, 可以在程序空白处, 新增一段字符串, 然后将之前对字符串的地址引用改为新增的字符串地址   程序空白处是指在OD左下角的数据面板, 拉到最下面, 可以看到一堆00 00 00 00 00 00 ..., 00在汇编中就是啥都没有, 啥都不干, 也就是空白的意思\n 这里暂时不知道[local.7]哪儿来的, 所以我选择第二种方式, 查看OD左下角数据面板, 拉到最下面, 找到程序空白处, 双击空白地址, 在弹出的编辑窗口中取消勾选\u0026quot;Keep size\u0026quot;, 在UNICODE栏输入localhost:7777\n image-13 \n image-14 \n Q1: 为什么不在011808E0行的6C 65 57后面的00处添加, 而是在00的后面?\n 因为汇编中字符串是以00结尾, 且每个字符后面都跟一个00, 为了尽量避免覆盖前面的数据块, 这里空开一个00位置, 如果前面数据块明显是字符串,需要空开三个00, 因为结束符00后面也会跟一个00\n   Q2: 为什么取消勾选\u0026quot;Keep size\u0026quot;\n Keep size的作用是保持长度字符串长度一致, 因为如果超过原来的长度会造成不可预知的错误, 但是这里是程序空白处, 后面都是空白行, 所以不需要保持长度, 有多少写多少\n  此时点击新增的字符串头6C可以在底部栏看到新字符串的起始地址为0x11808E4, 回到汇编面板, 双击刚才的push [local.7]所在行, 在弹出的面板中修改为 push 0x11808E4\n 由于修改后的代码较之前的代码更少, 需要勾选\u0026quot;Fill with NOP`s\u0026quot;来保持长度一致\n  image-15 \n可以看到在汇编面板右侧已经自动显示了标记, 提示当前push的值为localhost:7777\n image-16 \n现在选中刚才在数据面板添加的字符串十六进制代码块, 右键点击\u0026quot;复制到可执行文件\u0026quot;, 再选中汇编面板所有修改的行, 右键点击\u0026quot;复制到可执行文件\u0026quot; -\u0026gt; \u0026ldquo;选中行\u0026rdquo;, 在弹出的面板中右键\u0026quot;备份\u0026quot; -\u0026gt; \u0026ldquo;保存数据到文件\u0026quot;即可保存修改后的exe文件\n image-36 \n执行修改后的程序, 发现程序异常退出, 用OD打开修改后的文件, 再次找到刚才修改push的地方, 发现右侧没有显示localhost:7777的标记\n image-17 \n再看看跳转地址0x11808E4, 也不是刚才修改的字符串内容\n image-18 \n虽然不知道为什么, 但是看来push [local.x]形式的代码不能这样简单的修改. 那么换个角度想想[local.7]的值是哪里来的, 这时突然想到播放器启动的时候, 带的参数里是有一个网址的\nfile=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 我将这个网址修改为百度的网址\nfile=http://www.baidu.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 重新运行, 抓包发现它真的去请求百度的/codeindex.php接口了\n image-19 \n于是我再将参数换成localhost:7777, 重新运行, 结果发现程序异常退出, 进行跟踪调试发现[local.7]的实际值被截取了不包含端口号的部分, 为localhost\n image-20 \n尝试跟踪截取部分的代码, 但是太麻烦了决定放弃. 这时候我想到直接将整个url\n%s://%s/codeindex.php?d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s 中第二个%s直接替换成localhost:7777不就可以了? 但是这样就少了一个%s, 参数对不上后面的代码一定会报错, 于是我想到在?后面再加一个参数, 参数名随意, 参数值就用[local.7], 反正对于串来说, %s的数量能够对应参数的数量即可, 而对于HTTP请求来说, 多一个参数也没什么影响. 不过修改后字符串的长度就对不上了, 所以还是在程序空白处添加了一个新的字符串如下\n%s://localhost:7777/codeindex.php?a=%s\u0026amp;d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s  image-21 \n其中a就是新增的无用参数, a后面跟的%s将会被[local.7]的值替换, 这样一来无论启动参数中的域名是什么都无所谓了. 记录新字符串的地址为0x11808E4, 找到push原来字符串的汇编代码, 修改push地址为新的字符串地址\n image-22 \n再次保存执行, 程序还是异常退出, 用OD打开修改后的程序发现地址正确, 字符串正确, 但是还是会报错, 于是我怀疑不能用localhost作为域名. 将localhost:7777修改为127.0.0.1:7777, 再次运行, 这次终于在后台收到了来自播放器的HTTP请求!\n image-23 \n所有参数也都正常接收, 接下来只要返回正确的响应就行了, 对于m=index的直接返回\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;0\u0026quot;}} 对于m=getYpdsUrl 的则返回\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 然后, 用同样的方式修改搜索codeindex结果中的第二处, 再次运行就能正常播放了.\n继续破解 现在虽然播放曲谱没有问题了, 但是现在还有如下几个VIP功能用不了, 要白嫖就白嫖到极致\n image-24 \n从音源开始下手, 点击\u0026quot;音源\u0026rdquo; -\u0026gt; \u0026ldquo;浏览\u0026quot;后, 播放器弹出没有权限的提示\n image-25 \n查看Charles发现期间并没有发出网络请求, 推测应该是在之前的请求里就响应过了, 这时想到最开始m=index的请求中, power节点有很多为0的字段, 仔细一看这不就是对应的权限吗? 推测权限字段对应关系应该是\n openPower 打开的权限 printPower 打印的权限 printCount 可打印的数量 vstPower 使用vst音源的权限 pdfPower 转换pdf的权限  参考正常响应中openPower为1, 其他的为0, 因此把后台响应中所有为0改为1, 再次点击音源, 发现可以正常选择了\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;1\u0026quot;}}  image-26 \n接下来看看点击转换PDF功能, 通过Charles发现会发送一个权限请求\n image-27 \n其中接口仍然是/codeindex.php, 但本次m取值为addDynamic, 在OD中发现就是刚才上文codeindex搜索结果中的第三处\n image-28 \n双击搜索结果字符串转到汇编代码,00F63EAE 处的push地址就是将要用来替换成请求域名的参数, 这个地址指向了某琴吧的域名, 所以这里采用同样的办法, 先在程序空白处添加字符串127.0.0.1:7777, 然后修改push原来串的地址修改为新增的字符串地址\n image-29 \n重新保存, 然后在乐谱工具中监听这个地址, 并参考m=index的响应以下结果\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n {\u0026quot;data\u0026quot;:{\u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;}}} 重新打开运行PDF保存, 发现可以转换并保存了\n image-30 \n打印的功能和PDF的请求地址和参数m是一样的, 只要返回同样的响应就可以了\n至此VIP功能全部破解\n但是尚不完美 最后做脱机测试的时候发现播放器会先检查网络连接状态, 没有网络连接则无法播放\n image-31 \n但是我的目标是播放器能够脱机使用, 而且实际上播放器被我修改后已经不需要再连上互联网, 只需要请求乐谱工具的HTTP服务地址就可以, 因此根据弹窗搜索字符串, 定位到相关代码\n image-32 \n可以看到播放器在00F693E2处调用系统接口得到网络连接状态, 在00F693EC处, 如果有网络连接则会跳转到00F6940A处继续, 没有网络连接则会显示并中断运行, 那我只需要让这个判断失效就可以了, 双击00F693EC打开编辑窗口, 将jnz (不等于0则跳转) 修改为jmp (无条件跳转), 这样运行至此的时候将不会判断网络连接状态, 直接运行后面的代码\n image-34 \n image-35 \n同样的, 在使用转换PDF功能时还会检测网络状态, 然后弹窗提示\u0026quot;没有检测到网络!\u0026rdquo;, 找到代码运行处, 修改00F75DDE处的jnz为jmp即可\n image-33 \n保存后重新运行, 现在脱机情况下播放器能够正常打开并请求乐谱工具的HTTP服务并正常播放乐谱了, 转存PDF文件等VIP功能也能够正常使用\n至此exe版本宣告完美破解 ","date":"2021-05-26T00:50:44+08:00","image":"/posts/hack/xtan/exe/cover_hu9fa22720e1e2994b8f7276f9d33830a9_2622630_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/exe/","title":"某琴吧EXE播放器破解记录"},{"content":"背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.\n同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.\n目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用\n网站乐谱页  image-1 \n开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下\n 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图\n 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?\n首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3.6a 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 flash_player_debugger, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:\n image-2 \n其中Main为主类, init1 为初始化函数, 这里可以得到入参, 参数传入形式为\nplayer.swf?id=1 而配置类Config定义了服务端接口地址:\n image-3 \n但是很遗憾在player.swf中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时Sounds.swf就很可疑了, 通过阅读player.swf的代码发现Sounds.swf是点击播放按钮之后, 作为一个函数库被加载进来的, 这里load的地址就是Config里定义了Sounds.swf资源地址\n image-4 \n请求响应之后通过回调函数onSwComplete将其载入并储存到Clib类的成员变量clib中\n image-5 \n然后就可以通过utils.Clib.clib.xxx的方式调用函数, 再深入跟踪代码, 发现Clib中的getURL非常可疑\n image-6 \n找到他被调用的地方, 加一行日志跟踪一下输出\n image-7 \n调试运行之后输出的字符串为:\n image-14 \n这个地址跟第四步的请求地址就是同一个地址! 这就是我要找的东西, 现在只需要反编译Sounds.swf, 把getURL的算法抄下来就可以了! 想法很美好, 但现实很骨感, Sounds.swf反编译后发现经过了加密混淆, 反编译出来的代码是这样的\n image-8 \n这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹\n image-9 \n这url不就是刚才输出的地址吗, 显然此处的代码是将url中的%s, %d替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个Sounds.swf是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用getURL这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询ActionScript资料, 发现可以通过ExternalInterface, 让.swf将接口暴露出来提供外部Flash容器调用, 对于player.swf来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用WinForm的Shockwave Flash组件.\n于是修改player.swf的源码, 在Main中定义一段可供外部调用的函数\n image-10 \n其中函数名为swfExtGetypURL, 入参为string类型的乐谱ID, 函数首先检查clib是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用Clib的getURL返回乐谱信息url.\n上文提到clib是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化clib的函数onSwComplete, 仿照其代码, 在Clib中写一段初始化代码如下:\npublic static function myLoadSwf() : void { swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady); swfLoader.load(new URLRequest(Config.flash_sound_lib_URL)); } internal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); } 并将原来的初始化代码loadSwf修改为:\n//修改前 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); swfLoadCompleteCallBack(); return; } //修改后 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; if(null == CLib.clib) { swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); } else { swfLoadCompleteCallBack(); } return; } 最后在Mian类的初始化函数init1中调用myLoadSwf\n image-12 \n大功告成, 现在 player.swf 在启动的时候就会调用我添加的 myLoadSwf 函数, 开始加载 Sounds.swf 并初始化到 Clib 中. 而原来的loadSwf会先判断Sounds.swf有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过Shockwave Flash组件调用player.swf暴露出来的外部接口就可以了, 调用方式如下:\naxShockwaveFlash.CallFunction( string.Format(\u0026quot;\u0026lt;invoke name=\\\u0026quot;swfExtGetypURL\\\u0026quot; returntype=\\\u0026quot;xml\\\u0026quot;\u0026gt;\u0026lt;arguments\u0026gt;\u0026lt;string\u0026gt;{0}\u0026lt;/string\u0026gt;\u0026lt;/arguments\u0026gt;\u0026lt;/invoke\u0026gt;\u0026quot;, ypid));  axShockwaveFlash 是我在c#代码中定义的Flash容器组件成员变量, 它加载了player.swf作为内容, 代码中调用到的扩展函数名称为swfExtGetypURL, 也就是刚才在player.swf的Main中定义的ExternalInterface类型的函数, 参数为string类型的乐谱ID\n 得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;yp_create_time=\u0026lt;yp_create_time\u0026gt;1601587012\u0026lt;/yp_create_time\u0026gt; \u0026lt;br/\u0026gt; yp_title=\u0026lt;yp_title\u0026gt;Summer（菊次郎的夏天）\u0026lt;/yp_title\u0026gt; \u0026lt;br/\u0026gt; yp_page_count=\u0026lt;yp_page_count\u0026gt;5\u0026lt;/yp_page_count\u0026gt; \u0026lt;br/\u0026gt; yp_page_width=\u0026lt;yp_page_width\u0026gt;1051\u0026lt;/yp_page_width\u0026gt; \u0026lt;br/\u0026gt; yp_page_height=\u0026lt;yp_page_height\u0026gt;1487\u0026lt;/yp_page_height\u0026gt; \u0026lt;br/\u0026gt; yp_is_dadiao=\u0026lt;yp_is_dadiao\u0026gt;1\u0026lt;/yp_is_dadiao\u0026gt; \u0026lt;br/\u0026gt; yp_key_note=\u0026lt;yp_key_note\u0026gt;2\u0026lt;/yp_key_note\u0026gt; \u0026lt;br/\u0026gt; yp_is_yanyin=\u0026lt;yp_is_yanyin\u0026gt;0\u0026lt;/yp_is_yanyin\u0026gt; \u0026lt;br/\u0026gt; ypad_url=\u0026lt;ypad_url\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad\u0026lt;/ypad_url\u0026gt;ypad_url2=\u0026lt;ypad_url2\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2\u0026lt;/ypad_url2\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; 接下来, 只需要解析响应并下载资源就可以了\n 解析 yp_page_count 节点可以得到乐谱的总页数 解析ypad_url节点, 并在节点中url的最后拼接.乐谱页数.png, 即可得到真实的乐谱图片地址 解析ypad_url节点, 截取 _ 的前半部分, 再拼接 _prev.jpg还可以得到乐谱的封面图 解析ypad_url2节点即可获取真实的.ypa2格式的播放文件   由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式\n 以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对player.swf和Sounds.swf做一些修改, 首先修改player.swf的Config类, 把其中关键的加载Sounds.swf和获取封面的地址修改为localhost:7777\n//获取曲谱封面的地址 public static const flash_prev_yp_info_URL:String = \u0026quot;http://localhost:7777/yuepu/preview\u0026quot;; //获取Sounds.swf的地址 public static const flash_sound_lib_URL:String = \u0026quot;http://localhost:7777/yuepu/flash/sound\u0026quot;; 然后修改Sounds.swf在上文查找到的生成url串, 把串的前缀修改为localhost:7777\ngstaticInitter.asciz = \u0026quot;http://localhost:7777/yuepu/info?ypid=%d\u0026amp;sccode=%s\u0026amp;r1=%d\u0026amp;r2=%d\u0026amp;input=%s\u0026quot;;  此处Sounds.swf修改url后, 调用getURL返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求\n 最后在乐谱工具中开启一个端口为7777的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n  image-13 \n Adobe Flash彻底停用后的补偿方案 过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具WinForm的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, 直接导致Shockwave Flash也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.\n既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的flash_player_debugger, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的.swf文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令\nflashplayer_sa_debug.exe player.swf?id=1 即可启动 flash_player_debugger 并打开作为参数的 .swf 文件, 在C#中则可以使用Process启动, 代码如下:\nProcess.Start(\u0026quot;flashplayer_sa_debug.exe\u0026quot;, \u0026quot;Main.swf?id=1\u0026quot;); 但是在实际使用中, 发现通过命令行或者程序启动的 flash_player_debugger 打开的player.swf无法发送localhost的网络请求, 弹窗报错如下:\nSecurityError: Error #2119: 安全沙箱冲突 但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求localhost是因为他在用户文件夹下\\AppData\\Roaming\\Macromediax\\Flash Player\\#Security\\FlashPlayerTrust创建了信任文件intellij_idea.cfg, 文件内容即IDEA生成.swf的完整文件夹路径\nE:\\flash\\bin-debug 所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求localhost了\n现在解决了乐谱无法播放的问题, 但是由于flash_player_debugger不支持ExternalInterface, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用getURL获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.\n首先删除会引起报错的player.swf中使用ExternalInterface定义的接口swfExtGetypURL, 修改 myLoadSwf中定义的回调函数 onSoundsReady, 在此前初始化clib的基础上加上调用getURL返回的url, 并提取参数请求localhost:7777, 修改后的代码如下:\ninternal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); //添加的部分 if(utils.Func.ypadId != 0) { var url:* = CLib.getURL(utils.Func.ypadId); var args:* = \u0026quot;?\u0026quot; + url.split(\u0026quot;?\u0026quot;)[1] urlLoader3 = new flash.net.URLLoader(); urlLoader3.load(new flash.net.URLRequest(\u0026quot;http://localhost:7777/yuepu/fetch\u0026quot; + args)); } }  utils.Func.ypadId中存储了播放器启动时传入的乐谱ID参数\n 此时当clib初始化完成之后, 会使用传入的乐谱ID直接调用getURL, 截取返回url的参数部分, 再将参数通过HTTP请求上报到localhost:7777. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题\n//监听曲谱地址 if (httpListenerContext.Request.Url.LocalPath.Equals(\u0026quot;/yuepu/fetch\u0026quot;)) { httpListenerContext.Request.QueryString[\u0026quot;ypid\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;sccode\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r1\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r2\u0026quot;]; ... } 不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用Process启动的指定WindowStyle为ProcessWindowStyle.Hidden就可以无感使用了\nProcess.Start(new ProcessStartInfo() { FileName = \u0026quot;flashplayer_sa_debug.exe\u0026quot;, WindowStyle = ProcessWindowStyle.Hidden,//关键代码 Arguments = \u0026quot;Main.swf?id=64\u0026quot;, }) 至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的.ypa2格式播放器文件, 且删除了所有.ypa2资源, 并采用新的.ypdx文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了\u0026hellip; ","date":"2021-05-25T00:50:44+08:00","image":"/posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/flash/","title":"某琴吧Flash播放器破解记录"}]