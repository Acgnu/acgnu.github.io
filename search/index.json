[{"content":"目录  需求 准备工作 基本思路 编写服务端 编写客户端 测试效果 遇到的问题  需求 由于有时需要远程家里的电脑所以是24小时待机的, 然而大部分时间其实都是用不上的, 后来发现家里电费居高不下跟电脑有很大的关系, 财库已空的我决定设置一套网络唤醒\n首先, 需要购买专用的唤醒设备例如网卡, 开关, 支持WOL的路由器之类的就不考虑了, 家里也没有多余的设备, 于是打算给路由器刷第三方系统之后由路由器来唤醒, 我的路由器是小米的AC2100, 刷了Padavan, 刷完后自带两个内网管理插件\n DDNS插件: 因为申请不到公网IP, 所以用不了 Zerotier内网穿透插件: 配置后家里的网络连不上Zerotier服务, 查了一下说是被某些运营商屏蔽了(无语), 所以也用不了  虽然可以考虑刷支持其他内网穿透工具的固件, 但不想一个一个试, 且免费的内网穿透稳定性和速率通常都不太行, 最终决定自行编写一个WOL程序放到路由器执行\n准备工作   一台支持运行三方程序的路由器, OpenWRT或Padavan等. 在路由器「DHCP」管理页中为需要唤醒的电脑设置固定IP以及「ARP绑定」\n  电脑设置启用网络唤醒. 如何设置网络唤醒? 以我的设备为例:\n主板「B460M AORUS ELITE (rev. 1.0) 」默认开启了网络唤醒, 无需修改任何设置.\n网卡「Intel(R) Ethernet Connection (12) I219-V」设置如下:\n 关闭「以太网节能」, 可以解决关机时间过长后无法唤醒的问题, 其他唤醒相关设置均已默认开启, 无需改动\n 1219v     测试效果. 反复关机测试并不方便, 我们可以下载网络调试助手(NetAssist)在开机状态下模拟接收\n 协议类型选UDP 本机主机地址填本机IP地址 (例: 192.168.1.123) 端口填9, 因为魔术包是通过9端口收发的  当收到数据包时就会展示在右侧  NetAssist  然后可以在手机上微信搜索小程序「网络唤醒WakeOnLan」, 确保手机与电脑出于同一个网络, 如下图所示填写真实IP和MAC  测试效果  点击「唤醒WakeUp」即可看到电脑收到数据包了, 收包没有问题后可以关闭电脑测试\n  一台云服务器 (我这里用的是 神秘哥们 的服务器, 再次感谢 神秘哥们 的免费赞助)\n 没有云服务器? 也可以, 例如在代码托管网站上传一个文本文件, 编写的程序去请求这个文件并解析内容, 0代表不需要开机, 1代表需要. 需要开机的时候登录托管网站修改内容即可\n   搭建开发环境. 我的路由器是MIPS架构处理器, 需要搭建MIPS交叉编译环境, 其他架构自行查阅资料\n  基本思路 由于开机需求对时效性要求并不高, 所以程序周期执行即可, 由以下三部分组成:  方案 \n 服务端: 即云服务器上运行的HTTP服务, 提供两个接口  接收命令: 接收来自控制端的命令 查询命令: 提供查询最新的命令的接口给客户端   客户端: 运行在路由器上, 由crontab周期执行, 需要开机时唤醒电脑, Padavan可以在管理页面直接设置crontab, 如图所示, 填写 */1 * * * * /var/wol 表示每隔一分钟执行 /var 目录下的「wol」程序  crontab    据说路由器重启后crontab会失效, 相关帖子: 关于padavan的crontab, 如果不放心的话, 配置好crontab后在图示位置点击「提交」即可  storage \n 控制端: 由于接收命令是HTTP接口, 所以控制端可以用任何实现, 本文不提供实现, 仅通过curl命令执行  编写服务端 服务端业务简单, 综合开发速度和服务器资源采用Go语言开发, 新建wol-server项目, 添加main.go, 完整代码如下:\npackage main import \u0026quot;fmt\u0026quot; import \u0026quot;net/http\u0026quot; var wol = 0 func main() { http.HandleFunc(\u0026quot;/command/wol/push\u0026quot;, PushCommand) http.HandleFunc(\u0026quot;/command/wol/fetch\u0026quot;, FetchCommand) http.ListenAndServe(\u0026quot;:9080\u0026quot;, nil) } func FetchCommand(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026quot;%v\u0026quot;, wol) wol = 0 } func PushCommand(w http.ResponseWriter, r *http.Request) { if r.Method != http.MethodPut { http.Error(w, \u0026quot;0\u0026quot;, http.StatusMethodNotAllowed) return } wol = 1 fmt.Fprintf(w, \u0026quot;%v\u0026quot;, wol) } 代码很少简单说明一下\n 在9080端口开启HTTP服务, 暴露两个接口/command/wol/push和/command/wol/fetch, 分别对应实现PushCommand和PushCommand PushCommand将由控制端调用, 为避免在浏览器误操作限制了一下请求方式只能为PUT, 收到请求后会将开机标识wol设置为1 FetchCommand将由路由器调用, 收到请求后会首先返回开机标识wol, 然后把wol再次设置为0, 避免重复触发  云服务器是Linux 64位系统, 而开发环境是Windows 64, 我们需要交叉编译为Liunx的可执行文件\n 在PowerShell中执行$Env:GOOS=\u0026quot;linux\u0026quot;命令将目标系统设置为Linux 在开发工具终端中进入项目目录, 执行go build编译得到wol-server可执行文件  build  复制wol-server到Linux中并执行./wol-server启动服务 在CMD中执行命令curl http://服务器IP:9080/command/wol/fetch预览效果   preview1 \n参考资料: GO的交叉编译\n编写路由器客户端 路由器容量和内存都很小, 所以客户端程序使用C来实现, 由于我刷入的Padavan系统支持curl命令, 所以网络请求的部分直接调用curl, 若想通过HTTP实现, 可以参考文章: 如何使用C语言实现HTTP请求\n创建CMake项目wol-client并添加源文件wol.c, 本文假设需要唤醒的电脑IP及MAC如下:\nIP 192.168.1.123\nMAC AA:BB:CC:DD:EE:FF\n 使用ping命令检测电脑是否在线\n因为程序每分钟会被执行一次, 我们可以使用函数system()去调用ping命令来判断电脑是否在线, 当电脑在线的时候就没有必要从服务器查询开机命令了, 但system()函数无法直接获取命令执行结果, 我们可以使用 \u0026gt; 将输出结果存入文本文件, 再通过读取文件内容判断电脑是否在线  system(\u0026quot;ping -c 1 -W 1 192.168.1.123 | grep -c \\\u0026quot;100% packet loss\\\u0026quot; \u0026gt; wol_temp\u0026quot;); 解释一下各项参数\n -c 表示ping的次数, 这里我们只ping一次 -W 表示等待回复的超时时间, Linux上单位为秒, 这里设定成1秒, 因为局域网内在线的机器通常一秒内都能回复 gerp 的 -c 表示只打印找到目标文本的行号, 这里我们使用gerp查找「100% packet loss」这段字符, 如果目标不在线, 那么行号会等于1, 反之行号等于0 最后使用 \u0026gt; 将gerp查找到的行号结果存入wol_temp文件中  使用文件函数读取结果  FILE *file = fopen(\u0026quot;wol_temp\u0026quot;, \u0026quot;r\u0026quot;); char cmd_value = getc(file); fclose(file);  getc()读取文件的第一个字符, 在wol_temp文件中读取到的结果只会是0或1  使用curl命令查询服务端数据, 同样将结果存入文件, 再次读取文件判断是否需要开机  system(\u0026quot;curl http://服务器IP:9080/command/wol/fetch \u0026gt; wol_temp\u0026quot;); 实现发送魔术包函数, 并通过UDP发送, 唤醒电脑  /// \u0026lt;summary\u0026gt; /// UDP方式发送魔术包 /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026quot;mac\u0026quot;\u0026gt;网卡的物理地址, 格式 XX:XX:XX:XX:XX:XX\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026quot;ip\u0026quot;\u0026gt;局域网内的IP地址, 格式 XXX.XXX.XXX.XXX\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; int send_magic_pack(const char* mac, const char* ip) { int ret = -1; int send_length = -1; unsigned char packet[102] = { 0 }; struct sockaddr_in addr; int sockfd, i, j, option_value = 1; unsigned char mactohex[6] = { 0 }; sscanf(mac, \u0026quot;%02x:%02x:%02x:%02x:%02x:%02x\u0026quot;, (unsigned int*)\u0026amp;mactohex[0], (unsigned int*)\u0026amp;mactohex[1], (unsigned int*)\u0026amp;mactohex[2], (unsigned int*)\u0026amp;mactohex[3], (unsigned int*)\u0026amp;mactohex[4], (unsigned int*)\u0026amp;mactohex[5]); //构建magic packet for (i = 0; i \u0026lt; 6; i++) { //6对“FF”前缀 packet[i] = 0xFF; } for (i = 1; i \u0026lt; 17; i++) { //目标计算机的MAC地址，重复16次 for (j = 0; j \u0026lt; 6; j++) { packet[i * 6 + j] = mactohex[j]; } } //UDP sockfd = socket(AF_INET, SOCK_DGRAM, 0); //广播 ret = setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST, \u0026amp;option_value, sizeof(option_value)); if (ret \u0026lt; 0) { //printf(\u0026quot;set socket opt failed, errno=%d\\n\u0026quot;, errno); close(sockfd); return ret; } memset((void*)\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; addr.sin_port = htons(9); addr.sin_addr.s_addr = inet_addr(ip);//UDP广播地址 //发送广播 send_length = sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr*)\u0026amp;addr, sizeof(addr)); close(sockfd); return ret; } 之后在mian()函数中调用即可. 参考资料: 魔术包和C语言实现\n其他部分完整代码如下\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int send_magic_pack(const char* mac, const char* ip); int main(int argc, char *argv[]) { FILE *file; int code = system(\u0026quot;ping -c 1 -W 1 192.168.1.123 | grep -c \\\u0026quot;100% packet loss\\\u0026quot; \u0026gt; wol_temp\u0026quot;); if (code \u0026lt; 0 || code == 127) { puts(\u0026quot;ping执行出错\u0026quot;); return -1; } file = fopen(\u0026quot;wol_temp\u0026quot;, \u0026quot;r\u0026quot;); char cmd_value = getc(file); fclose(file); if (cmd_value == '0') { puts(\u0026quot;电脑在线, 无需唤醒\u0026quot;); return 0; } code = system(\u0026quot;curl http://服务器IP:9080/command/wol/fetch \u0026gt; wol_temp\u0026quot;); if (code \u0026lt; 0 || code == 127) { puts(\u0026quot;curl命令执行失败\u0026quot;); return -1; } file = fopen(\u0026quot;wol_temp\u0026quot;, \u0026quot;r\u0026quot;); cmd_value = getc(file); fclose(file); if (cmd_value == '0') { puts(\u0026quot;当前无开机命令\u0026quot;); return 0; } puts(\u0026quot;收到开机命令, 执行开机...\u0026quot;); int ret = send_magic_pack(\u0026quot;AA:BB:CC:DD:EE:FF\u0026quot;, \u0026quot;192.168.1.255\u0026quot;); if (ret == 0) puts(\u0026quot;唤醒包已发送\u0026quot;); return 0; }  注意: 函数send_magic_pack()目标IP参数可以是192.168.1.123, 但我这里传广播地址 192.168.1.255, 原因见后文\n 编译\n在Linux中导航到源文件所在目录, 执行命令mipsel-linux-gnu-gcc wol.c -o wol -static, 得到可执行文件wol   注意: 执行mipsel-linux-gnu-gcc命令需要先搭建MIPS架构交叉编译环境\n 测试效果 全部编写好后, 将服务端发布到云服务器上并启动. 客户端可以通过WinSCP复制到路由器/var目录并配置好crontab (方法参考上文). 然后关闭电脑\n此时用另一台电脑打开CMD, 输入curl -X PUT http://服务器IP:9080/command/wol/push, 正常的话就可以看到电脑在一分钟内启动了\n如果此时没有另一台电脑, 也可以用手机打开终端(Android), 或者其他任意能够以PUT方式发送HTTP请求到服务器的也是一样的\n遇到的问题 关机时间久了(大于1分钟)之后无法唤醒\n可能的原因如下:\n 网卡没有禁用节能, 例如我的网卡需要关闭「以太网节能」, 参考上文. 另外我的路由器没有开启APR绑定, 在路由器管理页设置「APR绑定」或许也能解决 UDP发送的IP地址不对, 例如开始的时候发送包的目标IP是192.168.1.123, 刚关机可以唤醒, 但几分钟后就无法唤醒了, 后改成192.168.1.255后唤醒成功, 区别在于后者是广播地址, 关于广播的详细介绍可参考: UDP广播  还有一个很奇怪的现象, 当时用自己编写的程序(以下简称WOL), 对比微信小程序「网络唤醒WakeOnLan」(以下简称小程序) 进行测试\n刚关机几分钟内, 通过小程序以及WOL都能够唤醒电脑. 当关机几分钟后, 使用小程序能够唤醒成功, 但是通过WOL就不能. 使用网络调试助手对比过两者发送的魔术包数据是完全一致的.\n后来将WOL发送的目标IP地址改成广播地址192.168.1.255之后就可以唤醒了, 但作为对比的小程序不论填192.168.1.123还是192.168.1.255还是255.255.255.255都可以唤醒, 推测可能还是因为没有设置「APR绑定」, 释放了IP, 而小程序有做特殊处理, 发送的也是广播IP\n","date":"2023-03-06T00:50:44+08:00","image":"/posts/embeded/wol/cover_hu18a0dfe24013f6b0b7ee4adfea89b908_1280697_120x120_fill_box_smart1_2.png","permalink":"/posts/embeded/wol/","title":"基于Padavan路由器系统的远程网络唤醒(WOL)工具开发"},{"content":"目录  硬件准备 Windows上的开发环境准备 使用Ubuntu安装MIPSEL架构的交叉编译器 使用C编写Hello Word!测试 过程中遇到的问题 一点感想  硬件准备  一台基于Linux内核, 采用MIPS架构CPU的路由器, 我的是小米AC2100, 刷了Padavan系统 一台支持Windows子系统(WSL)的Windows 10的电脑  Windows上的开发环境准备   安装Visual Studio 2019.9 或以上版本\n  为Visual Studio添加Linux开发环境工具集 (安装时已勾选的可跳过)\n 在开始菜单中打开「Visual Studio Installer」 找到刚刚安装的Visual Studio 2019, 点击右侧的「修改」按钮 找到「使用C++的Linux开发」, 并勾选保存   参考资料: 如何修改开发工具集?\n   为Windows开启子系统(WSL)并安装Ubuntu\n 在Windows功能中启用 「适用于Linux的Windows子系统」和「虚拟机平台」 在Microsoft Store中搜索 Ubuntu, 下载一个Linux发行版, 我的是22.04.2 安装后, 可按照自己需要修改root密码, 设置默认以root启动, 修改镜像源等   参考资料: 如何启用Win10的WSL?\n   为Visual Studio配置跨平台编译 具体配置方式可参考微软官方教程\n 如何在Visual Studio 2019中配置WSL交叉编译环境? 如何在Visual Studio 2022中配置WSL交叉编译环境?\n需要注意的是, 开始菜单中直接搜索「wsl」可以打开一个命令窗口执行Linux命令, 而打开Ubuntu窗口也可以执行命令, 我是在Ubutnu中安装的编译工具, 因此在Visual Studio的「WSL-GCC-Debug」配置中, 「WSL」一栏需要选「Ubuntu2204」  WSL配置     使用Ubuntu安装MIPSEL架构的交叉编译器   添加源, 以root权限添加下面两行内容到 /etc/apt/sources.list 文件\ndeb http://ftp.de.debian.org/debian squeeze main deb http://www.emdebian.org/debian/ squeeze main   在Ubuntu中依次执行下列命令\nsudo apt-get update sudo apt-get install emdebian-archive-keyring apt-get install linux-libc-dev-mips-cross libc6-mips-cross libc6-dev-mips-cross binutils-mips-linux-gnu gcc--mipsel-linux-gnu g++-mipsel-linux-gnu   检查是否安装成功\nmipsel-linux-gnu-gcc -dumpmachine 安装正确会输出 mipsel-linux-gnu\n参考资料: Ubuntu下安装MIPS交叉编译器 mips-linux-gcc\n 附一个FTP的库地址备用: ftp://ftp.linux-mips.org/pub/linux/mips/people/macro/RPMS/mipsel/\n   使用C编写Hello Word!测试 回到Visual Studio中, 在项目里创建源文件hello.c并编写helloword测试代码, 代码随处可见这里就不贴了, 编写完后在Ubuntu中导航到源文件目录并执行命令\nmipsel-linux-gnu-gcc hello.c -o hello -static 得到可执行文件hello\n  在基于WSL的Ubuntu中, 可以通过路径 /mnt/Windows盘符/Windows路径 的方式便捷的访问Windows上的文件, 例如 cd /mnt/c/Windows gcc编译命令中-static可以将所需要的库一起打包, 但这样做会导致可执行文件体积偏大, 优点就是可以确保目标系统能够在缺少动态链接库的情况下执行   将可执行文件hello通过WinSCP上传至路由器/var目录, 然后SSH到路由器并执行以下命令:\nchmod u+x ./var/hello ./var/hello  hello world \n可以看到路由器已经正确输出, 现在环境配置完毕, 可以开始编写需求代码了\n过程中遇到的问题   Visual Studio配置好WSL后, 直接F5编译运行出错, 弹窗提示「Launch options string provided by the project system is invalid. Required attribute \u0026lsquo;program\u0026rsquo; is missing or has an invalid value. 」\n原因是Visual Studio版本过低(一开始用的2019.6), 更新到2019.16.11.24之后再运行就好了\n参考资料: Exception from HRESULT: 0x80004004 (E_ABORT)\n  Visual Studio跨平台连接管理器无法连接到Ubuntu  vs远程连接  首先 基于本机WSL开发并不需要配置远程调试, 以往没有WSL的时候, 通过虚拟机或服务器的Linux跨平台开发时才需要配置. 如果依然希望使用远程调试本机WSL, 则需要配置WSL Ubuntu的openSSH, 更换SSH端口, 开启允许root登录, 然后重启ssh服务即可\n参考资料: 如何通过SSH连接到WSL?\n  WinSCP无法复制文件到路由器「Error code: 4」\n winscp \n因为一开始是复制到/user目录, 但此目录空间满了, 后来复制到/var就成功了, 可以在根目录使用df命令查看空间占用率\n 空间占用 \n  程序运行出错「-sh: ./hello: Permission denied」\n因为文件没有执行的权限, 执行命令\nchmod u+x hello 之后再执行程序即可\n  程序运行出错「line 1: syntax error: unexpected word (expecting \u0026ldquo;)\u0026quot;)」\n因为编译出来的可执行文件的指令集, 或者位数(64/32)不符合目标平台的CPU, 我的小米路由器AC2100搭载的CPU为MT7621A, 是一颗MIPS架构32位的CPU, 而最开始Visual Studio使用默认编译环境生成的平台是Intel x64, 所以路由器无法执行. 解决方法是在Ubuntu上安装mips架构的gcc编译器重新编译\n说一下发现过程:\nMIPS同ARM类似是属于嵌入式CPU的一种, 由于没有接触过嵌入式Linux开发, 仅在官网CPU介绍界面看到了MIPS字样, 同时看到很多嵌入式编译提到ARM字样, 推测MIPS也有自己的编译工具, 但网上ARM教程居多, MIPS很少, 大部分MIPS都需要自己使用「buildroot」或「crosstool-NG」生成编译工具, 找了好久才找到能直接用的编译工具mips-linux-gnu-gcc, 但编译出来的文件还是报一样的错, 一度怀疑是位数的问题, 但是加上参数指定位数mips-linux-gnu-gcc -mabi=32编译依然没有解决.\n后来我从路由器中复制出来一份自带的程序zerotier-one, 用记事本打开并和我自己编译的程序对比, 显示两者都是以ELF开头的后面接二进制数据, 说明我编译出来的确实是可执行文件.\n elf \n再后来用file命令分别查看两个文件, 显示zerotier-one和我编译的有所不同.\nhello的file信息\nELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld.so.1, BuildID[sha1].\u0026gt; =5cffbd2c17c264eadb4b91fa4490d868de7e4e15, for GNU/Linux 3.2.0, not stripped zerotier-one的file信息\nELF 32-bit LSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped 可见最大的差别就是MSB和LSB, 查询资料后了解到是高低在前的问题, 两者的数据内容相反.\n参考资料: MSB和LSB区别\n于是编译时加上参数mips-linux-gnu-gcc -EL\n/usr/lib/gcc-cross/mips-linux-gnu/10/../../../../mips-linux-gnu/bin/ld: /usr/lib/gcc-cross/mips-linux-gnu/10/../../../../mips-linux-gnu/lib/../lib/libgcc_s.so.1: error adding symbols: file in wrong format collect2: error: ld returned 1 exit status 但是报错了, 再后来注意到 MIPS编译工具也是分为MIPS和MIPSEL的, MIPSEL编译结果是低位在前, 就是我们想要的LSB文件, 而我一开始安装的编译工具是「gcc-mips-linux-gnu」, 即生成高位在前的可执行文件, 而当我直接执行 mipsel-linux-gnu-gcc会提示未安装\nCommand 'mipsel-linux-gnu-gcc' not found, but can be installed with: apt install gcc-mipsel-linux-gnu 我们根据提示执行 apt install gcc-mipsel-linux-gnu 安装后就可以使用mipsel-linux-gnu-gcc命令了\n  执行程序出错「-sh: ./hello: not found」\n原因是缺少运行库, 可以从别的地方复制库过来并配置环境变量啥的, 也可以简单点编译的时候加上-static参数直接把需要的库打包进程序里\nmipsel-linux-gnu-gcc hello.c -o hello --static 参考资料: linux 执行程序时，提示not found问题分析\n  其他探索\n 可使用cat /proc/cpuinfo命令查看CPU信息, 可得到关键信息32, MIPS, 1004K, MT7621, 然后查找相关资料 可使用uname -a命令查看系统信息, 但是不多, 可使用cat /proc/version命令查看系统信息, 如下  R2100:/proc # cat /proc/version Linux version 3.4.113 (root@fv-az19-273) (gcc version 7.4.0 (crosstool-NG 1.24.0) ) #1 SMP Wed Oct 20 17:03:44 UTC 2021 其中的 crosstool-NG 1.24.0, 是交叉编译工具, 所以这套系统应该是用这个工具编译出来的, 同理应该可以用这套工具编译自己的程序, 但网上很难找到现成的, 需要自己构建\n 可使用readelf命令查看可执行文件信息, 查看hello的信息如下:  wol  而路由器中自带的程序 zerotier-one的elf信息如下  zerotier-one  可见一眼看上去并没有明显差别, 都是MIPS 路由器上可以执行shell脚本和curl, 但我需要发送UDP路由器上的系统无法实现, 例如/dev/udp/xxx.xxx.xxx.xxx/x路由器并不支持, 还是只能用代码    最新发现\nGo语言原生支持Windows交叉编译MIPSEL, 在GO环境变量中将GOOS设置为linux, GOARCH设置为mipsle (没有拼错), 就可以直接用go build命令编译出MIPS架构LSB的可执行文件\n  一点感想 网上关于MIPS架构的资料太少了, 因为此前也没有这方面基础, 从开始到出结果可谓一波三折, 走了太多弯路, 所以这次记录下来便于以后查阅\n","date":"2023-03-03T00:50:44+08:00","image":"/posts/embeded/mipsel/cover_hu7d17bde0146cbb763a18c7e5ec702040_147670_120x120_fill_box_smart1_2.png","permalink":"/posts/embeded/mipsel/","title":"在Windows上使用基于WSL的Ubuntu搭建MIPSEL架构的C语言交叉编译环境"},{"content":"背景 某抑云音乐随着版本更新, 加入了越来越多的垃圾功能和广告, 严重影响体验, 而且在歌单播放按钮上添加了购买VIP按钮, 不仅比播放按钮大, 还是延迟显示的, 非常容易误按, 就很生气, 于是决定干掉它们\n目标 精简某易云UI, 只留下自己需要的部分, 同时各个地方的广告和更新提示\n受害者版本 V7.2.10.782837\nAPP界面概览  image-1 \n开始破解 直接用反编译工具Jadx, 打开安装包即.apk, 发现软件没有加壳, 可以顺利反编译出源码, 直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n 虽然没有加壳, 但是经过了混淆, 阅读性非常差, 而且绝大部分字符串都经过了加密, 无法直接搜索, 可以说是非常猥琐了\n  image-2 \n1.去除多余标签 首先去除本人用不上的标签页, 只需要留下\u0026quot;我的\u0026quot;标签页就行\n image-3 \n首先全局搜索文字\u0026quot;我的\u0026quot;\n image-4 \n发现能够完全匹配标签栏四组文字的, 在一个arrays.xml文本里, 其中节点的name为ap, 于是搜索R.array.ap\n image-5 \n可以发现一处搜索结果, 位于MainActivity, 应该就是需要找的目标了, 看看这个b方法的实现\n image-6 \n发现此方法只是把xml里的数组保存, 那么我只需要把这个入参的值修改一下, 应该就可以实现去除多余标签的作用了, 编写xposed模块代码如下\nfindAndHookMethod( \u0026quot;com.马赛克ease.马赛克music.activity.r\u0026quot;, loadPackageParam.classLoader, \u0026quot;b\u0026quot;, String[].class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { param.args[0] = new String[]{\u0026quot;我的\u0026quot;}; } } ); 此代码将在b方法执行前执行, 将原本带有4个节点的数组重新赋值为只有一个的数组, 实际执行效果如下\n image-7 \n可以看到除了\u0026quot;我的\u0026quot;以外的标签, 其他的都已经不再显示了\n2.去除用户VIP信息 用户VIP信息如下, 纯属占位置又无用的一块节点\n image-8 \n首先在Android Device Monitor查看一下VIP信息中头像节点的父节点id\n image-12 \n可以看到id为headerMyInfo, 在源码中全局搜索headerMyInfo, 找到HeaderEntryListViewHolder中有一处实际调用\n image-11 \n此处将headerMyInfo的view传入MyVipInfoViewHolder作为参数, 之后创建了MyVipInfoViewHolder, 因此只需要修改一下传入的headerMyInfo布局参数, 即可隐藏这个节点, 编写xposed代码如下:\nfindAndHookConstructor( \u0026quot;com.马赛克ease.马赛克music.module.mymusic.headerentry.MyVipInfoViewHolder\u0026quot;, loadPackageParam.classLoader, View.class, \u0026quot;com.马赛克ease.马赛克music.module.mymusic.k\u0026quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { View view = (View) param.args[0]; view.setVisibility(View.GONE); } } ) 此代码拦截MyVipInfoViewHolder的构造函数, 并将传入的参数headerMyInfo修改显示方式为View.GONE, 以达到隐藏的目的. 编写完后运行结果如下, 可以看到VIP节点已经成功隐藏\n 注: 一个界面节点在创建之后可能会被多次调用, 直接删除节点可能会引起报错, 因为隐藏节点最为妥当\n  image-13 \n3.隐藏小程序标题以及小程序列表 此处小程序列表本人也是从来不用, 而其所占位置之大令人发指\n image-14 \n在Android Device Monitor中看到标题节点的父节点id为miniAppListSection\n image-17 \n搜索这个id\n image-15 \n发现其在SimpleSectionViewHolder的构造函数中被调用, 该构造函数代码如下\n image-16 \n可以看出这里和刚才的VIP信息代码几乎一致, 因此可以采用刚才的方式进行隐藏, 但不同的是SimpleSectionViewHolder这个类有多处调用\n image-18 \n为了保证我们隐藏的view参数是小程序的标题, 因此需要查看一下传入miniAppListSection节点的资源id\n 资源id是安卓应用在编译后对应每个节点生成的唯一id, 在编译期间可以使用R.id/R.array/R.layout等其实都是引用了这个id, 在编译后会生成在R.java中, 还有一个public.xml中存在一个同样的值与之对应\n 点击调用SimpleSectionViewHolder构造函数中参数R.id.miniAppListSection可以跳转到R.java, 此时看到的资源id为2131299470\n image-19 \n现在可以编写xposed代码如下\nfindAndHookConstructor( \u0026quot;com.马赛克ease.马赛克music.module.mymusic.SimpleSectionViewHolder\u0026quot;, loadPackageParam.classLoader, View.class, \u0026quot;com.马赛克ease.马赛克music.module.mymusic.k\u0026quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { RelativeLayout layout = (RelativeLayout) param.args[0]; if (layout.getId() == 2131299470) { layout.setVisibility(View.GONE); } } } ); 这里拦截SimpleSectionViewHolder的构造函数, 当资源节点的id为2131299470时, 将节点隐藏\n继续寻找小程序卡片的布局, 这里卡片节点没有合适的节点id用于搜索, 因此找到他的父节点id为myMusicRecyclerView\n image-20 \n全局搜索myMusicRecyclerView, 得到多处结果, 但位于com.马赛克ease.马赛克music.module.mymusic.k中因为使用到了类MiniAppListLinearViewHolder, 根据名称推测MiniAppListLinearViewHolder应该是用于创建卡片父节点列表的\n image-21 \n其中bindType调用了MiniAppListLinearViewHolder.a(), 跳转进去可以看到内部调用了构造函数\n image-23 \n看一眼MiniAppListLinearViewHolder的构造函数代码\n image-22 \n实现也非常简单, 推测可以使用刚才的方式将隐藏, 编写xposed代码如下:\nfindAndHookConstructor( \u0026quot;com.马赛克ease.马赛克music.module.mymusic.miniapp.linear.MiniAppListLinearViewHolder\u0026quot;, loadPackageParam.classLoader, View.class, \u0026quot;com.马赛克ease.马赛克music.module.mymusic.k\u0026quot;, int.class, int.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { View miniAppListView = (View) param.args[0]; ViewGroup.LayoutParams layoutParams = miniAppListView.getLayoutParams(); layoutParams.height = 0; } } ); 这里拦截MiniAppListLinearViewHolder的构造函数, 并将布局高度改为0, 达到隐藏的目的, 运行效果如下\n image-25 \n在隐藏了这么多节点之后, 布局出现了一点问题\n image-26 \n可以看到\u0026quot;本地音乐\u0026quot;这一栏的按钮偏下了, 需要调整一下位置. 首先查看一下这一栏按钮父节点id\n image-27 \n可以看到父节点id为centerContainer, 全局搜索后可以找到一处调用\n image-28 \n这个节点被赋值为成员变量f15898e, 而这个变量名是由反编译工具改名而来, 可以看到反编译提示原本变量名为e\n image-29 \n下面需要修改这个节点的布局参数, 编写xposed代码如下\nfindAndHookConstructor( \u0026quot;com.马赛克ease.马赛克music.module.mymusic.headerentry.HeaderEntryListViewHolder\u0026quot;, loadPackageParam.classLoader, View.class, \u0026quot;com.马赛克ease.马赛克music.module.mymusic.k\u0026quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { LinearLayout view = (LinearLayout) getObjectField(param.thisObject, \u0026quot;e\u0026quot;); FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams(); layoutParams.bottomMargin = 50; layoutParams.gravity = Gravity.BOTTOM; } } ); 此处拦截赋值部分的方法, 在HeaderEntryListViewHolder的构造方法执行之后, 获取到成员变量e并修改其布局为Gravity.BOTTOM, 将节点靠底排列, bottomMargin=50, 距离底部50个边距, 编译后运行效果如下\n image-30 \n可以看到按钮正常排列了\n 按钮上方留白一段距离主要是为了设置背景的时候可以看到\n 至此, 首页全部整改完毕, 完整效果图如下\n image-31 \n4.去除播放列表顶部广告按钮 这个该死的广告按钮和播放按钮放一块非常容易误触\n image-32 \n首先查看节点id, 得到exposureGuideIcon\n image-33 \n全局搜索, 发现在构造函数中有一处引用\n image-34 \n通过搜索new ExposureGuideView查看实例被创建的地方, 找到两处, 但当前界面是播放列表, 因此关注PlayListFragment\n image-35 \n实例在PlayListFragment的cl方法中被创建, 查看一下cl的完整代码\n image-36 \n初步分析基本上都是干的和广告相关的事, 因此直接拦截取缔这个方法, 编写xposed代码如下\nfindAndHookMethod( \u0026quot;com.马赛克ease.马赛克music.fragment.PlayListFragment\u0026quot;, loadPackageParam.classLoader, \u0026quot;cl\u0026quot;, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return null; } } ); 此处代码直接替换原有方法执行, 不做任何事, 之后运行效果如下\n image-37 \n可以看到广告已经被移除了\n5.去除开屏广告 开屏广告非常烦人, 且严重影响启动速度, 必须移除\n 以下修改均为2019年期间, 我也不记得当时具体是怎么找的了, 只能以现有结果大致推测\n 首先从启动类入手, 查看AndroidManifest.xml, 找到intent-filter为android.intent.category.LAUNCHER的一项Actvity即为启动类, 这里为LoadingActivity\n image-38 \n查阅LoadingActivity的代码, 会发现其重写了onActivityResult\n image-39 \n接着深入查看一下h方法\n image-40 \n再看看i方法\n image-41 \n这里出现了一个关键的类 LoadingAdFragment, 看名字就像是一个读取广告的, 点进去查看一下类的代码可以看到, 在onCreate的时候从Bundle里尝试读取AdInfo, 这越看越像广告\n image-44 \n那么看一下取的key名称, 也就是变量f5823d的值\n image-43 \n可以看到这个键的名称也是叫做adInfo, 那么根据onCreate里的代码来看,如果取不到adInfo, 那应该就不会展示广告了吧, 而arguments参数是从getArguments()方法中获取的, 点进去看一下这个方法的实现\n image-45 \n可以看到getArguments()只是返回了this.mArguments, 而this.mArguments是从setArguments(Bundle bundle)赋值的, 那我只要拦截赋值方法将adInfo这个广告过滤掉就可以了\n于是编写xposed代码如下\nfindAndHookMethod( \u0026quot;androidx.fragment.app.Fragment\u0026quot;, loadPackageParam.classLoader, \u0026quot;setArguments\u0026quot;, Bundle.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { Bundle arg = (Bundle) param.args[0]; if (arg == null || !arg.containsKey(\u0026quot;adInfo\u0026quot;)) { return; } arg.putSerializable(\u0026quot;adInfo\u0026quot;, null); } } ); 这里拦截了setArguments, 判断传入的参数是否包含键为adInfo的参数, 如果有的话, 把这个bundle设置为null\n但这并不完美, 因为只是隐藏了广告, 请求广告的代码任然会执行, 浪费资源, 因此继续深入追踪代码, 再经过一番我也不记得当时怎么找到现在也因为很复杂懒得找的寻找之后, 最终确定到com.马赛克ease.马赛克music.module.ad.a.a类中的a(int, string)是实际执行请求广告的代码, 如下:\n image-46 \n这一部分代码无法反编译出来, 但问题不大, 反正不需要执行这部分代码, 直接编写xposed代码如下\nfindAndHookMethod( \u0026quot;com.马赛克ease.马赛克music.module.ad.a\u0026quot;, loadPackageParam.classLoader, \u0026quot;a\u0026quot;, int.class, String.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return null; } } ); 直接拦截并替换掉目标方法, 不做任何事情, 这样一来就不会再请求广告了, 编译后运行发现进入速度变快了也没有烦人的开屏广告了\n6.去除更新检查 更新弹窗非常烦人, 必须干掉. 首先一般更新检查都是调用的同一个地方的代码, 直接来到APP的\u0026quot;关于\u0026quot;界面, 找到更新检查按钮, 通过Android Device Monitor可以看到更新按钮的id为updateVersionArea\n image-47 \n全局搜索这个id, 在setOnClickListener处有调用\n image-48 \n这里直接通过调用方法传入了参数, 一路跟踪这个方法, 都是比较简单的调用, 这里的分支查看super.a(z)的代码\n image-50 \n最终会来到com.马赛克ease.马赛克music.appupdate.a.a类, 看这个包名推测确实没找错地方, 而最终调用的a(boolean)应该就是检查更新的核心代码\n image-49 \n不多说直接编写xposed代码进行拦截, 代码如下\nfindAndHookMethod( \u0026quot;com.马赛克ease.马赛克music.appupdate.a\u0026quot;, loadPackageParam.classLoader, \u0026quot;a\u0026quot;, boolean.class, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam methodHookParam) throws Throwable { return null; } } ); 直接将拦截目标方法替换掉, 不执行任何业务, 编译后再次打开APP会发现已经去除了更新检查, 至此, 所有该整改都已经完成\n附录   由于这APP将所有字符串加密, 因此很多节点无法直接通过文本搜索, 经发现其解密部分的代码位于a.auu.a的c(string)方法, 可以通过xposed拦截前后参数来获得解密前和解密后的数据, 代码如下  findAndHookMethod( \u0026quot;a.auu.a\u0026quot;, loadPackageParam.classLoader, \u0026quot;c\u0026quot;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { strBeforeDec = param.args[0]; } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { MyLog.log(strBeforeDec.toString(), param.getResult().toString(), doLog); } } ); 该代码先拦截入参, 把参数记录一下, 在解密方法执行完之后打印入参和出参, 除此之外, 也可以使用xposed去主动调用解密方法, 代码如下\nClass[] argCls = new Class[]{String.class}; Object result = callStaticMethod(findClass(\u0026quot;a.auu.a\u0026quot;, loadPackageParam.classLoader), \u0026quot;c\u0026quot;, argCls, \u0026quot;待解密\u0026quot;);  拦截存储目录  可以通过以下代码拦截APP能够获取到的储存目录\nfindAndHookMethod( \u0026quot;com.马赛克ease.马赛克music.utils.马赛克easeMusicUtils\u0026quot;, loadPackageParam.classLoader, \u0026quot;c\u0026quot;, boolean.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { } @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { } } ); 马赛克easeMusicUtils工具类包含读取内置存储目录的方法, 可以在这里拦截并修改对应参数使得APP读取指定的目录\n 当初是因为APP总是读取到我音乐文件夹以外的文件夹, APP自带的过滤器又没有效果, 只能我自己改了\n 结语 不得不说这混淆确实增加了很多麻烦, 尤其是当初找广告代码的时候, 不过随着经验的增加现在找起来比以前快了很多, 另外国产APP真就一个比一个流氓, 越更新越是增加乱七八糟的功能, 因为可以同步歌单才一直没卸载, 但随着版权越抓越紧, 它已经越来越不好用了, 现在移动端已经卸载换了一个纯粹的本地播放器, 希望PC端能够保持初心吧\n","date":"2021-11-09T00:50:44+08:00","image":"/posts/hack/xeasemusic/cover_hu18a0dfe24013f6b0b7ee4adfea89b908_4335534_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xeasemusic/","title":"某抑云音乐破解简化UI去广告去更新"},{"content":"背景 最近发现一直在用的某抑云音乐越来越不行了, 没版权下架歌曲我可以理解, 但下架了也不告诉具体下架了哪些歌曲, 害得我都不知道该怎么找. 更无语的是我自己上传到某易云盘的歌曲都会因为版权问题无法添加到歌单, 而它自身的本地播放功能做的又太垃圾, 于是只能另谋出路, 在Google Play上找到一款本地播放器, 兼顾美观和功能简单实用, 不过免费版有点小广告, 然后试了几款去广告的插件, 都不能完美去除, 而我作为强迫症决定一定要处理掉\n目标 去掉各处的广告以及订购按钮\n受害者版本 V.6.2.15\nAPP界面以及广告  image-1 \n开始破解 打开Jadx, 直接把安装包即.apk文件拖进去, 发现软件没有加壳, 顺利反编译出了播放器源码, 然后直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n 源码 \n可以看到虽然源码没有加壳, 但还是有做混淆的, 不过问题不大, 首先通过Android Device Monitor解析一下当前页面的布局\n 布局 \n发现主界面中的歌曲列表部分组件的id为content, 于是全局搜索@+id/content\n content \n发现多处搜索结果, 根据当前APP所在界面以及布局文件命名推测mian_layout应该是其布局文件, 分别看看上面的viewAnim和viewAnimWithoutBackground, 这两个id在当前Android Device Monitor解析的界面中都能找到对应节点, 验证了猜想, 如下图\n DDMS \n现在要找展示广告的组件了, 通过刚才的搜索结果可以看到, 在main_layout中并没有存在疑似专门用于展示广告的节点, 所以还是很有可能是在运行过程中动态添加的, 于是我们直接搜索main_layout, 找到使用到此布局的MainActivity\n 搜索Activity \n由于暂时没有其他线索, 先看看onCreate源码能不能发现什么\n onCreate \n可以看到实现比较简单, 再看看在父类的代码, 来到D2方法, 有多个实现, 这里看MainActivity的实现\n D2 \n都是一些混淆代码, 咱也看不懂, 凭直觉都过一下, 此时在D2中就发现可疑类GooglePlayPurchaseChecker\n D2实现 \n考虑到APP是从Google Play上下载的, 可以在Google Play上购买进行解锁, 那么这个类名就显得很可疑了, 跟踪进去看看都写了啥\n checker-1 \n首先直接内部调用 aVar.g, 继续跟踪\n checker-2 \n发现这里的LinkedHashMap中存放了名为stellio_all_inclusive和stellio_premium的键, 首先这俩键的名字就很可疑, 而他们的值存储为布尔, 此时注意到有枚举ResolvedLicense用于分辨APP解锁状态\n 枚举 \n综合起来推测这个Map应该就是用于初始化一个授权值的, 以给定键的布尔值是否为true来判断应用是否已经购买, 那么我只要在初始化的时候把这个Map的值固定写死成true, 应该就可以让APP认为已经购买过了, 编写Xposed代码如下\nfindAndHookConstructor( \u0026quot;air.stellio.player.Helpers.GooglePlayPurchaseChecker\u0026quot;, loadPackageParam.classLoader, \u0026quot;air.stellio.player.Activities.u\u0026quot;, \u0026quot;org.solovyev.android.checkout.F\u0026quot;, Map.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { MyLog.log(\u0026quot;hookin GooglePlayPurchaseChecker()\u0026quot;, doLog); Map\u0026lt;String, Boolean\u0026gt; arg3 = (Map\u0026lt;String, Boolean\u0026gt;) param.args[2]; if(null == arg3) { arg3 = new LinkedHashMap\u0026lt;\u0026gt;(); param.args[2] = arg3; } arg3.put(\u0026quot;stellio_all_inclusive\u0026quot;, true); arg3.put(\u0026quot;stellio_premium\u0026quot;, true); } } ); 观察GooglePlayPurchaseChecker类中的赋值代码可以发现, 主要是通过构造函数将Map的值存储的, 因此使用Xposed的findAndHookConstructor去挂钩GooglePlayPurchaseChecker的构造函数, 在构造函数执行之前, 修改传入的第三个参数Map, 把键为stellio_premium和stellio_all_inclusive的值存为true, 这样当构造函数执行的时候, 会永远认为这是已订购的了\n安装模块并运行, 此时可以发现APP中的广告以及订购按钮都没有了\n Yeah \n","date":"2021-11-05T00:50:44+08:00","image":"/posts/hack/xstellio/cover_hu18a0dfe24013f6b0b7ee4adfea89b908_253760_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xstellio/","title":"Stellio Player破解专业版"},{"content":"背景 由于个人喜好, 比较喜欢直角屏的手机, 但市面上的手机放眼望去只有三星Note系列符合我的爱好, 遂购买三星Note 10御用, 然而这手机虽然造型是方方正正的, 但是UI却跟S系列一样到处都是圆角, 这让我很不舒服, 于是有了此文章\n目标 将系统UI的圆角修改为直角\n三星ONEUI修改前后对比图  image-1 \n基础知识 再开始之前, 首先需要了解一下基础知识\n1. 安卓系统的UI构成\n 安卓系统的界面呈现都是由内置在系统的APP构成的, 其APP一般位于 /system/app 和 /system/priv-app, 还有一个系统APP引用的公共框架APP, 位于 /system/framework/framework-res.apk, 部分系统例如Flyme在此目录还会有另外一个自己的框架APP, 命名通常以自家OS命名, 此处不作过多介绍, 界面中比较常见的APP如下 framework-res.apk 系统应用引用的界面, 例如提示信息弹窗 SystemUI.apk 系统通知栏界面, 通知弹窗界面 Settings.apk 系统设置界面, OneUI中此APP名称为 SecSettings.apk Messages.apk 短信界面, OneUI中为SamsungMessages_11.apk Gallery.apk 相册界面, OneUI中为SamsungGallery2018.apk Dialer.apk 拨号器,通话记录,联系人界面, OneUI中为SamsungDialer.apk Clock.apk 时钟,闹钟,计时器界面, OneUI中为ClockPackage.apk Finder.apk OneUI启动器(桌面)独有的搜索组件  2. 安卓实现圆角的基本方式\n 简单的实现安卓圆角可以通过\u0026lt;Shape\u0026gt;来实现, 其中\u0026lt;Corner\u0026gt;节点的属性xxxRadius为关键属性, 例如bottomRightRadius 通常是APP开发者为了减少代码重复率, 会定义一个统一风格而定义的一个统一的资源文件dimens.xml, 所有用到同样值的地方都会引用这个文件, 方便修改和风格统一  开始修改 首先修改framework-res.apk, 由于需要对源码反编译和回编译, 所以需要用到安卓反编译工具 ApkTool, 本人修改时使用的版本为v2.4.1\n首先使用命令进行反编译\napktool d framework-res.apk 中途没有错误则表示反编译成功\n image-4 \n即可在当前目录生成反编译后的源码文件夹\n image-2 \n目录简单介绍下\n assets 为APP所用到的额外资源文件包, 可以是任何东西 original 顾名思义存放原始文件 res APP所用到的资源文件, 例如图标, 国际化文本, 图形, 布局文件等 unknown 工具无法解析的文件, 回编译后会按照原样编译进去 AndroidManifest.xml APP清单文件, 记录了版本号, 包名, 权限等重要信息 apktool.yml 记录了ApkTool回编译时需要参考的信息  可以看到在此framework-res.apk中仅定义了资源文件, 并没有代码文件, 有代码的APP将在下文介绍, 在此framework-res.apk中, 只需要关注res文件夹下的资源文件就行, 我们把整个文件夹用IDEA打开, 然后根据圆角的基础知识, 直接简单粗暴先从搜索Radius开始\n image-3 \n发现多处结果, 我们缩小一下搜索范围, 可以自己写一个小的安卓应用, 定义个圆角并尝试不同圆度, 根据多次测试观察到资源文件中圆度值为26.0dip的比较符合, 因此搜索radius=\u0026quot;26.0dip, 可以发现结果少了很多\n image-5 \n接着根据资源文件命名可以大致猜出这些对应的都是哪些部分的圆角, 例如notification_template_view_bg.xml应该就是定义的通知模板背景, 根据经验这些都可以改成直角, 因此直接将所有的26.0dip修改为0.0dip\n之后, 为了更彻底的覆盖所有部分, 继续深入搜索, 只搜索26.0dip, 发现更多结果\n image-6 \n例如在dimens.xml中定义的一些值为26.0dip的数据, 需要仔细观察其name, 因为不是所有值为26.0dip的都需要修改, 例如第一行的car_seekbar_padding看名字就知道是一个填充值, 这个是不需要修改的, 但是下面的sem_menu_popup_corner_radius这种是需要修改的, 主要是经验和推测, 我们将这些需要修改的统统修改为0.0dip\n所有圆角修改完之后, 开始回编译, 在反编译出来的目录下, 执行命令\napktool b framework-res  image-7 \n像这样没有错误说明回编译成功了, 打开framework-res文件夹, 会发现里面多了两个文件夹\n image-8 \n build 回编译构建编译后的资源文件 dist 回编译后生成的APK文件  打开dist文件夹, 可以看到生成的framework-res.apk文件, 接下来需要将它替换到系统里去\n我们有四中方式替换\n 使用电脑ADB工具执行命令行替换 (简单快捷, 有一定风险) 复制到手机使用RE管理器替换 (风险较大) 制作成单刷包替换 (安全性较好, 稍微麻烦一点) 制作成ROM刷机替换 (性价比不高, 不考虑)  由于可能需要多次测试效果, 且有多个APK需要修改, 这里采用第一种方式, 需要ROOT\n步骤如下\n 打开手机里的USB调试 电脑安装手机的ADB驱动 (每个厂家的手机不一样), 装好后使用USB连接手机 使用安卓ADB工具执行命令如下  //1.将新生成的APK复制到手机存储根目录 adb push framework-res.apk /sdcard/framework-res.apk //2.执行shell adb shell //3.获取超级用户权限 su //4.复制手机存储的framework-res.apk到系统框架目录 cp /sdcard/framework-res.apk /system/framework/framework-res.apk //5.将复制进去的新APK重设rw-r-r权限 chmod 644 /system/framework/framework-res.apk //6.退出shell exit //7.重启手机 adb reboot 经过这一系列操作后, 如果没有出现意外, 手机重新开机后就可以看到修改后的效果了, 首先迎面而来的就是手机基础弹窗已经变成直角了\n image-9 \n 注意!!! 通常为了防止意外情况发生导致无法开机,需要通过Recovery备份一次系统,并将备份的系统复制到电脑以防万一,嫌麻烦的话至少也得有一份完整的刷机包,最好制作一份单刷包,如果修改后无法正常进入系统,推荐优先使用单刷包,如果单刷包无法生效,可以使用Recovery还原系统,如果没有备份系统的,则使用完整的刷机包重刷,但将丢失所有数据(双清的情况),关于单刷包的制作,我将在文章尾部补充\n 但是这还远远不够, 接下来开始处理SecSettings.apk, 仍然使用ApkTool按照上文命令进行反编译, 不过在此之前, 需要先给ApkTool安装framework-res.apk\n 由于系统APP会引用到框架APP, 因此需要给ApkTool安装框架APP, 才能继续反编译系统APP\n 通过如下命令安装framework-res.apk\napktool if framework-res.apk 安装之后就可以开始反编译SecSettings.apk了, 反编译成功之后会发现相比较framework-res.apk, 多出了几个文件夹\n image-10 \n其中smali和smali_classesX 就是应用的源代码文件, 为.smali格式的Java字节码, 类似C程序反编译出来的汇编代码, 我们先使用上文的知识将圆角值为26.0dip的圆角修改为0.0dip, 替换进系统后发现只有一部分界面的圆角变成了直角\n 文章编辑于2021年8月, 系统修改于2020年7月, 当时没有保留截图, 现在也没有重新替换的必要, 因此这部分只能描述了\n 继续检查所有可能造成圆角的值为26.0dip的.xml文件, 仍然无法找到可能存在问题的部分, 此时将检查范围扩大到源代码文件, 为了方便阅读, 首先使用Jadx反编译SecSettings.apk, 并将反编译后的.java源码导入IDEA进行观察, 搜索26发现一个可疑的方法initRoundedCorner\n image-11 \n此处推测应该是初始化一个圆度为26.0dip的圆角, 而且这个类是很多类的父类, 应该是从代码层指定了圆角的圆度, 但是此时的.java源码无法直接修改, 我们回到ApkTool反编译出来而得到的.smali源码, 根据类名方法名找到对应在.smali代码中的initRoundedCorner如下\n image-12 \nsmali代码中的第一行也是定义了一个值为26的变量, 直接将0x26改成0x0, 然后回编译替换进系统观察效果, 此时可以看到界面基本上已经变成直角了\n image-13 \n但是进入某些功能的深层选项时会发现仍然有一小部分是圆角的, 不过仔细观察这部分的圆角角度值大概在15.0dip到16.0dip左右, 因此继续搜索圆角值为这些的部分, 根据名称将可能的地方修改为0.0dip即可, 至此SecSettings.apk全部改完\n接下来按照同样的步骤修改上文列出的剩余的系统APP即可\n关于单刷包的制作 关于单刷包是什么, 有什么作用, 优缺点等网上已经有大量介绍, 此处不多说明, 仅介绍Note10下单刷包的制作\n制作OneUI单刷包\n首先我们需要一个完整的.zip刷机包, 以我的为例, 假定我们需要保留的文件为SecSettings.apk, 需要删掉除SecSettings.apk及其父文件夹以外的东西\n 尽量不要解压修改, 有时候解压了修改再压缩回去会出现奇奇怪怪的问题, 导致签名无法识别, 无法刷入\n  image-14 \n例如此处图示的部分, 红框以外的都是可以删除的, 删完后如下\n image-15 \n 从原始刷机包删除目标以外的东西做成的单刷包通常用于备份恢复, 如果是为了替换成其他文件, 例如需要做成单刷修改后的SecSettings.apk, 则删除多余文件后, 将修改后的SecSettings.apk替换到单刷包里的对应目录即可\n 接下来需要修改刷机脚本, 原始的刷机脚本通常会做很多事, 但是单刷包不需要, 我们打开位于META-INF/com/google/android下的updater-script文件, 可以看到如下代码\n image-16 \n脚本语言为updater-script, 具体语法以及含义可以自行查阅, 此处不多作介绍, 我们将内容修改如下\nui_print(\u0026quot;Mounting system\u0026quot;); ui_print(\u0026quot;\u0026quot;); mount(\u0026quot;ext4\u0026quot;, \u0026quot;EMMC\u0026quot;, \u0026quot;/dev/block/platform/soc/1d84000.ufshc/by-name/system\u0026quot;, \u0026quot;/system\u0026quot;); ui_print(\u0026quot;Copying modules\u0026quot;); ui_print(\u0026quot;\u0026quot;); package_extract_dir(\u0026quot;system\u0026quot;, \u0026quot;/system\u0026quot;); ui_print(\u0026quot;Unmounting system\u0026quot;); ui_print(\u0026quot;\u0026quot;); unmount(\u0026quot;/system\u0026quot;); show_progress(0.100000, 0); 其中关键代码为 mount挂载/system为可写分区, package_extract_dir将压缩包中system文件夹全部复制到系统的/system目录, unmount取消挂载, 其他的例如ui_print和show_progress仅为提示作用, 修改完成后, 一个单刷包就制作完毕了, 可以像普通刷机一样直接刷进系统\n结语 由于安卓的开源特性使得安卓的可玩性和定制性非常高, 我所入手的每一部安卓手机都会进行ROOT并做一定程度的修改, 最开始的时候参考前辈的教程修改了系统APK的各种背景, 特效, 音效, 性能调优, 开机动画之类的, 随着手机UI越来越美观功能以及本人时间精力越来越有限, 现在对这种定制需要也已经越来越少了, 加之谷歌对安卓开源的策略调整以厂商的限制, 进行定制也越来越麻烦了, 但我仍会继续热爱安卓, 希望安卓开放的特性能够保持下去\n","date":"2021-08-23T00:50:44+08:00","image":"/posts/hack/xrom/oneui/cover_hu84818c9c9d4fdca57166891297ad3a69_124905_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xrom/oneui/","title":"三星ONEUI修改记录"},{"content":"背景 由于某些需要, 进入某大楼的时候必须用他们物业指定的APP刷门禁, 我安装的时候是6.5.0版本, 这会儿启动速度也还可以, 也没太多花里胡哨的功能. 然而没过多久就迎来了一波强制版本更新, 更新后的版本启动速度慢到令人发指, 且增加了商城, 我就怒了, 区区门禁软件竟然这样肆意妄为, 开工!\n目标 去除更新检查, 去掉实名认证\n 某加在7.0.0版本更名为某品, 破解版本为6.5.0, 在此保持称呼其为某加\n 受害者版本 6.5.0\n 首页 \n开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某加安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某加的源码\n 7.0版本开始APP加了壳, 没记错的话是某数字安全软件的壳, 脱壳过于麻烦于是使用6.5.0版本破解\n  JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n禁用强制升级 首先根据弹窗文字\u0026quot;发现新版本\u0026quot;搜索代码\n 更新弹窗 \n发现全文匹配的仅有一处, 位于布局文件dialog_check_update.xml\n 结果1 \n查找使用该布局文件的地方, 仅有一个类UpdateNoticeDialog\n 结果2 \n查看UpdateNoticeDialog的代码, 可以看出这是一个自定义的对话框, 和APP显示的更新弹出框一致\n 结果3 \n接着查找使用到了UpdateNoticeDialog类的地方, 发现多处引用\n 结果4 \n而APP弹出更新提示的时候, 我正位于APP的首页, 可以推断出HomeActivity应该就是我要寻找的弹框处, 查看HomeActivity的代码如下\n 首页 \n可以看到这里将UpdateNoticeDialog定义为成员变量, 然后在checkUpdate中对UpdateNoticeDialog赋值, 且其他操作都位于checkUpdate中, 现在看看checkUpdate完整代码如下\n 检查更新 \n这个方法并没有做除了更新检查以外的事, 那么我只需要在Xposed中替换这个方法就可以了, 这样当APP调用checkUpdate时, 将执行我定义的方法, Xposed模块代码如下\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克.home.HomeActivity\u0026quot;, loadPackageParam.classLoader, \u0026quot;checkUpdate\u0026quot;, new XC_MethodReplacement() { @Override protected Object replaceHookedMethod(MethodHookParam param) throws Throwable { return null; } }); 这里直接使用replaceHookedMethod, 用自己定义的方法代替checkUpdate执行, 写好后重新运行可以发现首页更新弹窗已经被屏蔽了.\n然而后来手贱不小心退出登录了, 再启动APP时发现登录的时候也有更新认证, 现在可行的方法有二, 一是找到登录界面, 用同样的方法去除更新, 但是这样一来繁琐, 二来他可能还有其他的地方有更新检查, 所以使用第二种方法\n根据Android开发文档可以得知, 可以在APP的AndroidManifest.xml中可以定义当前APP的版本号, 然后可以在Java代码中使用PackageInfo来获得当前APP的版本信息, 而定义版本主要分为版本号versionCode和版本名versionName, 一般使用versionCode大小来判断是否需要更新, 而versionName则主要用作展示, 查看某加APP的AndroidManifest.xml文件, 发现其版本定义如下\n 版本 \n那么一般的做法只要将versionCode的值修改成足够大, 就能达到免更新的目的, 但是实际操作下来发现这APP比较鸡贼, 判断版本是否更新并不是简单通过versionCode大小来判断, 不过当时为了偷懒也没有进一步分析版本检查代码, 我只知道最新版本的versionName是7.0.0, 所以直接使用Xposed将返回的versionName修改为固定的7.0.0\nfindAndHookMethod(\u0026quot;android.app.ApplicationPackageManager\u0026quot;, loadPackageParam.classLoader, \u0026quot;getPackageInfo\u0026quot;, String.class, int.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { PackageInfo packageInfo = (PackageInfo) param.getResult(); if (null != packageInfo \u0026amp;\u0026amp; getTargetPackage().equals(packageInfo.packageName)) { packageInfo.versionCode = Integer.MAX_VALUE; packageInfo.versionName = \u0026quot;7.0.0\u0026quot;; } } }); 此处使用Xposed直接拦截Android系统的包管理器, 当某加需要获取版本名时, 直接返回7.0.0, 不过这样做的缺点是如果某加未来版本更新到7.0.0以上时, 需要修改代码, 然而从2020年12月破解至今, 某加都没有再发布过版本更新, 省了我不少事\n至此重新打包运行, 发现登录的更新检查也被去除了\n然而新的风暴又出现了, 由于刚才的不慎退出, 现在需要重新上传实名认证资料了, 包括身份证号和照片, 由于我之前已经填过一次, 而且上传后需要重新审核, 所以不愿意再次填写, 于是开始寻找认证部分的代码\n跳过实名认证 认证弹窗如下\n 实名认证弹窗 \n当我点击右下角的显示门禁卡二维码按钮的时候, 就会弹出认证弹窗, 我们知道Activity会通过setContentView加载一个布局文件, 此页面为APP首页, 所以在HomeActivity中搜索setContentView, 发现并没有结果\n 首页2 \n但是HomeActivity继承自BaseActivity_2019_8_22, 于是在父类中找到了setContentView\n 设置布局 \n可以看到这里加载的布局是activity_only_linear_layout.xml, 查看这个布局文件, 里面的代码非常简单\n 布局 \n根据名称可以很容易的推断出id为fab_show_qr_code的按钮组件就是首页显示二维码的组件, 搜索这个id查看他的点击事件\n 点击事件 \n根据判断逻辑, 如果CacheUtils.getStatus()返回为1, 就展示二维码弹窗, 不为1则执行checkStatus(), 以防万一, 看看checkStatus()的代码如下\n 检查状态 \n显然checkIdentityStatus()这名字就很直白的告诉我这个就是用来检查身份认证的了, 在回来看看CacheUtils.getStatus()代码如下\n 获取状态 \n这里的逻辑也很简单, 就是从登录信息中获取认证状态, 那么我只要用Xposed将getStatus()的返回值修改为1就可以了, Xposed代码如下\nfindAndHookMethod(\u0026quot;com.excegroup.community.utils.CacheUtils\u0026quot;, loadPackageParam.classLoader, \u0026quot;getStatus\u0026quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { param.setResult(\u0026quot;1\u0026quot;); } }); 拦截代码将在getStatus()执行之后执行, 将其返回值为修改为1, 现在重新运行, 程序一切正常, 也没有身份认证弹窗了, 点击显示二维码按钮正常显示门禁二维码\n ok \n","date":"2021-06-10T00:50:44+08:00","image":"/posts/hack/xplus/cover_hu3190e2a44b906316a77f497bcfe6cb92_2387451_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xplus/","title":"某加APP破解去除认证和更新"},{"content":"背景 作为一个家徒四壁的打工人, 在某鱼上购买二手的闲置商品便成了我实现梦想的捷径, 但某鱼经过多次升级改版已经相当流氓, 在我搜索出想要的商品的结果页, 嵌入识别度很低的广告, 导致我经常手滑点错, 然后直接跳转启动某宝, 某宝的启动速度又慢的令人发指, 最终还得按下多次返回才能再次回到某鱼的搜索结果页, 忍无可忍的我只能对它做一些不可描述的事了\n目标 去除搜索结果页的广告, 同时去掉每次启动就弹窗的恼人的更新提示\n受害者版本 6.7.40\n某鱼的搜索结果页  某鱼广告 \n PS:一个屏幕总共就6个展位, 某鱼你这三个广告位良心不会痛吗\n 开始破解 首先尝试使用Android反编译大杀器Jadx, 打开Jadx, 直接把某鱼安装包即.apk文件拖进去, 发现软件没有加壳, 可以看到Jadx顺利反编译出了某鱼的源码\n JADX-源码 \n直接按 Ctrl + S 将源码全部保存, 然后导入IDEA, 开始分析代码\n首先从输入搜索目标后, 点击搜索的按钮开始入手\n 搜索面板 \n在代码中查找\u0026quot;搜索\u0026quot;关键字, 发现有多处匹配, 结合搜索面板底下的历史搜索布局, 推测该面板的布局文件应该是search_mid.xml\n 面板代码 \n搜索布局文件引用的地方, 发现其在SearchMidActivity中被使用\n 布局使用 \n再查看布局文件代码, 搜索按钮的组件ID为search_button, 在SearchMidActivity中查找相关引用\n 搜索点击1 \n 搜索点击2 \n可以看出按钮点击后, 首先会调用searchKeyAction, 再经过层层调用最后到达searchNormal, 之后就会通过 gotoResultActivity 跳转到结果页, 继续跟踪gotoResultActivity方法\n 搜索点击3 \n此处出现searchresult字符, 搜索这个字符\n 搜索点击4 \n可以看出这个字符串对应的页面应该是 SearchResultActivity, 打开这个类之后一眼看不出什么重要的东西, 然后线索就这么中断了\n线索中断之后, 可以用Xposed拦截某些可疑方法, 然后通过打印调用堆栈的方法, 继续分析, 比如此我找到的SearchResultInterrupter中的checkInterrupt方法\n Xposed是一款Android底层的框架, 能够从虚拟机层拦截系统所有执行代码, 而Xposed模块是使用Xposed提供的SDK所开发的Android应用, 能够借助Xposed实现对所有关心代码的拦截, 详情请戳Xposed官网\n Throwable ex = new Throwable(); StackTraceElement[] stackElements = ex.getStackTrace(); if (stackElements != null) { for (int i = 0; i \u0026lt; stackElements.length; i++) { MyLog.log(stackElements[i].getClassName() + \u0026quot; -\u0026gt; \u0026quot; + stackElements[i].getMethodName() + \u0026quot;()\u0026quot; , true); } } 不过这样比较麻烦而且也不好找. 于是换个思路, 安装Xposed模块XAppDebug, 为某鱼强制开启Debug模式, 此时查看控制台会显示所有某鱼打印的日志信息, 现在控制台显示了包括网络请求在内的日志信息\n MTOP \n最终找到可疑类MtopResponse, 分析代码可以推测这个类应该是一个封装了网络响应的类, 其成员变量bytedata是主要数据源, bytedata将会被转换成dataJsonObject的JSON对象储存, 然后被使用, 因此找到bytedata赋值的方法setBytedata\n 响应模型 \n 破解时间于2020年8月, 文章编辑时间为2021年6月, 我也不记得当初是不是这样找到MtopResponse类的, 没有记录下来是我的失误也是我的损失, 现在能找到这个类是因为当时开发Xposed模块中的代码有这一段. 如果某天我突然想起来了或者有兴致花时间重新找的话, 会回来补充的\n 使用Xposed拦截此函数, 并打印入参\nfindAndHookMethod(\u0026quot;mtopsdk.mtop.domain.MtopResponse\u0026quot;, loadPackageParam.classLoader, \u0026quot;setBytedata\u0026quot;, byte[].class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { String content = new String((byte[]) param.args[0]); MyLog.log(content); } }); 得到入参截取如下\n\u0026quot;data\u0026quot;: { \u0026quot;item\u0026quot;: { ... \u0026quot;main\u0026quot;: { \u0026quot;clickParam\u0026quot;: { \u0026quot;arg1\u0026quot;: \u0026quot;Item\u0026quot;, \u0026quot;args\u0026quot;: { ... \u0026quot;tagname\u0026quot;: \u0026quot;全新\\/极好\\/298人想要\u0026quot;, \u0026quot;wantNum\u0026quot;: \u0026quot;298\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;tag\u0026quot;: \u0026quot;new\\/credit-6\\/wantnum-298\u0026quot;, \u0026quot;scm\u0026quot;: \u0026quot;1007.32845.224895.0\u0026quot;, \u0026quot;publishTime\u0026quot;: \u0026quot;1590461455000\u0026quot;, \u0026quot;i2i\u0026quot;: \u0026quot;相似\u0026quot;, \u0026quot;search_tab_from\u0026quot;: null, \u0026quot;item_id\u0026quot;: \u0026quot;619312410203\u0026quot;, \u0026quot;biz_type\u0026quot;: \u0026quot;item\u0026quot;, //破解重点 \u0026quot;q\u0026quot;: \u0026quot;10700k\u0026quot;, ... }, \u0026quot;page\u0026quot;: \u0026quot;Page_xySearchResult\u0026quot; }, ... } } ... } ... 此处截取了一条记录展示, 实际拦截到的参数中是一个数组, 包含本次结果页的所有商品, 其中就包括了搜索的商品, 广告商品, 推荐商品等, 通过对比发现, 搜索的商品数据在节点args \u0026gt; biz_type 的取值为 item, 而广告等商品取值为ad, Bagtag, 聚合卡片, 那么接下来要做的事就很明确了, 解析这个字符串, 如果发现是广告商品则从数据中删除这条数据, 修改对setBytedate的拦截代码如下\n... protected void beforeHookedMethod(MethodHookParam param) throws Throwable { if (null == param.args[0] || ((byte[]) param.args[0]).length == 0) { return; } String content = new String((byte[]) param.args[0]); JSONObject jsonContent = new JSONObject(content); JSONObject jsonData = jsonContent.optJSONObject(\u0026quot;data\u0026quot;); if (null == jsonData || !jsonData.has(\u0026quot;resultList\u0026quot;)) { return; } JSONArray resultList = jsonData.getJSONArray(\u0026quot;resultList\u0026quot;); List\u0026lt;String\u0026gt; filterList = Arrays.asList(\u0026quot;ad\u0026quot;, \u0026quot;Bagtag\u0026quot;, \u0026quot;聚合卡片\u0026quot;); for (int i = 0; i \u0026lt; resultList.length(); i++) { JSONObject listItem = resultList.getJSONObject(i); String bizType = listItem.getJSONObject(\u0026quot;data\u0026quot;).getJSONObject(\u0026quot;item\u0026quot;) .getJSONObject(\u0026quot;main\u0026quot;).getJSONObject(\u0026quot;clickParam\u0026quot;).getJSONObject(\u0026quot;args\u0026quot;) .getString(\u0026quot;biz_type\u0026quot;); if (filterList.contains(bizType)) { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.KITKAT) { resultList.remove(i); i--; } } } param.args[0] = jsonContent.toString().getBytes(); } ... 上述代码首先将byte数组转换为json对象, 然后遍历所有商品, 将找到的广告商品移除, 再将处理过后的字符串重新转换为byte数组, 最后赋值给原始参数, 这样当某鱼实际代码setBytedata得到的参数将会是我修改后的参数. 编译验证后可以看到广告已经不会再显示了\n 哇塞 \n禁用恼人的升级弹窗 由于本人不爱更新, 且破解后如果更新版本, 可能导致破解失效, 所以必须禁用更新\n首先根据弹窗文字搜索代码\n 更新弹窗 \n发现仅有一处, 位于BaseUpgradeHandler类的onUpgradeNeed()方法\n 更新代码 \n跟踪方法调用, 在com.马赛克.马赛克fish.upgrade.traceable.Upgrade类的c方法中被调用, 而c则被b调用\n 更新1 \n 更新2 \n重点代码摘要如下:\nprivate void c(final UpgradeHandler handler) { if (handler != null) { ... handler.onUpgradeNeed(info, tracer); ... } } c中的代码的突破点在于, 如果传入的handler不为null, 才会执行更新检测并弹窗的方法, 那么我只需要让传入的handler为null就可以了. 在Xposed模块中拦截Upgrade类的b方法, 将入参设置为null\nfindAndHookMethod(\u0026quot;com.马赛克.马赛克fish.upgrade.traceable.Upgrade\u0026quot;,loadPackageParam.classLoader, \u0026quot;b\u0026quot;, \u0026quot;com.马赛克.马赛克fish.upgrade.traceable.UpgradeHandler\u0026quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { //这里将入参设置为null param.args[0] = null; } } ); 重新进行测试, 一切正常且启动之后不再有更新弹窗了\n","date":"2021-06-08T00:50:44+08:00","image":"/posts/hack/xfish/cover_hu6805bb858ef8d6e39da1ca045c198567_262554_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xfish/","title":"某鱼APP破解去广告"},{"content":"背景 本文接另一篇文章 某琴吧Flash播放器破解记录\n由于某琴吧改版正式使用exe播放器之后, 删除了所有的.ypa2资源, 导致我没有及时下载的乐谱都无法继续使用Flash播放器播放了, 忍不了, 只能破解exe播放器了\n目标 破解该站的exe播放器, 使其能够免费播放VIP乐谱, 且可以完全脱机使用\n开始破解 首先安装网站的乐谱播放器, 打开安装目录发现文件结构如下\n image-3 \n其中xxxchrome.exe相当于一个浏览器, 可以访问某琴吧, 点击\u0026quot;客户端播放\u0026quot;按钮即可打开播放器, 如下图\n image-2 \n而xxplayer.exe才是播放器, 播放器启动后, 可以从任务管理器看到新增的进程\n image-1 \n剩下的安装文件和库文件还有配置文件, 就不介绍了.\n首先播放一个免费的乐谱, 在任务管理器中查看一下xxplayer.exe的启动参数\n image-4 \n完整的启动参数如下\n\u0026quot;C:\\Program Files\\马赛克music\\out1\\马赛克player.exe\u0026quot; \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981\u0026quot; 可以看到启动参数主要为\n file 官网的乐谱页地址 ypid 乐谱ID uid 用户ID token 凭证  如果从xxxchrome.exe打开一个VIP乐谱, 则会显示\n image-5 \n那么如果我不用他的xxxchrome.exe, 直接从命令行启动xxplayer.exe, 传入一个VIP乐谱ID, 会发生什么呢?\n将刚才的启动参数中的ypid参数修改为一个VIP乐谱ID, 通过命令行\nxxplayer.exe \u0026quot;file=http://www.马赛克.com/open_yp.php?ypid=33418\u0026amp;uid=999999999\u0026amp;token=4c6930a47090c3f04c7e9db3bf214078\u0026quot; 启动xxplayer.exe之后如下\n image-6 \n非常的正常, 但是至少验证了 xxplayer.exe是可以脱离xxxchrome.exe独立运行的, 那么既然要鉴权, 不请求服务器肯定是不行的吧? 于是打开Charles开始抓包, 首先用命令行打开一个免费的乐谱, 捕获到网络请求如下\n image-7 \n可以看出主要请求接口为/codeindex.php, 通过参数m做不同功能的权限认证\n当m=index, 验证成功返回权限信息\n{ \u0026quot;responseCode\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u6b63\\u5e38\u0026quot;, \u0026quot;power\u0026quot;: { \u0026quot;openPower\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;printPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;printCount\u0026quot;: \u0026quot;30\u0026quot;, \u0026quot;vstPower\u0026quot;: \u0026quot;0\u0026quot;, \u0026quot;pdfPower\u0026quot;: \u0026quot;0\u0026quot; } } 当m=getYpdsUrl, 验证成功返回.ypdx格式的播放文件地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;: \u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypds\u0026quot;, \u0026quot;ypdxUrl\u0026quot;: \u0026quot;http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx\u0026quot; } } } 最后再请求资源地址http:\\/\\/马赛克.马赛克.com\\/yuepuku\\/148\\/74205\\/74205_cfcbahia.ypdx, 得到.ypdx格式的播放文件\n现在再来通过命令行启动一个VIP乐谱,看看请求和响应会是怎样的\n image-8 \n可以看到这次只有一个m=index的请求, 且返回码不同于免费乐谱的1000, 之后播放器弹出没有权限的弹窗, 那么思路就来了\n如果我将篡改请求的响应,播放器应该就会认为我是有权限的,那不就可以播放了吗?\n首先使用Charles进行断点, 针对m=index的请求, 修改播放器请求VIP乐谱的返回值\n iamge-9 \n和我预料的一样, 修改m=index的响应后, 这次发送了m=getYpdsUrl的请求\n但是m=getYpdsUrl仍然对用户权限进行了判断, 因此返回码不是正常的1000, 且result节点没有返回.ypdx播放文件的资源地址, 看样子不是VIP用户是无法获得资源地址了\n但是 在文章 某琴吧Flash播放器破解记录 中, 使用getURL生成的乐谱信息url去请求乐谱服务器得到的返回值里, 是包含.ypa2格式的资源地址的, 只不过现在.ypa2资源已经被删了, 不过观察刚才免费的乐谱.ypdx资源地址后, 会发现这和.ypa2的资源地址高度相似! 于是我将返回的.ypa2资源地址修改后缀名为.ypdx进行请求之后, 顺利得到了.ypdx格式的播放文件!\n//ypa2请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypa2 //ypdx请求地址 http://oss.马赛克.com/yuepuku/115/57806/57806_hhdafigb.ypdx 得到.ypdx文件之后, 开启一个本地HTTP服务器, 开放一个地址用于返回.ypdx文件, 然后用Charles对VIP乐谱请求中m=getYpdsUrl断点, 并修改响应中result里对应的资源地址为本地HTTP服务器地址\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 再次测试, 成功打开VIP乐谱, 并开始播放, 所有功能正常!\n image-10 \n确定伪造响应的方案确定可行之后, 下一步就是要让播放器请求我指定的地址了, 因为刚才是通过Charles修改响应的, 但我不可能每次都使用Charles断点, 我需要反编译xxplayer.exe, 并修改服务请求地址为我监听的地址, 然后由我监听的地址返回所需数据\n使用OllyDbg(以下简称OD)反汇编xxplayer.exe, 在菜单栏依次点击 \u0026ldquo;插件\u0026rdquo; -\u0026gt; \u0026ldquo;中文搜索引擎\u0026rdquo; -\u0026gt; \u0026ldquo;搜索UNICODE\u0026rdquo;, 以Charles捕获到的url中的关键字codeindex搜索, 发现一共有三处\n iamge-11 \n Warning: 此处我没有使用虚拟机打开, 建议各位反汇编的时候用虚拟机, 因为被反汇编的程序如果有反调试的代码, 轻则闪退重则格盘. 另外OD本身是不带\u0026quot;中文搜索引擎\u0026quot;插件的, 需要自行下载安装\n 双击搜索到的第一处字符串, 跳转到引用代码段, 通过字符串格式可以看出, 其中%s是要用参数替换的, 且通过前面的push可以看出, 它自身也是作为参数被传递的, 那么只要跟踪下方离他最近的call之前的变量, 就能确定需要修改哪一行了, 在可疑的push处按F2断点, F8单步调试后, 发现push [local.7]正是请求的域名\n image-12 \n为了修改字符串, 有两种方式\n 如果修改前后字符串长度相同, 可以直接定位到字符串地址进行修改 如果长度不同, 可以在程序空白处, 新增一段字符串, 然后将之前对字符串的地址引用改为新增的字符串地址   程序空白处是指在OD左下角的数据面板, 拉到最下面, 可以看到一堆00 00 00 00 00 00 ..., 00在汇编中就是啥都没有, 啥都不干, 也就是空白的意思\n 这里暂时不知道[local.7]哪儿来的, 所以我选择第二种方式, 查看OD左下角数据面板, 拉到最下面, 找到程序空白处, 双击空白地址, 在弹出的编辑窗口中取消勾选\u0026quot;Keep size\u0026quot;, 在UNICODE栏输入localhost:7777\n image-13 \n image-14 \n Q1: 为什么不在011808E0行的6C 65 57后面的00处添加, 而是在00的后面?\n 因为汇编中字符串是以00结尾, 且每个字符后面都跟一个00, 为了尽量避免覆盖前面的数据块, 这里空开一个00位置, 如果前面数据块明显是字符串,需要空开三个00, 因为结束符00后面也会跟一个00\n   Q2: 为什么取消勾选\u0026quot;Keep size\u0026quot;\n Keep size的作用是保持长度字符串长度一致, 因为如果超过原来的长度会造成不可预知的错误, 但是这里是程序空白处, 后面都是空白行, 所以不需要保持长度, 有多少写多少\n  此时点击新增的字符串头6C可以在底部栏看到新字符串的起始地址为0x11808E4, 回到汇编面板, 双击刚才的push [local.7]所在行, 在弹出的面板中修改为 push 0x11808E4\n 由于修改后的代码较之前的代码更少, 需要勾选\u0026quot;Fill with NOP`s\u0026quot;来保持长度一致\n  image-15 \n可以看到在汇编面板右侧已经自动显示了标记, 提示当前push的值为localhost:7777\n image-16 \n现在选中刚才在数据面板添加的字符串十六进制代码块, 右键点击\u0026quot;复制到可执行文件\u0026quot;, 再选中汇编面板所有修改的行, 右键点击\u0026quot;复制到可执行文件\u0026quot; -\u0026gt; \u0026ldquo;选中行\u0026rdquo;, 在弹出的面板中右键\u0026quot;备份\u0026quot; -\u0026gt; \u0026ldquo;保存数据到文件\u0026quot;即可保存修改后的exe文件\n image-36 \n执行修改后的程序, 发现程序异常退出, 用OD打开修改后的文件, 再次找到刚才修改push的地方, 发现右侧没有显示localhost:7777的标记\n image-17 \n再看看跳转地址0x11808E4, 也不是刚才修改的字符串内容\n image-18 \n虽然不知道为什么, 但是看来push [local.x]形式的代码不能这样简单的修改. 那么换个角度想想[local.7]的值是哪里来的, 这时突然想到播放器启动的时候, 带的参数里是有一个网址的\nfile=http://www.马赛克.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 我将这个网址修改为百度的网址\nfile=http://www.baidu.com/open_yp.php?ypid=73981\u0026amp;uid=999999999\u0026amp;token=fbf0ab24ee47bfa1cb460e41c1f61fdb\u0026amp;ypid=73981 重新运行, 抓包发现它真的去请求百度的/codeindex.php接口了\n image-19 \n于是我再将参数换成localhost:7777, 重新运行, 结果发现程序异常退出, 进行跟踪调试发现[local.7]的实际值被截取了不包含端口号的部分, 为localhost\n image-20 \n尝试跟踪截取部分的代码, 但是太麻烦了决定放弃. 这时候我想到直接将整个url\n%s://%s/codeindex.php?d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s 中第二个%s直接替换成localhost:7777不就可以了? 但是这样就少了一个%s, 参数对不上后面的代码一定会报错, 于是我想到在?后面再加一个参数, 参数名随意, 参数值就用[local.7], 反正对于串来说, %s的数量能够对应参数的数量即可, 而对于HTTP请求来说, 多一个参数也没什么影响. 不过修改后字符串的长度就对不上了, 所以还是在程序空白处添加了一个新的字符串如下\n%s://localhost:7777/codeindex.php?a=%s\u0026amp;d=api\u0026amp;c=check马赛克playerPower\u0026amp;m=%s\u0026amp;ypid=%d\u0026amp;uid=%d\u0026amp;token=%s  image-21 \n其中a就是新增的无用参数, a后面跟的%s将会被[local.7]的值替换, 这样一来无论启动参数中的域名是什么都无所谓了. 记录新字符串的地址为0x11808E4, 找到push原来字符串的汇编代码, 修改push地址为新的字符串地址\n image-22 \n再次保存执行, 程序还是异常退出, 用OD打开修改后的程序发现地址正确, 字符串正确, 但是还是会报错, 于是我怀疑不能用localhost作为域名. 将localhost:7777修改为127.0.0.1:7777, 再次运行, 这次终于在后台收到了来自播放器的HTTP请求!\n image-23 \n所有参数也都正常接收, 接下来只要返回正确的响应就行了, 对于m=index的直接返回\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;0\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;0\u0026quot;}} 对于m=getYpdsUrl 的则返回\n{ \u0026quot;data\u0026quot;: { \u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;, \u0026quot;message\u0026quot;:\u0026quot;\\u83b7\\u53d6\\u6210\\u529f\u0026quot;, \u0026quot;result\u0026quot;: { \u0026quot;ypdsUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypds\u0026quot;,\u0026quot;ypdxUrl\u0026quot;:\u0026quot;http:\\/\\/127.0.0.1:7777\\/yuepu\\/57806_hhdafigb.ypdx\u0026quot; } } } 然后, 用同样的方式修改搜索codeindex结果中的第二处, 再次运行就能正常播放了.\n继续破解 现在虽然播放曲谱没有问题了, 但是现在还有如下几个VIP功能用不了, 要白嫖就白嫖到极致\n image-24 \n从音源开始下手, 点击\u0026quot;音源\u0026rdquo; -\u0026gt; \u0026ldquo;浏览\u0026quot;后, 播放器弹出没有权限的提示\n image-25 \n查看Charles发现期间并没有发出网络请求, 推测应该是在之前的请求里就响应过了, 这时想到最开始m=index的请求中, power节点有很多为0的字段, 仔细一看这不就是对应的权限吗? 推测权限字段对应关系应该是\n openPower 打开的权限 printPower 打印的权限 printCount 可打印的数量 vstPower 使用vst音源的权限 pdfPower 转换pdf的权限  参考正常响应中openPower为1, 其他的为0, 因此把后台响应中所有为0改为1, 再次点击音源, 发现可以正常选择了\n{\u0026quot;responseCode\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;power\u0026quot;:{\u0026quot;openPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;,\u0026quot;vstPower\u0026quot;:\u0026quot;1\u0026quot;,\u0026quot;pdfPower\u0026quot;:\u0026quot;1\u0026quot;}}  image-26 \n接下来看看点击转换PDF功能, 通过Charles发现会发送一个权限请求\n image-27 \n其中接口仍然是/codeindex.php, 但本次m取值为addDynamic, 在OD中发现就是刚才上文codeindex搜索结果中的第三处\n image-28 \n双击搜索结果字符串转到汇编代码,00F63EAE 处的push地址就是将要用来替换成请求域名的参数, 这个地址指向了某琴吧的域名, 所以这里采用同样的办法, 先在程序空白处添加字符串127.0.0.1:7777, 然后修改push原来串的地址修改为新增的字符串地址\n image-29 \n重新保存, 然后在乐谱工具中监听这个地址, 并参考m=index的响应以下结果\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n {\u0026quot;data\u0026quot;:{\u0026quot;code\u0026quot;:\u0026quot;1000\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;\\u6b63\\u5e38\u0026quot;,\u0026quot;result\u0026quot;:{\u0026quot;printCount\u0026quot;:\u0026quot;30\u0026quot;}}} 重新打开运行PDF保存, 发现可以转换并保存了\n image-30 \n打印的功能和PDF的请求地址和参数m是一样的, 只要返回同样的响应就可以了\n至此VIP功能全部破解\n但是尚不完美 最后做脱机测试的时候发现播放器会先检查网络连接状态, 没有网络连接则无法播放\n image-31 \n但是我的目标是播放器能够脱机使用, 而且实际上播放器被我修改后已经不需要再连上互联网, 只需要请求乐谱工具的HTTP服务地址就可以, 因此根据弹窗搜索字符串, 定位到相关代码\n image-32 \n可以看到播放器在00F693E2处调用系统接口得到网络连接状态, 在00F693EC处, 如果有网络连接则会跳转到00F6940A处继续, 没有网络连接则会显示并中断运行, 那我只需要让这个判断失效就可以了, 双击00F693EC打开编辑窗口, 将jnz (不等于0则跳转) 修改为jmp (无条件跳转), 这样运行至此的时候将不会判断网络连接状态, 直接运行后面的代码\n image-34 \n image-35 \n同样的, 在使用转换PDF功能时还会检测网络状态, 然后弹窗提示\u0026quot;没有检测到网络!\u0026rdquo;, 找到代码运行处, 修改00F75DDE处的jnz为jmp即可\n image-33 \n保存后重新运行, 现在脱机情况下播放器能够正常打开并请求乐谱工具的HTTP服务并正常播放乐谱了, 转存PDF文件等VIP功能也能够正常使用\n至此exe版本宣告完美破解 ","date":"2021-05-26T00:50:44+08:00","image":"/posts/hack/xtan/exe/cover_hu9fa22720e1e2994b8f7276f9d33830a9_2622630_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/exe/","title":"某琴吧EXE播放器破解记录"},{"content":"背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.\n同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.\n目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用\n网站乐谱页  image-1 \n开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下\n 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图\n 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?\n首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3.6a 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 flash_player_debugger, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:\n image-2 \n其中Main为主类, init1 为初始化函数, 这里可以得到入参, 参数传入形式为\nplayer.swf?id=1 而配置类Config定义了服务端接口地址:\n image-3 \n但是很遗憾在player.swf中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时Sounds.swf就很可疑了, 通过阅读player.swf的代码发现Sounds.swf是点击播放按钮之后, 作为一个函数库被加载进来的, 这里load的地址就是Config里定义了Sounds.swf资源地址\n image-4 \n请求响应之后通过回调函数onSwComplete将其载入并储存到Clib类的成员变量clib中\n image-5 \n然后就可以通过utils.Clib.clib.xxx的方式调用函数, 再深入跟踪代码, 发现Clib中的getURL非常可疑\n image-6 \n找到他被调用的地方, 加一行日志跟踪一下输出\n image-7 \n调试运行之后输出的字符串为:\n image-14 \n这个地址跟第四步的请求地址就是同一个地址! 这就是我要找的东西, 现在只需要反编译Sounds.swf, 把getURL的算法抄下来就可以了! 想法很美好, 但现实很骨感, Sounds.swf反编译后发现经过了加密混淆, 反编译出来的代码是这样的\n image-8 \n这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹\n image-9 \n这url不就是刚才输出的地址吗, 显然此处的代码是将url中的%s, %d替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个Sounds.swf是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用getURL这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询ActionScript资料, 发现可以通过ExternalInterface, 让.swf将接口暴露出来提供外部Flash容器调用, 对于player.swf来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用WinForm的Shockwave Flash组件.\n于是修改player.swf的源码, 在Main中定义一段可供外部调用的函数\n image-10 \n其中函数名为swfExtGetypURL, 入参为string类型的乐谱ID, 函数首先检查clib是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用Clib的getURL返回乐谱信息url.\n上文提到clib是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化clib的函数onSwComplete, 仿照其代码, 在Clib中写一段初始化代码如下:\npublic static function myLoadSwf() : void { swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady); swfLoader.load(new URLRequest(Config.flash_sound_lib_URL)); } internal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); } 并将原来的初始化代码loadSwf修改为:\n//修改前 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); swfLoadCompleteCallBack(); return; } //修改后 public static function loadSwf(arg1:Function):void { swfLoadCompleteCallBack = arg1; if(null == CLib.clib) { swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress); swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError); swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete); ui.HUD.show(\u0026quot;加载音色库\u0026quot;, 0); swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL)); } else { swfLoadCompleteCallBack(); } return; } 最后在Mian类的初始化函数init1中调用myLoadSwf\n image-12 \n大功告成, 现在 player.swf 在启动的时候就会调用我添加的 myLoadSwf 函数, 开始加载 Sounds.swf 并初始化到 Clib 中. 而原来的loadSwf会先判断Sounds.swf有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过Shockwave Flash组件调用player.swf暴露出来的外部接口就可以了, 调用方式如下:\naxShockwaveFlash.CallFunction( string.Format(\u0026quot;\u0026lt;invoke name=\\\u0026quot;swfExtGetypURL\\\u0026quot; returntype=\\\u0026quot;xml\\\u0026quot;\u0026gt;\u0026lt;arguments\u0026gt;\u0026lt;string\u0026gt;{0}\u0026lt;/string\u0026gt;\u0026lt;/arguments\u0026gt;\u0026lt;/invoke\u0026gt;\u0026quot;, ypid));  axShockwaveFlash 是我在c#代码中定义的Flash容器组件成员变量, 它加载了player.swf作为内容, 代码中调用到的扩展函数名称为swfExtGetypURL, 也就是刚才在player.swf的Main中定义的ExternalInterface类型的函数, 参数为string类型的乐谱ID\n 得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:\n\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;yp_create_time=\u0026lt;yp_create_time\u0026gt;1601587012\u0026lt;/yp_create_time\u0026gt; \u0026lt;br/\u0026gt; yp_title=\u0026lt;yp_title\u0026gt;Summer（菊次郎的夏天）\u0026lt;/yp_title\u0026gt; \u0026lt;br/\u0026gt; yp_page_count=\u0026lt;yp_page_count\u0026gt;5\u0026lt;/yp_page_count\u0026gt; \u0026lt;br/\u0026gt; yp_page_width=\u0026lt;yp_page_width\u0026gt;1051\u0026lt;/yp_page_width\u0026gt; \u0026lt;br/\u0026gt; yp_page_height=\u0026lt;yp_page_height\u0026gt;1487\u0026lt;/yp_page_height\u0026gt; \u0026lt;br/\u0026gt; yp_is_dadiao=\u0026lt;yp_is_dadiao\u0026gt;1\u0026lt;/yp_is_dadiao\u0026gt; \u0026lt;br/\u0026gt; yp_key_note=\u0026lt;yp_key_note\u0026gt;2\u0026lt;/yp_key_note\u0026gt; \u0026lt;br/\u0026gt; yp_is_yanyin=\u0026lt;yp_is_yanyin\u0026gt;0\u0026lt;/yp_is_yanyin\u0026gt; \u0026lt;br/\u0026gt; ypad_url=\u0026lt;ypad_url\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad\u0026lt;/ypad_url\u0026gt;ypad_url2=\u0026lt;ypad_url2\u0026gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2\u0026lt;/ypad_url2\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; 接下来, 只需要解析响应并下载资源就可以了\n 解析 yp_page_count 节点可以得到乐谱的总页数 解析ypad_url节点, 并在节点中url的最后拼接.乐谱页数.png, 即可得到真实的乐谱图片地址 解析ypad_url节点, 截取 _ 的前半部分, 再拼接 _prev.jpg还可以得到乐谱的封面图 解析ypad_url2节点即可获取真实的.ypa2格式的播放文件   由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式\n 以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对player.swf和Sounds.swf做一些修改, 首先修改player.swf的Config类, 把其中关键的加载Sounds.swf和获取封面的地址修改为localhost:7777\n//获取曲谱封面的地址 public static const flash_prev_yp_info_URL:String = \u0026quot;http://localhost:7777/yuepu/preview\u0026quot;; //获取Sounds.swf的地址 public static const flash_sound_lib_URL:String = \u0026quot;http://localhost:7777/yuepu/flash/sound\u0026quot;; 然后修改Sounds.swf在上文查找到的生成url串, 把串的前缀修改为localhost:7777\ngstaticInitter.asciz = \u0026quot;http://localhost:7777/yuepu/info?ypid=%d\u0026amp;sccode=%s\u0026amp;r1=%d\u0026amp;r2=%d\u0026amp;input=%s\u0026quot;;  此处Sounds.swf修改url后, 调用getURL返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求\n 最后在乐谱工具中开启一个端口为7777的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了\n 乐谱工具是我基于C#开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自localhost:7777的HTTP请求\n  image-13 \n Adobe Flash彻底停用后的补偿方案 过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具WinForm的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, 直接导致Shockwave Flash也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.\n既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的flash_player_debugger, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的.swf文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令\nflashplayer_sa_debug.exe player.swf?id=1 即可启动 flash_player_debugger 并打开作为参数的 .swf 文件, 在C#中则可以使用Process启动, 代码如下:\nProcess.Start(\u0026quot;flashplayer_sa_debug.exe\u0026quot;, \u0026quot;Main.swf?id=1\u0026quot;); 但是在实际使用中, 发现通过命令行或者程序启动的 flash_player_debugger 打开的player.swf无法发送localhost的网络请求, 弹窗报错如下:\nSecurityError: Error #2119: 安全沙箱冲突 但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求localhost是因为他在用户文件夹下\\AppData\\Roaming\\Macromediax\\Flash Player\\#Security\\FlashPlayerTrust创建了信任文件intellij_idea.cfg, 文件内容即IDEA生成.swf的完整文件夹路径\nE:\\flash\\bin-debug 所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求localhost了\n现在解决了乐谱无法播放的问题, 但是由于flash_player_debugger不支持ExternalInterface, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用getURL获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.\n首先删除会引起报错的player.swf中使用ExternalInterface定义的接口swfExtGetypURL, 修改 myLoadSwf中定义的回调函数 onSoundsReady, 在此前初始化clib的基础上加上调用getURL返回的url, 并提取参数请求localhost:7777, 修改后的代码如下:\ninternal static function onSoundsReady(arg1:Event) : void { swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady); var loc1:* = swfLoader.contentLoaderInfo.applicationDomain; var loc2:* = loc1.getDefinition(\u0026quot;Sounds\u0026quot;) as Class; CLib.clib = loc2.cLibInit(); //添加的部分 if(utils.Func.ypadId != 0) { var url:* = CLib.getURL(utils.Func.ypadId); var args:* = \u0026quot;?\u0026quot; + url.split(\u0026quot;?\u0026quot;)[1] urlLoader3 = new flash.net.URLLoader(); urlLoader3.load(new flash.net.URLRequest(\u0026quot;http://localhost:7777/yuepu/fetch\u0026quot; + args)); } }  utils.Func.ypadId中存储了播放器启动时传入的乐谱ID参数\n 此时当clib初始化完成之后, 会使用传入的乐谱ID直接调用getURL, 截取返回url的参数部分, 再将参数通过HTTP请求上报到localhost:7777. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题\n//监听曲谱地址 if (httpListenerContext.Request.Url.LocalPath.Equals(\u0026quot;/yuepu/fetch\u0026quot;)) { httpListenerContext.Request.QueryString[\u0026quot;ypid\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;sccode\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r1\u0026quot;]; httpListenerContext.Request.QueryString[\u0026quot;r2\u0026quot;]; ... } 不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用Process启动的指定WindowStyle为ProcessWindowStyle.Hidden就可以无感使用了\nProcess.Start(new ProcessStartInfo() { FileName = \u0026quot;flashplayer_sa_debug.exe\u0026quot;, WindowStyle = ProcessWindowStyle.Hidden,//关键代码 Arguments = \u0026quot;Main.swf?id=64\u0026quot;, }) 至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的.ypa2格式播放器文件, 且删除了所有.ypa2资源, 并采用新的.ypdx文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了\u0026hellip; ","date":"2021-05-25T00:50:44+08:00","image":"/posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_120x120_fill_box_smart1_2.png","permalink":"/posts/hack/xtan/flash/","title":"某琴吧Flash播放器破解记录"}]