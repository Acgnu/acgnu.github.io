<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.
同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.
目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用
网站乐谱页  image-1 
开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下
 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图
 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?
首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3."><title>某琴吧Flash播放器破解记录</title><link rel=canonical href=https://example.com/posts/hack/xtan/flash/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="某琴吧Flash播放器破解记录"><meta property="og:description" content="背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.
同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.
目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用
网站乐谱页  image-1 
开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下
 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图
 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?
首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3."><meta property="og:url" content="https://example.com/posts/hack/xtan/flash/"><meta property="og:site_name" content="Acgnu+"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Hack"><meta property="article:tag" content="Flash"><meta property="article:tag" content="Flex"><meta property="article:tag" content="ActionScript"><meta property="article:tag" content=".NET"><meta property="article:published_time" content="2021-05-25T00:50:44+08:00"><meta property="article:modified_time" content="2021-05-25T00:50:44+08:00"><meta property="og:image" content="https://example.com/posts/hack/xtan/flash/cover.png"><meta name=twitter:title content="某琴吧Flash播放器破解记录"><meta name=twitter:description content="背景 2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.
同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.
目标 破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用
网站乐谱页  image-1 
开始破解 首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下
 进入乐谱页面, 网站向服务端请求 player.swf, 该 .swf 文件即为乐谱播放器 浏览器加载 player.swf , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中 点击播放按钮时, 播放器请求 Sounds.swf, 播放器请求接口 /flash_get_yp_info.php 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址 播放器下载并载入余下的 .png 格式乐谱图片, 并加载 .ypa2 格式的播放文件, 即可开始播放   由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图
 基本过程已经明确了, 而所有的请求接口中, 只有第四步的/flash_get_yp_info.php是需要对入参sccode, r1, r2, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?
首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 jpexs-decompiler, 顺利反编译出player.swf代码, 用IDEA新建为Flex项目打开, 再百度其中的一些package名称, 发现代码可基于 flex_sdk_3."><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://example.com/posts/hack/xtan/flash/cover.png"><link rel="shortcut icon" href=/favicon.ico></head><body class="article-page keep-sidebar"><script>(function(){const colorSchemeKey='StackColorScheme';if(!localStorage.getItem(colorSchemeKey)){localStorage.setItem(colorSchemeKey,"auto");}})();</script><script>(function(){const colorSchemeKey='StackColorScheme';const colorSchemeItem=localStorage.getItem(colorSchemeKey);const supportDarkMode=window.matchMedia('(prefers-color-scheme: dark)').matches===true;if(colorSchemeItem=='dark'||colorSchemeItem==='auto'&&supportDarkMode){document.body.dataset.scheme='dark';}else{document.body.dataset.scheme='light';}})();</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hu3a9833e4ebdcf9e444b7caf140fa72b8_113624_300x0_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>😎</span></figure><h1 class=site-name><a href=https://example.com>Acgnu+</a></h1><h2 class=site-description>時間はいつも足りない</h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/posts/hack/xtan/flash/><img src=/posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_800x0_resize_box_2.png srcset="/posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_800x0_resize_box_2.png 800w, /posts/hack/xtan/flash/cover_huc983e047102b89c4f0ca87837c4b488b_1556764_1600x0_resize_box_2.png 1600w" width=800 height=476 loading=lazy alt="Featured image of post 某琴吧Flash播放器破解记录"></a></div><div class=article-details><header class=article-category><a href=/categories/hack/>Hack</a></header><h2 class=article-title><a href=/posts/hack/xtan/flash/>某琴吧Flash播放器破解记录</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>May 25, 2021</time></footer></div></header><section class=article-content><h2 id=背景>背景</h2><p>2019年的某月, 某琴吧将越来越多的谱子改为vip收费谱, 遂于网上寻找Chrome插件实现白嫖.</p><p>同年, 得知Adobe公司将于2020年年末彻底停用Flash, 遂产生破解其Flash播放器并本地化的想法.</p><h2 id=目标>目标</h2><p>破解该站的Flash播放器, 使其能够免费下载并播放VIP乐谱, 并将乐谱保存至本地硬盘, 同时使播放器可以脱离浏览器且可以脱机使用</p><h2 id=网站乐谱页>网站乐谱页</h2><p><figure style=flex-grow:105;flex-basis:252px><a href=/posts/hack/xtan/flash/1.jpg data-size=829x789><img src=/posts/hack/xtan/flash/1.jpg srcset="/posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/1_hu7d519fa7cc6e6f603ce1301045ffe678_62992_1024x0_resize_q75_box.jpg 1024w" width=829 height=789 loading=lazy alt=image-1></a><figcaption>image-1</figcaption></figure></p><h2 id=开始破解>开始破解</h2><p><strong>首先通过Chrome的调试控制台Network面板, 跟踪进入乐谱页的网络请求如下</strong></p><ol><li>进入乐谱页面, 网站向服务端请求 <code>player.swf</code>, 该 <code>.swf</code> 文件即为乐谱播放器</li><li>浏览器加载 <code>player.swf</code> , 播放器向服务端请求乐谱的第一页作为预览图, 显示在播放器中</li><li>点击播放按钮时, 播放器请求 <code>Sounds.swf</code>,</li><li>播放器请求接口 <code>/flash_get_yp_info.php</code> 获取乐谱详细信息, 包括谱名称, 页数, 作者, 余下的乐谱页资源地址, 播放文件地址</li><li>播放器下载并载入余下的 <code>.png</code> 格式乐谱图片, 并加载 <code>.ypa2</code> 格式的播放文件, 即可开始播放</li></ol><blockquote><p>由于文章编辑于2021年5月, 该网站已经改版移除了Flash版本播放器, 因此当时调用的服务器接口没有被记录下来, 文章没有该部分请求的截图</p></blockquote><p><strong>基本过程已经明确了, 而所有的请求接口中, 只有第四步的<code>/flash_get_yp_info.php</code>是需要对入参<code>sccode</code>, <code>r1</code>, <code>r2</code>, 进行校验, 那我只需要反编译出播放器的源码, 再根据代码仿写一个凭证生成的算法, 不就可以调用接口并得到资源地址了?</strong></p><p>首先要实现下载乐谱图片以及播放文件, 多番对比后选用开源且免费的 <a class=link href=https://github.com/wholesky/ffdec target=_blank rel=noopener>jpexs-decompiler</a>, 顺利反编译出<code>player.swf</code>代码, 用IDEA新建为<code>Flex</code>项目打开, 再百度其中的一些<code>package</code>名称, 发现代码可基于 <code>flex_sdk_3.6a</code> 的SDK运行, 再从Adobe官网下载官方的Flash调试工具 <a class=link href=https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe target=_blank rel=noopener>flash_player_debugger</a>, 配合IDEA编译后可直接运行调试, 反编译出来的代码如下:</p><p><figure style=flex-grow:120;flex-basis:288px><a href=/posts/hack/xtan/flash/2.jpg data-size=965x803><img src=/posts/hack/xtan/flash/2.jpg srcset="/posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/2_hu9a1d963a635d7c3fe6b355f33f6e6f72_118163_1024x0_resize_q75_box.jpg 1024w" width=965 height=803 loading=lazy alt=image-2></a><figcaption>image-2</figcaption></figure></p><p>其中<code>Main</code>为主类, <code>init1</code> 为初始化函数, 这里可以得到入参, 参数传入形式为</p><pre><code>player.swf?id=1
</code></pre><p>而配置类<code>Config</code>定义了服务端接口地址:</p><p><figure style=flex-grow:167;flex-basis:402px><a href=/posts/hack/xtan/flash/3.png data-size=825x492><img src=/posts/hack/xtan/flash/3.png srcset="/posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_480x0_resize_box_2.png 480w, /posts/hack/xtan/flash/3_hub3691062b2e8682742c3a0f382173200_262924_1024x0_resize_box_2.png 1024w" width=825 height=492 loading=lazy alt=image-3></a><figcaption>image-3</figcaption></figure></p><p>但是很遗憾在<code>player.swf</code>中的代码没有发现第四步获取乐谱信息的接口地址, 那么只能找其他突破口, 这时<code>Sounds.swf</code>就很可疑了, 通过阅读<code>player.swf</code>的代码发现<code>Sounds.swf</code>是点击播放按钮之后, 作为一个函数库被加载进来的, 这里<code>load</code>的地址就是<code>Config</code>里定义了<code>Sounds.swf</code>资源地址</p><p><figure style=flex-grow:699;flex-basis:1677px><a href=/posts/hack/xtan/flash/4.jpg data-size=734x105><img src=/posts/hack/xtan/flash/4.jpg srcset="/posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/4_hucd33810a9373f5b4f2b4d4125da2b238_18828_1024x0_resize_q75_box.jpg 1024w" width=734 height=105 loading=lazy alt=image-4></a><figcaption>image-4</figcaption></figure></p><p>请求响应之后通过回调函数<code>onSwComplete</code>将其载入并储存到<code>Clib</code>类的成员变量<code>clib</code>中</p><p><figure style=flex-grow:318;flex-basis:764px><a href=/posts/hack/xtan/flash/5.jpg data-size=771x242><img src=/posts/hack/xtan/flash/5.jpg srcset="/posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/5_hu7dd1148387811415828b0c5367c0c670_28650_1024x0_resize_q75_box.jpg 1024w" width=771 height=242 loading=lazy alt=image-5></a><figcaption>image-5</figcaption></figure></p><p>然后就可以通过<code>utils.Clib.clib.xxx</code>的方式调用函数, 再深入跟踪代码, 发现<code>Clib</code>中的<code>getURL</code>非常可疑</p><p><figure style=flex-grow:379;flex-basis:910px><a href=/posts/hack/xtan/flash/6.jpg data-size=353x93><img src=/posts/hack/xtan/flash/6.jpg srcset="/posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/6_hue5a4a1589d6a6a188c0c5873cbc35fd2_5299_1024x0_resize_q75_box.jpg 1024w" width=353 height=93 loading=lazy alt=image-6></a><figcaption>image-6</figcaption></figure></p><p>找到他被调用的地方, 加一行日志跟踪一下输出</p><p><figure style=flex-grow:555;flex-basis:1333px><a href=/posts/hack/xtan/flash/7.jpg data-size=400x72><img src=/posts/hack/xtan/flash/7.jpg srcset="/posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/7_hu8629b41a250b233303861c7394ae8dd6_6344_1024x0_resize_q75_box.jpg 1024w" width=400 height=72 loading=lazy alt=image-7></a><figcaption>image-7</figcaption></figure></p><p>调试运行之后输出的字符串为:</p><p><figure style=flex-grow:469;flex-basis:1127px><a href=/posts/hack/xtan/flash/14.jpg data-size=902x192><img src=/posts/hack/xtan/flash/14.jpg srcset="/posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/14_hu3210bbc216cfc300e53c7acd4064fc13_28157_1024x0_resize_q75_box.jpg 1024w" width=902 height=192 loading=lazy alt=image-14></a><figcaption>image-14</figcaption></figure></p><p><strong>这个地址跟第四步的请求地址就是同一个地址!</strong> 这就是我要找的东西, 现在只需要反编译<code>Sounds.swf</code>, 把<code>getURL</code>的算法抄下来就可以了! 想法很美好, 但现实很骨感, <code>Sounds.swf</code>反编译后发现经过了加密混淆, 反编译出来的代码是这样的</p><p><figure style=flex-grow:116;flex-basis:280px><a href=/posts/hack/xtan/flash/8.jpg data-size=821x702><img src=/posts/hack/xtan/flash/8.jpg srcset="/posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/8_hu43be67c00b60669f820dce2f971712aa_63579_1024x0_resize_q75_box.jpg 1024w" width=821 height=702 loading=lazy alt=image-8></a><figcaption>image-8</figcaption></figure></p><p>这代码别说放进去编译了, 甚至难以阅读, 但是在我坚持不懈的寻找下, 还是发现了一丝蛛丝马迹</p><p><figure style=flex-grow:327;flex-basis:786px><a href=/posts/hack/xtan/flash/9.jpg data-size=678x207><img src=/posts/hack/xtan/flash/9.jpg srcset="/posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/9_hu182ee99ffd16f1fcbe68bcb75ca899e7_23076_1024x0_resize_q75_box.jpg 1024w" width=678 height=207 loading=lazy alt=image-9></a><figcaption>image-9</figcaption></figure></p><p>这url不就是刚才输出的地址吗, 显然此处的代码是将url中的<code>%s</code>, <code>%d</code>替换成对应的参数, 但参数值到底是怎么来的, 仍然无法查明, 于是我决定换个思路, 虽然我无法知道生成参数的具体算法, 但是别忘了这个<code>Sounds.swf</code>是一个函数库, 那我是不是可以写一个外部代码, 通过外部去调用<code>getURL</code>这个函数, 直接返回整个url? 这样所达到的最终目的仍然是一样的, 于是开始查询<code>ActionScript</code>资料, 发现可以通过<code>ExternalInterface</code>, 让<code>.swf</code>将接口暴露出来提供外部Flash容器调用, 对于<code>player.swf</code>来说, 容器就是浏览器, 而我不通过浏览器的话, 则可以使用<code>WinForm</code>的<code>Shockwave Flash</code>组件.</p><p>于是修改<code>player.swf</code>的源码, 在<code>Main</code>中定义一段可供外部调用的函数</p><p><figure style=flex-grow:210;flex-basis:505px><a href=/posts/hack/xtan/flash/10.jpg data-size=825x392><img src=/posts/hack/xtan/flash/10.jpg srcset="/posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/10_hu36f4b6c22103002f7c5a2ad98378fba6_27639_1024x0_resize_q75_box.jpg 1024w" width=825 height=392 loading=lazy alt=image-10></a><figcaption>image-10</figcaption></figure></p><p>其中函数名为<code>swfExtGetypURL</code>, 入参为<code>string</code>类型的乐谱ID, 函数首先检查<code>clib</code>是否已经初始化完成, 没有初始化则提示错误, 初始化之后则调用<code>Clib</code>的<code>getURL</code>返回乐谱信息url.</p><p>上文提到<code>clib</code>是在播放器点击播放按钮之后才开始加载的, 那我总不能每次调用前都先点一下播放按钮吧, 于是找到上文提到的初始化<code>clib</code>的函数<code>onSwComplete</code>, 仿照其代码, 在<code>Clib</code>中写一段初始化代码如下:</p><pre><code>public static function myLoadSwf() : void
{
    swfLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,onSoundsReady);
    swfLoader.load(new URLRequest(Config.flash_sound_lib_URL));
}

internal static function onSoundsReady(arg1:Event) : void
{
    swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
    var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
    var loc2:* = loc1.getDefinition(&quot;Sounds&quot;) as Class;
    CLib.clib = loc2.cLibInit();
}
</code></pre><p>并将原来的初始化代码<code>loadSwf</code>修改为:</p><pre><code>//修改前
public static function loadSwf(arg1:Function):void
{
    swfLoadCompleteCallBack = arg1;
    swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
    swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
    swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
    ui.HUD.show(&quot;加载音色库&quot;, 0);
    swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
    swfLoadCompleteCallBack();
    return;
}

//修改后
public static function loadSwf(arg1:Function):void
{
    swfLoadCompleteCallBack = arg1;
    if(null == CLib.clib)
    {
        swfLoader.contentLoaderInfo.addEventListener(flash.events.ProgressEvent.PROGRESS, onSwfProgress);
        swfLoader.contentLoaderInfo.addEventListener(flash.events.IOErrorEvent.IO_ERROR, onSwError);
        swfLoader.contentLoaderInfo.addEventListener(flash.events.Event.COMPLETE, onSwComplete);
        ui.HUD.show(&quot;加载音色库&quot;, 0);
        swfLoader.load(new flash.net.URLRequest(Config.flash_sound_lib_URL));
    } else {
        swfLoadCompleteCallBack();
    }
    return;
}
</code></pre><p>最后在<code>Mian</code>类的初始化函数<code>init1</code>中调用<code>myLoadSwf</code></p><p><figure style=flex-grow:190;flex-basis:456px><a href=/posts/hack/xtan/flash/12.jpg data-size=574x302><img src=/posts/hack/xtan/flash/12.jpg srcset="/posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/12_hufd0f78f234cc4632a6b5bd4b8255d81a_26583_1024x0_resize_q75_box.jpg 1024w" width=574 height=302 loading=lazy alt=image-12></a><figcaption>image-12</figcaption></figure></p><p>大功告成, 现在 <code>player.swf</code> 在启动的时候就会调用我添加的 <code>myLoadSwf</code> 函数, 开始加载 <code>Sounds.swf</code> 并初始化到 <code>Clib</code> 中. 而原来的<code>loadSwf</code>会先判断<code>Sounds.swf</code>有没有初始化, 初始化了就跳过初始化步骤, 然后我再通过<code>Shockwave Flash</code>组件调用<code>player.swf</code>暴露出来的外部接口就可以了, 调用方式如下:</p><pre><code>axShockwaveFlash.CallFunction(
                string.Format(&quot;&lt;invoke name=\&quot;swfExtGetypURL\&quot; returntype=\&quot;xml\&quot;&gt;&lt;arguments&gt;&lt;string&gt;{0}&lt;/string&gt;&lt;/arguments&gt;&lt;/invoke&gt;&quot;, ypid));
</code></pre><blockquote><p><code>axShockwaveFlash</code> 是我在c#代码中定义的Flash容器组件成员变量, 它加载了<code>player.swf</code>作为内容, 代码中调用到的扩展函数名称为<code>swfExtGetypURL</code>, 也就是刚才在<code>player.swf</code>的<code>Main</code>中定义的<code>ExternalInterface</code>类型的函数, 参数为<code>string</code>类型的乐谱ID</p></blockquote><p>得到返回的url之后, 使用url发起HTTP请求, 得到的响应如下:</p><pre><code>&lt;html&gt;&lt;body&gt;yp_create_time=&lt;yp_create_time&gt;1601587012&lt;/yp_create_time&gt;  &lt;br/&gt;
yp_title=&lt;yp_title&gt;Summer（菊次郎的夏天）&lt;/yp_title&gt;  &lt;br/&gt;
yp_page_count=&lt;yp_page_count&gt;5&lt;/yp_page_count&gt;  &lt;br/&gt;
yp_page_width=&lt;yp_page_width&gt;1051&lt;/yp_page_width&gt;  &lt;br/&gt;
yp_page_height=&lt;yp_page_height&gt;1487&lt;/yp_page_height&gt;  &lt;br/&gt;
yp_is_dadiao=&lt;yp_is_dadiao&gt;1&lt;/yp_is_dadiao&gt;  &lt;br/&gt;
yp_key_note=&lt;yp_key_note&gt;2&lt;/yp_key_note&gt;  &lt;br/&gt;
yp_is_yanyin=&lt;yp_is_yanyin&gt;0&lt;/yp_is_yanyin&gt;  &lt;br/&gt;
ypad_url=&lt;ypad_url&gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypad&lt;/ypad_url&gt;ypad_url2=&lt;ypad_url2&gt;http://www.手动马赛克.com//yuepuku/0/64/64_bidea.ypa2&lt;/ypad_url2&gt;&lt;/body&gt;&lt;/html&gt;
</code></pre><p><strong>接下来, 只需要解析响应并下载资源就可以了</strong></p><ul><li>解析 <code>yp_page_count</code> 节点可以得到乐谱的总页数</li><li>解析<code>ypad_url</code>节点, 并在节点中url的最后拼接<code>.乐谱页数.png</code>, 即可得到真实的乐谱图片地址</li><li>解析<code>ypad_url</code>节点, 截取 <code>_</code> 的前半部分, 再拼接 <code>_prev.jpg</code>还可以得到乐谱的封面图</li><li>解析<code>ypad_url2</code>节点即可获取真实的<code>.ypa2</code>格式的播放文件</li></ul><blockquote><p>由于通过对浏览器Network的跟踪, 可以发现请求的资源地址和响应的乐谱信息资源地址高度相似, 由此可以推论出解析方式以及拼接方式</p></blockquote><p>以上即完成了白嫖VIP乐谱的方式, 但播放器仍然会请求官方服务器地址, 达不到脱机使用的目的, 因此, 还需要对<code>player.swf</code>和<code>Sounds.swf</code>做一些修改, 首先修改<code>player.swf</code>的<code>Config</code>类, 把其中关键的加载<code>Sounds.swf</code>和获取封面的地址修改为<code>localhost:7777</code></p><pre><code>//获取曲谱封面的地址
public static const flash_prev_yp_info_URL:String = &quot;http://localhost:7777/yuepu/preview&quot;;

//获取Sounds.swf的地址
public static const flash_sound_lib_URL:String = &quot;http://localhost:7777/yuepu/flash/sound&quot;;
</code></pre><p>然后修改<code>Sounds.swf</code>在上文查找到的生成url串, 把串的前缀修改为<code>localhost:7777</code></p><pre><code>gstaticInitter.asciz = &quot;http://localhost:7777/yuepu/info?ypid=%d&amp;sccode=%s&amp;r1=%d&amp;r2=%d&amp;input=%s&quot;;
</code></pre><blockquote><p>此处<code>Sounds.swf</code>修改url后, 调用<code>getURL</code>返回的url已经不再是某琴吧域名了, 需要将返回的localhost域名修改回为某琴吧域名之后再请求</p></blockquote><p>最后在乐谱工具中开启一个端口为<code>7777</code>的HTTP的服务, 监听播放器请求的地址, 返回之前下载过来的的对应资源就行了</p><blockquote><p>乐谱工具是我基于<code>C#</code>开发的一款桌面应用, 其中包括乐谱管理功能, 可以管理所有下载的乐谱并调用Flash播放器播放, 同时开启了一个HTTP监听服务, 监听所有来自<code>localhost:7777</code>的HTTP请求</p></blockquote><p><figure style=flex-grow:101;flex-basis:243px><a href=/posts/hack/xtan/flash/13.jpg data-size=602x593><img src=/posts/hack/xtan/flash/13.jpg srcset="/posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_480x0_resize_q75_box.jpg 480w, /posts/hack/xtan/flash/13_hu2908833c875ad89b3b6b9b88cf245112_47260_1024x0_resize_q75_box.jpg 1024w" width=602 height=593 loading=lazy alt=image-13></a><figcaption>image-13</figcaption></figure></p><hr><h2 id=adobe-flash彻底停用后的补偿方案>Adobe Flash彻底停用后的补偿方案</h2><p>过以上修改之后, 就可以脱离浏览器, 嵌入到乐谱工具<code>WinForm</code>的Windows窗口中运行, 原以为可以高枕无忧了, 直到2020年底Adobe正式停用Flash, 受此影响, 浏览器都移除了对Flash的支持, 这是意料之中的事, 但是万万没想到安装版的Flash也受到了影响, <strong>直接导致<code>Shockwave Flash</code>也无法加载Flash内容, 所以乐谱工具也无法打开播放器了.</strong></p><p>既然Flash已经被放弃, 那么继续使用其他低版本安装版的Flash就不考虑了, 本身Flash被代理添加了大量广告令人发指. 因此转念考虑上文的<a class=link href=https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe target=_blank rel=noopener>flash_player_debugger</a>, 这个是不需要安装的, 那么我是不是可以通过命令行的形式启动它, 并将需要播放的<code>.swf</code>文件作为参数传递给它? 由于没有查阅到相关文档, 只能按照习惯进行尝试了, 发现确实可行, 在命令行窗口输入以下命令</p><pre><code>flashplayer_sa_debug.exe player.swf?id=1
</code></pre><p>即可启动 <a class=link href=https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe target=_blank rel=noopener>flash_player_debugger</a> 并打开作为参数的 <code>.swf</code> 文件, 在<code>C#</code>中则可以使用<code>Process</code>启动, 代码如下:</p><pre><code>Process.Start(&quot;flashplayer_sa_debug.exe&quot;, &quot;Main.swf?id=1&quot;);
</code></pre><p>但是在实际使用中, 发现通过命令行或者程序启动的 <a class=link href=https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe target=_blank rel=noopener>flash_player_debugger</a> 打开的<code>player.swf</code>无法发送<code>localhost</code>的网络请求, 弹窗报错如下:</p><pre><code>SecurityError: Error #2119: 安全沙箱冲突
</code></pre><p>但是通过IDEA启动的又可以, 查阅资料后最终确定是由于Adobe施加的安全策略影响, IDEA启动的能正常请求<code>localhost</code>是因为他在用户文件夹下<code>\AppData\Roaming\Macromediax\Flash Player\#Security\FlashPlayerTrust</code>创建了信任文件<code>intellij_idea.cfg</code>, 文件内容即IDEA生成<code>.swf</code>的完整文件夹路径</p><pre><code>E:\flash\bin-debug
</code></pre><p><strong>所以, 我只需要为乐谱工具所在的文件夹也创建信任文件, 内容为乐谱工具完整路径, 就能正常打开并请求<code>localhost</code>了</strong></p><p>现在解决了乐谱无法播放的问题, 但是由于<a class=link href=https://www.flash.cn/cdm/latest/flashplayer_sa_debug.exe target=_blank rel=noopener>flash_player_debugger</a>不支持<code>ExternalInterface</code>, 因此需要通过其他方式获取乐谱信息url, 于是我想到在播放器启动的时候, 根据传入的乐谱ID, 直接调用<code>getURL</code>获取乐谱信息url, 并通过HTTP将url中的参数作为请求参数, 发送到乐谱工具开启的HTTP监听服务中, 再根据得到的参数请求某琴吧获取乐谱详细信息.</p><p>首先删除会引起报错的<code>player.swf</code>中使用<code>ExternalInterface</code>定义的接口<code>swfExtGetypURL</code>, 修改 <code>myLoadSwf</code>中定义的回调函数 <code>onSoundsReady</code>, 在此前初始化<code>clib</code>的基础上加上调用<code>getURL</code>返回的url, 并提取参数请求<code>localhost:7777</code>, 修改后的代码如下:</p><pre><code>internal static function onSoundsReady(arg1:Event) : void
{
    swfLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,onSoundsReady);
    var loc1:* = swfLoader.contentLoaderInfo.applicationDomain;
    var loc2:* = loc1.getDefinition(&quot;Sounds&quot;) as Class;
    CLib.clib = loc2.cLibInit();
    //添加的部分
    if(utils.Func.ypadId != 0) {
        var url:* = CLib.getURL(utils.Func.ypadId);
        var args:* = &quot;?&quot; + url.split(&quot;?&quot;)[1]
        urlLoader3 = new flash.net.URLLoader();
        urlLoader3.load(new flash.net.URLRequest(&quot;http://localhost:7777/yuepu/fetch&quot; + args));
    }
}
</code></pre><blockquote><p><code>utils.Func.ypadId</code>中存储了播放器启动时传入的乐谱ID参数</p></blockquote><p>此时当<code>clib</code>初始化完成之后, 会使用传入的乐谱ID直接调用<code>getURL</code>, 截取返回url的参数部分, 再将参数通过HTTP请求上报到<code>localhost:7777</code>. 收到请求后, 首先判断该ID的乐谱是否已经下载, 如果没有下载则会开启下载任务, 这样就解决了乐谱下载的问题</p><pre><code>//监听曲谱地址
if (httpListenerContext.Request.Url.LocalPath.Equals(&quot;/yuepu/fetch&quot;))
{
    httpListenerContext.Request.QueryString[&quot;ypid&quot;];
    httpListenerContext.Request.QueryString[&quot;sccode&quot;];
    httpListenerContext.Request.QueryString[&quot;r1&quot;];
    httpListenerContext.Request.QueryString[&quot;r2&quot;];
    ...
}
</code></pre><p>不过这样的弊端也很明显, 想要下载下一个乐谱就要重新打开一次播放器, 因此在使用<code>Process</code>启动的指定<code>WindowStyle</code>为<code>ProcessWindowStyle.Hidden</code>就可以无感使用了</p><pre><code>Process.Start(new ProcessStartInfo()
{
    FileName = &quot;flashplayer_sa_debug.exe&quot;,
    WindowStyle = ProcessWindowStyle.Hidden,//关键代码
    Arguments = &quot;Main.swf?id=64&quot;,
})
</code></pre><h2 id=至此已经彻底解决flash停用的影响了-但是仍然存在另一个问题-adobe禁用flash之后-某琴吧也对播放器进行了换代-停用了旧的flash播放器-改用安装版的exe播放器-同时exe播放器不再使用flash用的ypa2格式播放器文件-且删除了所有ypa2资源-并采用新的ypdx文件-新格式的文件flash无法播放-因此破解exe版本的播放器又被放在日程上了>至此已经彻底解决Flash停用的影响了, 但是仍然存在另一个问题, Adobe禁用Flash之后, 某琴吧也对播放器进行了换代, 停用了旧的Flash播放器, 改用安装版的exe播放器, 同时exe播放器不再使用Flash用的<code>.ypa2</code>格式播放器文件, 且删除了所有<code>.ypa2</code>资源, 并采用新的<code>.ypdx</code>文件, 新格式的文件Flash无法播放, 因此破解exe版本的播放器又被放在日程上了&mldr;</h2></section><footer class=article-footer><section class=article-tags><a href=/tags/hack/>Hack</a>
<a href=/tags/flash/>Flash</a>
<a href=/tags/flex/>Flex</a>
<a href=/tags/actionscript/>ActionScript</a>
<a href=/tags/.net/>.NET</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2021 Acgnu+</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.3.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script></body></html>